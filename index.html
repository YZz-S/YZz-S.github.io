<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>YZz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1637200696663.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1637200696663.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">YZz</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-SpringBoot学习路上遇到的坑"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/11/19/SpringBoot%E5%AD%A6%E4%B9%A0%E8%B7%AF%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">SpringBoot学习路上遇到的问题</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="数据库无法连接"><a href="#数据库无法连接" class="headerlink" title="数据库无法连接"></a>数据库无法连接</h1><ol>
<li><p>配置文件异常 例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">		<span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">		<span class="attr">Url:</span> <span class="string">jdbc:mysql://:/WXDinner?</span></span><br><span class="line">		<span class="attr">username:</span> </span><br><span class="line">		<span class="attr">password:</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是下方的方式可以使用</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.driver-class-name=</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://:/WXDinner?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false</span></span><br><span class="line"><span class="string">spring.datasource.username=</span></span><br><span class="line"><span class="string">spring.datasource.password=</span></span><br></pre></td></tr></table></figure></li>
<li><p>没装连接用的jar包</p>
</li>
</ol>
<h1 id="SpringBoot测试"><a href="#SpringBoot测试" class="headerlink" title="SpringBoot测试"></a>SpringBoot测试</h1><p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;----- selectAll method test ------&quot;</span>));</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">5</span>, userList.size());</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Service错误"><a href="#Service错误" class="headerlink" title="Service错误"></a>Service错误</h1><p>未使用注释@Service,若使用serviceimp则应在impl中标注@Service</p>
<h1 id="org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found"><a href="#org-apache-ibatis-binding-BindingException-Invalid-bound-statement-not-found" class="headerlink" title="org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)"></a>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)</h1><p>mapper.java与mapper.xml文件名应相同</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mapper-locations未配置正确</span></span><br></pre></td></tr></table></figure>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-19T01:23:18.000Z" itemprop="datePublished">2021-11-19</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-遇到的问题_KafKa"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_KafKa/">KafKa学习路上遇到的问题</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>Connection to node -1 could not be established. Broker may not be available.</p>
<p>卡夫卡配置文件中监听地址存在问题，未设置IP</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-19T01:23:18.000Z" itemprop="datePublished">2021-11-19</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KafKa/" rel="tag">KafKa</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-遇到的问题以及解决方案_MyBatis"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88_MyBatis/">MyBatis学习路上遇到的问题</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="mybatis-Plus-多表联合查询"><a href="#mybatis-Plus-多表联合查询" class="headerlink" title="mybatis Plus 多表联合查询"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LQ970811/p/12100296.html">mybatis Plus 多表联合查询</a></h1><p>//实体类package com.sk.skkill.entity;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TableName(&quot;orders&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>  serialVersionUID =<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="keyword">private</span> String userID;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span>  List&lt;Users&gt;  listUsers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String id, String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//dao层</span></span><br><span class="line"><span class="keyword">package</span> com.sk.skkill.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.entity.Order;</span><br><span class="line"><span class="keyword">import</span> com.sun.javafx.collections.MappingChange;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Order</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function">List&lt;Order&gt; <span class="title">selectOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多表联合查询 按条件orderID</span></span><br><span class="line"><span class="meta">@Select(&quot;select t1.*,t2.user_name,t2.nick_name from orders t1 LEFT JOIN  users t2  ON t1.user_id =t2.id WHERE t1.user_id= #&#123;id&#125;&quot;)</span></span><br><span class="line"> List&lt;Map&lt;String,Object&gt;&gt; orderUserList(Page&lt;Map&lt;String,Object&gt;&gt; page,String id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//service层</span></span><br><span class="line"><span class="keyword">package</span> com.sk.skkill.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.entity.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">Order</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">selectOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line"><span class="comment">//    List&lt;Map&lt;String,Object&gt;&gt; orderUserList(Page&lt;Map&lt;String,Object&gt;&gt; page, String id);</span></span><br><span class="line">    Page&lt;Map&lt;String,Object&gt;&gt; selectListPage(<span class="keyword">int</span> current,<span class="keyword">int</span> number,String id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//serviceImpl层</span></span><br><span class="line"><span class="keyword">package</span> com.sk.skkill.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.entity.Order;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.mapper.OrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">OrderMapper</span>, <span class="title">Order</span>&gt; <span class="keyword">implements</span> <span class="title">OrderService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">selectOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insert(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;Map&lt;String, Object&gt;&gt; selectListPage(<span class="keyword">int</span> current, <span class="keyword">int</span> number,String id) &#123;</span><br><span class="line">        <span class="comment">//新建分页</span></span><br><span class="line">        Page&lt;Map&lt;String,Object&gt;&gt; page =<span class="keyword">new</span> Page&lt;Map&lt;String,Object&gt;&gt;(current,number);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span>  page.setRecords(<span class="keyword">this</span>.baseMapper.orderUserList(page,id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//controller层</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sk.skkill.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.entity.Order;</span><br><span class="line"><span class="keyword">import</span> com.sk.skkill.service.impl.OrderServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderServiceImpl service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;selectOrder&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">selectOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.selectOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;addOrder&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">addOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        order=<span class="keyword">new</span> Order(<span class="string">&quot;FGGG&quot;</span>,<span class="string">&quot;蒙牛MILK&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> service.addOrder(order);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@RequestMapping(&quot;selectListPage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span>  List&lt;Map&lt;String,Object&gt;&gt;   selectListPage(String id)</span><br><span class="line">    &#123;</span><br><span class="line">        Page&lt;Map&lt;String, Object&gt;&gt; page = service.selectListPage(<span class="number">1</span>, <span class="number">2</span>,id);</span><br><span class="line">        <span class="keyword">return</span> page.getRecords();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MapperScan配置问题"><a href="#MapperScan配置问题" class="headerlink" title="MapperScan配置问题"></a>MapperScan配置问题</h1><h2 id="在Application中著名包名，例"><a href="#在Application中著名包名，例" class="headerlink" title="在Application中著名包名，例"></a>在Application中著名包名，例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.InterviewPreparation.learning.MyBatisPlus.mapper&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="写一个配置类，例"><a href="#写一个配置类，例" class="headerlink" title="写一个配置类，例"></a>写一个配置类，例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZYZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/13 20:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(value = &#123;&quot;com.InterviewPreparation.learning.MyBatisPlus.mapper*&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置文件中表示"><a href="#配置文件中表示" class="headerlink" title="配置文件中表示"></a>配置文件中表示</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath*:org/jeecg/modules/**/xml/*Mapper.xml</span></span><br></pre></td></tr></table></figure>

<h1 id="代码生成器使用"><a href="#代码生成器使用" class="headerlink" title="代码生成器使用"></a>代码生成器使用</h1><h1 id="CRUD-接口"><a href="#CRUD-接口" class="headerlink" title="CRUD 接口"></a>CRUD 接口</h1><h2 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="#Service CRUD 接口"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#service-crud-%E6%8E%A5%E5%8F%A3">#</a>Service CRUD 接口</h2><p>说明:</p>
<ul>
<li>通用 Service CRUD 封装<a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</li>
<li>泛型 <code>T</code> 为任意实体对象</li>
<li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</li>
<li>对象 <code>Wrapper</code> 为 <a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html">条件构造器</a></li>
</ul>
<h3 id="Save"><a href="#Save" class="headerlink" title="#Save"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#save">#</a>Save</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明"><a href="#参数说明" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">entity</td>
<td align="center">实体对象</td>
</tr>
<tr>
<td align="center">Collection<T></td>
<td align="center">entityList</td>
<td align="center">实体对象集合</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">batchSize</td>
<td align="center">插入批次数量</td>
</tr>
</tbody></table>
<h3 id="SaveOrUpdate"><a href="#SaveOrUpdate" class="headerlink" title="#SaveOrUpdate"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#saveorupdate">#</a>SaveOrUpdate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdate</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-2">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">entity</td>
<td align="center">实体对象</td>
</tr>
<tr>
<td align="center">Wrapper<T></td>
<td align="center">updateWrapper</td>
<td align="center">实体对象封装操作类 UpdateWrapper</td>
</tr>
<tr>
<td align="center">Collection<T></td>
<td align="center">entityList</td>
<td align="center">实体对象集合</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">batchSize</td>
<td align="center">插入批次数量</td>
</tr>
</tbody></table>
<h3 id="Remove"><a href="#Remove" class="headerlink" title="#Remove"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#remove">#</a>Remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-3">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wrapper<T></td>
<td align="center">queryWrapper</td>
<td align="center">实体包装类 QueryWrapper</td>
</tr>
<tr>
<td align="center">Serializable</td>
<td align="center">id</td>
<td align="center">主键ID</td>
</tr>
<tr>
<td align="center">Map&lt;String, Object&gt;</td>
<td align="center">columnMap</td>
<td align="center">表字段 map 对象</td>
</tr>
<tr>
<td align="center">Collection&lt;? extends Serializable&gt;</td>
<td align="center">idList</td>
<td align="center">主键ID列表</td>
</tr>
</tbody></table>
<h3 id="Update"><a href="#Update" class="headerlink" title="#Update"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#update">#</a>Update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateById</span><span class="params">(T entity)</span></span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span></span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-4">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wrapper<T></td>
<td align="center">updateWrapper</td>
<td align="center">实体对象封装操作类 UpdateWrapper</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">entity</td>
<td align="center">实体对象</td>
</tr>
<tr>
<td align="center">Collection<T></td>
<td align="center">entityList</td>
<td align="center">实体对象集合</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">batchSize</td>
<td align="center">更新批次数量</td>
</tr>
</tbody></table>
<h3 id="Get"><a href="#Get" class="headerlink" title="#Get"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#get">#</a>Get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">getById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="function">T <span class="title">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="keyword">boolean</span> throwEx)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; <span class="function">V <span class="title">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-5">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serializable</td>
<td align="center">id</td>
<td align="center">主键ID</td>
</tr>
<tr>
<td align="center">Wrapper<T></td>
<td align="center">queryWrapper</td>
<td align="center">实体对象封装操作类 QueryWrapper</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">throwEx</td>
<td align="center">有多个 result 是否抛出异常</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">entity</td>
<td align="center">实体对象</td>
</tr>
<tr>
<td align="center">Function&lt;? super Object, V&gt;</td>
<td align="center">mapper</td>
<td align="center">转换函数</td>
</tr>
</tbody></table>
<h3 id="List"><a href="#List" class="headerlink" title="#List"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#list">#</a>List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMaps();</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">listObjs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; <span class="function">List&lt;V&gt; <span class="title">listObjs</span><span class="params">(Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; <span class="function">List&lt;V&gt; <span class="title">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="keyword">super</span> Object, V&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-6">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wrapper<T></td>
<td align="center">queryWrapper</td>
<td align="center">实体对象封装操作类 QueryWrapper</td>
</tr>
<tr>
<td align="center">Collection&lt;? extends Serializable&gt;</td>
<td align="center">idList</td>
<td align="center">主键ID列表</td>
</tr>
<tr>
<td align="center">Map&lt;?String, Object&gt;</td>
<td align="center">columnMap</td>
<td align="center">表字段 map 对象</td>
</tr>
<tr>
<td align="center">Function&lt;? super Object, V&gt;</td>
<td align="center">mapper</td>
<td align="center">转换函数</td>
</tr>
</tbody></table>
<h3 id="Page"><a href="#Page" class="headerlink" title="#Page"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#page">#</a>Page</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">page</span><span class="params">(IPage&lt;T&gt; page)</span></span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-7">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IPage<T></td>
<td align="center">page</td>
<td align="center">翻页对象</td>
</tr>
<tr>
<td align="center">Wrapper<T></td>
<td align="center">queryWrapper</td>
<td align="center">实体对象封装操作类 QueryWrapper</td>
</tr>
</tbody></table>
<h3 id="Count"><a href="#Count" class="headerlink" title="#Count"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#count">#</a>Count</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-8">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wrapper<T></td>
<td align="center">queryWrapper</td>
<td align="center">实体对象封装操作类 QueryWrapper</td>
</tr>
</tbody></table>
<h3 id="Chain"><a href="#Chain" class="headerlink" title="#Chain"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#chain">#</a>Chain</h3><h4 id="query"><a href="#query" class="headerlink" title="#query"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#query">#</a>query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式查询 普通</span></span><br><span class="line"><span class="function">QueryChainWrapper&lt;T&gt; <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 链式查询 lambda 式。注意：不支持 Kotlin</span></span><br><span class="line"><span class="function">LambdaQueryChainWrapper&lt;T&gt; <span class="title">lambdaQuery</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">query().eq(<span class="string">&quot;column&quot;</span>, value).one();</span><br><span class="line">lambdaQuery().eq(Entity::getId, value).list();</span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="#update"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#update-2">#</a>update</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式更改 普通</span></span><br><span class="line"><span class="function">UpdateChainWrapper&lt;T&gt; <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 链式更改 lambda 式。注意：不支持 Kotlin </span></span><br><span class="line"><span class="function">LambdaUpdateChainWrapper&lt;T&gt; <span class="title">lambdaUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">update().eq(<span class="string">&quot;column&quot;</span>, value).remove();</span><br><span class="line">lambdaUpdate().eq(Entity::getId, value).update(entity);</span><br></pre></td></tr></table></figure>

<h2 id="Mapper-CRUD-接口"><a href="#Mapper-CRUD-接口" class="headerlink" title="#Mapper CRUD 接口"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#mapper-crud-%E6%8E%A5%E5%8F%A3">#</a>Mapper CRUD 接口</h2><p>说明:</p>
<ul>
<li>通用 CRUD 封装<a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-core/src/main/java/com/baomidou/mybatisplus/core/mapper/BaseMapper.java">BaseMapper (opens new window)</a>接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li>
<li>泛型 <code>T</code> 为任意实体对象</li>
<li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li>
<li>对象 <code>Wrapper</code> 为 <a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html">条件构造器</a></li>
</ul>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="#Insert"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#insert">#</a>Insert</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(T entity)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-9">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">entity</td>
<td align="center">实体对象</td>
</tr>
</tbody></table>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="#Delete"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#delete">#</a>Delete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span></span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-9"><a href="#参数说明-9" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-10">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Wrapper<T></td>
<td align="center">wrapper</td>
<td align="center">实体对象封装操作类（可以为 null）</td>
</tr>
<tr>
<td align="center">Collection&lt;? extends Serializable&gt;</td>
<td align="center">idList</td>
<td align="center">主键ID列表(不能为 null 以及 empty)</td>
</tr>
<tr>
<td align="center">Serializable</td>
<td align="center">id</td>
<td align="center">主键ID</td>
</tr>
<tr>
<td align="center">Map&lt;String, Object&gt;</td>
<td align="center">columnMap</td>
<td align="center">表字段 map 对象</td>
</tr>
</tbody></table>
<h3 id="Update-1"><a href="#Update-1" class="headerlink" title="#Update"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#update-3">#</a>Update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-10"><a href="#参数说明-10" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-11">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">entity</td>
<td align="center">实体对象 (set 条件值,可为 null)</td>
</tr>
<tr>
<td align="center">Wrapper<T></td>
<td align="center">updateWrapper</td>
<td align="center">实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td>
</tr>
</tbody></table>
<h3 id="Select"><a href="#Select" class="headerlink" title="#Select"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#select">#</a>Select</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line"><span class="function">T <span class="title">selectById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line"><span class="function">T <span class="title">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;</span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; selectMaps(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line"><span class="function">List&lt;Object&gt; <span class="title">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="function">IPage&lt;T&gt; <span class="title">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper);</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="function">Integer <span class="title">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="参数说明-11"><a href="#参数说明-11" class="headerlink" title="#参数说明"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-12">#</a>参数说明</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">参数名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serializable</td>
<td align="center">id</td>
<td align="center">主键ID</td>
</tr>
<tr>
<td align="center">Wrapper<T></td>
<td align="center">queryWrapper</td>
<td align="center">实体对象封装操作类（可以为 null）</td>
</tr>
<tr>
<td align="center">Collection&lt;? extends Serializable&gt;</td>
<td align="center">idList</td>
<td align="center">主键ID列表(不能为 null 以及 empty)</td>
</tr>
<tr>
<td align="center">Map&lt;String, Object&gt;</td>
<td align="center">columnMap</td>
<td align="center">表字段 map 对象</td>
</tr>
<tr>
<td align="center">IPage<T></td>
<td align="center">page</td>
<td align="center">分页查询条件（可以为 RowBounds.DEFAULT）</td>
</tr>
</tbody></table>
<h2 id="mapper-层-选装件"><a href="#mapper-层-选装件" class="headerlink" title="#mapper 层 选装件"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#mapper-%E5%B1%82-%E9%80%89%E8%A3%85%E4%BB%B6">#</a>mapper 层 选装件</h2><p>说明:</p>
<p>选装件位于 <code>com.baomidou.mybatisplus.extension.injector.methods</code> 包下 需要配合<a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/sql-injector.html">Sql 注入器</a>使用,<a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-sql-injector">案例(opens new window)</a><br>使用详细见<a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus/tree/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/injector/methods">源码注释(opens new window)</a></p>
<h3 id="AlwaysUpdateSomeColumnById-opens-new-window"><a href="#AlwaysUpdateSomeColumnById-opens-new-window" class="headerlink" title="#AlwaysUpdateSomeColumnById(opens new window)"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#alwaysupdatesomecolumnbyid">#</a><a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/injector/methods/AlwaysUpdateSomeColumnById.java">AlwaysUpdateSomeColumnById(opens new window)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alwaysUpdateSomeColumnById</span><span class="params">(T entity)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="insertBatchSomeColumn-opens-new-window"><a href="#insertBatchSomeColumn-opens-new-window" class="headerlink" title="#insertBatchSomeColumn(opens new window)"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#insertbatchsomecolumn">#</a><a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/injector/methods/InsertBatchSomeColumn.java">insertBatchSomeColumn(opens new window)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertBatchSomeColumn</span><span class="params">(List&lt;T&gt; entityList)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="deleteByIdWithFill-opens-new-window"><a href="#deleteByIdWithFill-opens-new-window" class="headerlink" title="#deleteByIdWithFill(opens new window)"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/crud-interface.html#deletebyidwithfill">#</a><a target="_blank" rel="noopener" href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/injector/methods/LogicDeleteByIdWithFill.java">deleteByIdWithFill(opens new window)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByIdWithFill</span><span class="params">(T entity)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="条件构造器"><a href="#条件构造器" class="headerlink" title="#条件构造器"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8">#</a>条件构造器</h1><p>说明:</p>
<ul>
<li>以下出现的第一个入参<code>boolean condition</code>表示该条件<strong>是否</strong>加入最后生成的sql中，例如：query.like(StringUtils.isNotBlank(name), Entity::getName, name) .eq(age!=null &amp;&amp; age &gt;= 0, Entity::getAge, age)</li>
<li>以下代码块内的多个方法均为从上往下补全个别<code>boolean</code>类型的入参,默认为<code>true</code></li>
<li>以下出现的泛型<code>Param</code>均为<code>Wrapper</code>的子类实例(均具有<code>AbstractWrapper</code>的所有方法)</li>
<li>以下方法在入参中出现的<code>R</code>为泛型,在普通wrapper中是<code>String</code>,在LambdaWrapper中是<strong>函数</strong>(例:<code>Entity::getId</code>,<code>Entity</code>为实体类,<code>getId</code>为字段<code>id</code>的<strong>getMethod</strong>)</li>
<li>以下方法入参中的<code>R column</code>均表示数据库字段,当<code>R</code>具体类型为<code>String</code>时则为数据库字段名(<strong>字段名是数据库关键字的自己用转义符包裹!</strong>)!而不是实体类数据字段名!!!,另当<code>R</code>具体类型为<code>SFunction</code>时项目runtime不支持eclipse自家的编译器!!!</li>
<li>以下举例均为使用普通wrapper,入参为<code>Map</code>和<code>List</code>的均以<code>json</code>形式表现!</li>
<li>使用中如果入参的<code>Map</code>或者<code>List</code>为<strong>空</strong>,则不会加入最后生成的sql中!!!</li>
<li>有任何疑问就点开源码看,看不懂<strong>函数</strong>的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/613a6118e2e0">点击我学习新知识(opens new window)</a></li>
</ul>
<p>警告:</p>
<p>不支持以及不赞成在 RPC 调用中把 Wrapper 进行传输</p>
<ol>
<li>wrapper 很重</li>
<li>传输 wrapper 可以类比为你的 controller 用 map 接收值(开发一时爽,维护火葬场)</li>
<li>正确的 RPC 调用姿势是写一个 DTO 进行传输,被调用方再根据 DTO 执行相应的操作</li>
<li>我们拒绝接受任何关于 RPC 传输 Wrapper 报错相关的 issue 甚至 pr</li>
</ol>
<h2 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="#AbstractWrapper"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#abstractwrapper">#</a>AbstractWrapper</h2><p>说明:</p>
<p>QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类<br>用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件<br>注意: entity 生成的 where 条件与 使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p>
<h3 id="allEq"><a href="#allEq" class="headerlink" title="#allEq"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#alleq">#</a>allEq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allEq(Map&lt;R, V&gt; params)</span><br><span class="line">allEq(Map&lt;R, V&gt; params, <span class="keyword">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="keyword">boolean</span> condition, Map&lt;R, V&gt; params, <span class="keyword">boolean</span> null2IsNull)</span><br></pre></td></tr></table></figure>

<ul>
<li>全部<a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#eq">eq</a>(或个别<a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#isnull">isNull</a>)</li>
</ul>
<p>个别参数说明:</p>
<p><code>params</code> : <code>key</code>为数据库字段名,<code>value</code>为字段值<br><code>null2IsNull</code> : 为<code>true</code>则在<code>map</code>的<code>value</code>为<code>null</code>时调用 <a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#isnull">isNull</a> 方法,为<code>false</code>时则忽略<code>value</code>为<code>null</code>的</p>
<ul>
<li>例1: <code>allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;)</code>—&gt;<code>id = 1 and name = &#39;老王&#39; and age is null</code></li>
<li>例2: <code>allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;, false)</code>—&gt;<code>id = 1 and name = &#39;老王&#39;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params)</span><br><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="keyword">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="keyword">boolean</span> condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="keyword">boolean</span> null2IsNull) </span><br></pre></td></tr></table></figure>

<p>个别参数说明:</p>
<p><code>filter</code> : 过滤函数,是否允许字段传入比对条件中<br><code>params</code> 与 <code>null2IsNull</code> : 同上</p>
<ul>
<li>例1: <code>allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt;= 0, &#123;id:1,name:&quot;老王&quot;,age:null&#125;)</code>—&gt;<code>name = &#39;老王&#39; and age is null</code></li>
<li>例2: <code>allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt;= 0, &#123;id:1,name:&quot;老王&quot;,age:null&#125;, false)</code>—&gt;<code>name = &#39;老王&#39;</code></li>
</ul>
<h3 id="eq"><a href="#eq" class="headerlink" title="#eq"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#eq">#</a>eq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq(R column, Object val)</span><br><span class="line">eq(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>等于 =</li>
<li>例: <code>eq(&quot;name&quot;, &quot;老王&quot;)</code>—&gt;<code>name = &#39;老王&#39;</code></li>
</ul>
<h3 id="ne"><a href="#ne" class="headerlink" title="#ne"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#ne">#</a>ne</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ne(R column, Object val)</span><br><span class="line">ne(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>不等于 &lt;&gt;</li>
<li>例: <code>ne(&quot;name&quot;, &quot;老王&quot;)</code>—&gt;<code>name &lt;&gt; &#39;老王&#39;</code></li>
</ul>
<h3 id="gt"><a href="#gt" class="headerlink" title="#gt"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#gt">#</a>gt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gt(R column, Object val)</span><br><span class="line">gt(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>大于 &gt;</li>
<li>例: <code>gt(&quot;age&quot;, 18)</code>—&gt;<code>age &gt; 18</code></li>
</ul>
<h3 id="ge"><a href="#ge" class="headerlink" title="#ge"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#ge">#</a>ge</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ge(R column, Object val)</span><br><span class="line">ge(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>大于等于 &gt;=</li>
<li>例: <code>ge(&quot;age&quot;, 18)</code>—&gt;<code>age &gt;= 18</code></li>
</ul>
<h3 id="lt"><a href="#lt" class="headerlink" title="#lt"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#lt">#</a>lt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lt(R column, Object val)</span><br><span class="line">lt(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>小于 &lt;</li>
<li>例: <code>lt(&quot;age&quot;, 18)</code>—&gt;<code>age &lt; 18</code></li>
</ul>
<h3 id="le"><a href="#le" class="headerlink" title="#le"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#le">#</a>le</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">le(R column, Object val)</span><br><span class="line">le(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>小于等于 &lt;=</li>
<li>例: <code>le(&quot;age&quot;, 18)</code>—&gt;<code>age &lt;= 18</code></li>
</ul>
<h3 id="between"><a href="#between" class="headerlink" title="#between"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#between">#</a>between</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">between(R column, Object val1, Object val2)</span><br><span class="line">between(<span class="keyword">boolean</span> condition, R column, Object val1, Object val2)</span><br></pre></td></tr></table></figure>

<ul>
<li>BETWEEN 值1 AND 值2</li>
<li>例: <code>between(&quot;age&quot;, 18, 30)</code>—&gt;<code>age between 18 and 30</code></li>
</ul>
<h3 id="notBetween"><a href="#notBetween" class="headerlink" title="#notBetween"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#notbetween">#</a>notBetween</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notBetween(R column, Object val1, Object val2)</span><br><span class="line">notBetween(<span class="keyword">boolean</span> condition, R column, Object val1, Object val2)</span><br></pre></td></tr></table></figure>

<ul>
<li>NOT BETWEEN 值1 AND 值2</li>
<li>例: <code>notBetween(&quot;age&quot;, 18, 30)</code>—&gt;<code>age not between 18 and 30</code></li>
</ul>
<h3 id="like"><a href="#like" class="headerlink" title="#like"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#like">#</a>like</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">like(R column, Object val)</span><br><span class="line">like(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>LIKE ‘%值%’</li>
<li>例: <code>like(&quot;name&quot;, &quot;王&quot;)</code>—&gt;<code>name like &#39;%王%&#39;</code></li>
</ul>
<h3 id="notLike"><a href="#notLike" class="headerlink" title="#notLike"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#notlike">#</a>notLike</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notLike(R column, Object val)</span><br><span class="line">notLike(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>NOT LIKE ‘%值%’</li>
<li>例: <code>notLike(&quot;name&quot;, &quot;王&quot;)</code>—&gt;<code>name not like &#39;%王%&#39;</code></li>
</ul>
<h3 id="likeLeft"><a href="#likeLeft" class="headerlink" title="#likeLeft"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#likeleft">#</a>likeLeft</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">likeLeft(R column, Object val)</span><br><span class="line">likeLeft(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>LIKE ‘%值’</li>
<li>例: <code>likeLeft(&quot;name&quot;, &quot;王&quot;)</code>—&gt;<code>name like &#39;%王&#39;</code></li>
</ul>
<h3 id="likeRight"><a href="#likeRight" class="headerlink" title="#likeRight"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#likeright">#</a>likeRight</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">likeRight(R column, Object val)</span><br><span class="line">likeRight(<span class="keyword">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>LIKE ‘值%’</li>
<li>例: <code>likeRight(&quot;name&quot;, &quot;王&quot;)</code>—&gt;<code>name like &#39;王%&#39;</code></li>
</ul>
<h3 id="isNull"><a href="#isNull" class="headerlink" title="#isNull"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#isnull">#</a>isNull</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNull(R column)</span><br><span class="line">isNull(<span class="keyword">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 IS NULL</li>
<li>例: <code>isNull(&quot;name&quot;)</code>—&gt;<code>name is null</code></li>
</ul>
<h3 id="isNotNull"><a href="#isNotNull" class="headerlink" title="#isNotNull"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#isnotnull">#</a>isNotNull</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNotNull(R column)</span><br><span class="line">isNotNull(<span class="keyword">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 IS NOT NULL</li>
<li>例: <code>isNotNull(&quot;name&quot;)</code>—&gt;<code>name is not null</code></li>
</ul>
<h3 id="in"><a href="#in" class="headerlink" title="#in"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#in">#</a>in</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in(R column, Collection&lt;?&gt; value)</span><br><span class="line">in(<span class="keyword">boolean</span> condition, R column, Collection&lt;?&gt; value)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 IN (value.get(0), value.get(1), …)</li>
<li>例: <code>in(&quot;age&quot;,&#123;1,2,3&#125;)</code>—&gt;<code>age in (1,2,3)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in(R column, Object... values)</span><br><span class="line">in(<span class="keyword">boolean</span> condition, R column, Object... values)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 IN (v0, v1, …)</li>
<li>例: <code>in(&quot;age&quot;, 1, 2, 3)</code>—&gt;<code>age in (1,2,3)</code></li>
</ul>
<h3 id="notIn"><a href="#notIn" class="headerlink" title="#notIn"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#notin">#</a>notIn</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notIn(R column, Collection&lt;?&gt; value)</span><br><span class="line">notIn(<span class="keyword">boolean</span> condition, R column, Collection&lt;?&gt; value)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 NOT IN (value.get(0), value.get(1), …)</li>
<li>例: <code>notIn(&quot;age&quot;,&#123;1,2,3&#125;)</code>—&gt;<code>age not in (1,2,3)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notIn(R column, Object... values)</span><br><span class="line">notIn(<span class="keyword">boolean</span> condition, R column, Object... values)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 NOT IN (v0, v1, …)</li>
<li>例: <code>notIn(&quot;age&quot;, 1, 2, 3)</code>—&gt;<code>age not in (1,2,3)</code></li>
</ul>
<h3 id="inSql"><a href="#inSql" class="headerlink" title="#inSql"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#insql">#</a>inSql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inSql(R column, String inValue)</span><br><span class="line">inSql(<span class="keyword">boolean</span> condition, R column, String inValue)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 IN ( sql语句 )</li>
<li>例: <code>inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age in (1,2,3,4,5,6)</code></li>
<li>例: <code>inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)</code>—&gt;<code>id in (select id from table where id &lt; 3)</code></li>
</ul>
<h3 id="notInSql"><a href="#notInSql" class="headerlink" title="#notInSql"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#notinsql">#</a>notInSql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notInSql(R column, String inValue)</span><br><span class="line">notInSql(<span class="keyword">boolean</span> condition, R column, String inValue)</span><br></pre></td></tr></table></figure>

<ul>
<li>字段 NOT IN ( sql语句 )</li>
<li>例: <code>notInSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age not in (1,2,3,4,5,6)</code></li>
<li>例: <code>notInSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)</code>—&gt;<code>id not in (select id from table where id &lt; 3)</code></li>
</ul>
<h3 id="groupBy"><a href="#groupBy" class="headerlink" title="#groupBy"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#groupby">#</a>groupBy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupBy(R... columns)</span><br><span class="line">groupBy(<span class="keyword">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure>

<ul>
<li>分组：GROUP BY 字段, …</li>
<li>例: <code>groupBy(&quot;id&quot;, &quot;name&quot;)</code>—&gt;<code>group by id,name</code></li>
</ul>
<h3 id="orderByAsc"><a href="#orderByAsc" class="headerlink" title="#orderByAsc"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#orderbyasc">#</a>orderByAsc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderByAsc(R... columns)</span><br><span class="line">orderByAsc(<span class="keyword">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure>

<ul>
<li>排序：ORDER BY 字段, … ASC</li>
<li>例: <code>orderByAsc(&quot;id&quot;, &quot;name&quot;)</code>—&gt;<code>order by id ASC,name ASC</code></li>
</ul>
<h3 id="orderByDesc"><a href="#orderByDesc" class="headerlink" title="#orderByDesc"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#orderbydesc">#</a>orderByDesc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderByDesc(R... columns)</span><br><span class="line">orderByDesc(<span class="keyword">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure>

<ul>
<li>排序：ORDER BY 字段, … DESC</li>
<li>例: <code>orderByDesc(&quot;id&quot;, &quot;name&quot;)</code>—&gt;<code>order by id DESC,name DESC</code></li>
</ul>
<h3 id="orderBy"><a href="#orderBy" class="headerlink" title="#orderBy"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#orderby">#</a>orderBy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderBy(<span class="keyword">boolean</span> condition, <span class="keyword">boolean</span> isAsc, R... columns)</span><br></pre></td></tr></table></figure>

<ul>
<li>排序：ORDER BY 字段, …</li>
<li>例: <code>orderBy(true, true, &quot;id&quot;, &quot;name&quot;)</code>—&gt;<code>order by id ASC,name ASC</code></li>
</ul>
<h3 id="having"><a href="#having" class="headerlink" title="#having"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#having">#</a>having</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">having(String sqlHaving, Object... params)</span><br><span class="line">having(<span class="keyword">boolean</span> condition, String sqlHaving, Object... params)</span><br></pre></td></tr></table></figure>

<ul>
<li>HAVING ( sql语句 )</li>
<li>例: <code>having(&quot;sum(age) &gt; 10&quot;)</code>—&gt;<code>having sum(age) &gt; 10</code></li>
<li>例: <code>having(&quot;sum(age) &gt; &#123;0&#125;&quot;, 11)</code>—&gt;<code>having sum(age) &gt; 11</code></li>
</ul>
<h3 id="func"><a href="#func" class="headerlink" title="#func"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#func">#</a>func</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(Consumer&lt;Children&gt; consumer)</span><br><span class="line">func(<span class="keyword">boolean</span> condition, Consumer&lt;Children&gt; consumer)</span><br></pre></td></tr></table></figure>

<ul>
<li>func 方法(主要方便在出现if…else下调用不同方法能不断链)</li>
<li>例: <code>func(i -&gt; if(true) &#123;i.eq(&quot;id&quot;, 1)&#125; else &#123;i.ne(&quot;id&quot;, 1)&#125;)</code></li>
</ul>
<h3 id="or"><a href="#or" class="headerlink" title="#or"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#or">#</a>or</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or()</span><br><span class="line">or(<span class="keyword">boolean</span> condition)</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接 OR</li>
</ul>
<p>注意事项:</p>
<p>主动调用<code>or</code>表示紧接着下一个<strong>方法</strong>不是用<code>and</code>连接!(不调用<code>or</code>则默认为使用<code>and</code>连接)</p>
<ul>
<li>例: <code>eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)</code>—&gt;<code>id = 1 or name = &#39;老王&#39;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="keyword">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure>

<ul>
<li>OR 嵌套</li>
<li>例: <code>or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li>
</ul>
<h3 id="and"><a href="#and" class="headerlink" title="#and"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#and">#</a>and</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(Consumer&lt;Param&gt; consumer)</span><br><span class="line">and(<span class="keyword">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure>

<ul>
<li>AND 嵌套</li>
<li>例: <code>and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li>
</ul>
<h3 id="nested"><a href="#nested" class="headerlink" title="#nested"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#nested">#</a>nested</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nested(Consumer&lt;Param&gt; consumer)</span><br><span class="line">nested(<span class="keyword">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure>

<ul>
<li>正常嵌套 不带 AND 或者 OR</li>
<li>例: <code>nested(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>—&gt;<code>(name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;)</code></li>
</ul>
<h3 id="apply"><a href="#apply" class="headerlink" title="#apply"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#apply">#</a>apply</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply(String applySql, Object... params)</span><br><span class="line">apply(<span class="keyword">boolean</span> condition, String applySql, Object... params)</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接 sql</li>
</ul>
<p>注意事项:</p>
<p>该方法可用于数据库<strong>函数</strong> 动态入参的<code>params</code>对应前面<code>applySql</code>内部的<code>&#123;index&#125;</code>部分.这样是不会有sql注入风险的,反之会有!</p>
<ul>
<li>例: <code>apply(&quot;id = 1&quot;)</code>—&gt;<code>id = 1</code></li>
<li>例: <code>apply(&quot;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;)</code>—&gt;<code>date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;)</code></li>
<li>例: <code>apply(&quot;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#123;0&#125;&quot;, &quot;2008-08-08&quot;)</code>—&gt;<code>date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;)</code></li>
</ul>
<h3 id="last"><a href="#last" class="headerlink" title="#last"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#last">#</a>last</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last(String lastSql)</span><br><span class="line">last(<span class="keyword">boolean</span> condition, String lastSql)</span><br></pre></td></tr></table></figure>

<ul>
<li>无视优化规则直接拼接到 sql 的最后</li>
</ul>
<p>注意事项:</p>
<p>只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</p>
<ul>
<li>例: <code>last(&quot;limit 1&quot;)</code></li>
</ul>
<h3 id="exists"><a href="#exists" class="headerlink" title="#exists"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#exists">#</a>exists</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists(String existsSql)</span><br><span class="line">exists(<span class="keyword">boolean</span> condition, String existsSql)</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接 EXISTS ( sql语句 )</li>
<li>例: <code>exists(&quot;select id from table where age = 1&quot;)</code>—&gt;<code>exists (select id from table where age = 1)</code></li>
</ul>
<h3 id="notExists"><a href="#notExists" class="headerlink" title="#notExists"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#notexists">#</a>notExists</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notExists(String notExistsSql)</span><br><span class="line">notExists(<span class="keyword">boolean</span> condition, String notExistsSql)</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接 NOT EXISTS ( sql语句 )</li>
<li>例: <code>notExists(&quot;select id from table where age = 1&quot;)</code>—&gt;<code>not exists (select id from table where age = 1)</code></li>
</ul>
<h2 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="#QueryWrapper"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#querywrapper">#</a>QueryWrapper</h2><p>说明:</p>
<p>继承自 AbstractWrapper ,自身的内部属性 entity 也用于生成 where 条件<br>及 LambdaQueryWrapper, 可以通过 new QueryWrapper().lambda() 方法获取</p>
<h3 id="select"><a href="#select" class="headerlink" title="#select"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#select">#</a>select</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置查询字段</li>
</ul>
<p>说明:</p>
<p>以上方法分为两类.<br>第二类方法为:过滤查询字段(主键除外),入参不包含 class 的调用前需要<code>wrapper</code>内的<code>entity</code>属性有值! 这两类方法重复调用以最后一次为准</p>
<ul>
<li>例: <code>select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</code></li>
<li>例: <code>select(i -&gt; i.getProperty().startsWith(&quot;test&quot;))</code></li>
</ul>
<h2 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="#UpdateWrapper"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#updatewrapper">#</a>UpdateWrapper</h2><p>说明:</p>
<p>继承自 <code>AbstractWrapper</code> ,自身的内部属性 <code>entity</code> 也用于生成 where 条件<br>及 <code>LambdaUpdateWrapper</code>, 可以通过 <code>new UpdateWrapper().lambda()</code> 方法获取!</p>
<h3 id="set"><a href="#set" class="headerlink" title="#set"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#set">#</a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="keyword">boolean</span> condition, String column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL SET 字段</li>
<li>例: <code>set(&quot;name&quot;, &quot;老李头&quot;)</code></li>
<li>例: <code>set(&quot;name&quot;, &quot;&quot;)</code>—&gt;数据库字段值变为<strong>空字符串</strong></li>
<li>例: <code>set(&quot;name&quot;, null)</code>—&gt;数据库字段值变为<code>null</code></li>
</ul>
<h3 id="setSql"><a href="#setSql" class="headerlink" title="#setSql"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#setsql">#</a>setSql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSql(String sql)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 SET 部分 SQL</li>
<li>例: <code>setSql(&quot;name = &#39;老李头&#39;&quot;)</code></li>
</ul>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="#lambda"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#lambda">#</a>lambda</h3><ul>
<li>获取 <code>LambdaWrapper</code><br>在<code>QueryWrapper</code>中是获取<code>LambdaQueryWrapper</code><br>在<code>UpdateWrapper</code>中是获取<code>LambdaUpdateWrapper</code></li>
</ul>
<h2 id="使用-Wrapper-自定义SQL"><a href="#使用-Wrapper-自定义SQL" class="headerlink" title="#使用 Wrapper 自定义SQL"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#%E4%BD%BF%E7%94%A8-wrapper-%E8%87%AA%E5%AE%9A%E4%B9%89sql">#</a>使用 Wrapper 自定义SQL</h2><p>注意事项:</p>
<p>需要<code>mybatis-plus</code>版本 &gt;= <code>3.0.7</code> param 参数名要么叫<code>ew</code>,要么加上注解<code>@Param(Constants.WRAPPER)</code> 使用<code>$&#123;ew.customSqlSegment&#125;</code> 不支持 <code>Wrapper</code> 内的entity生成where语句</p>
<h3 id="用注解"><a href="#用注解" class="headerlink" title="#用注解"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#%E7%94%A8%E6%B3%A8%E8%A7%A3">#</a>用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from mysql_data $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;MysqlData&gt; <span class="title">getAll</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="用XML"><a href="#用XML" class="headerlink" title="#用XML"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#%E7%94%A8xml">#</a>用XML</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;MysqlData&gt; <span class="title">getAll</span><span class="params">(Wrapper ew)</span></span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;getAll&quot;</span> resultType=<span class="string">&quot;MysqlData&quot;</span>&gt;</span><br><span class="line">	SELECT * FROM mysql_data $&#123;ew.customSqlSegment&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="kotlin使用wrapper"><a href="#kotlin使用wrapper" class="headerlink" title="#kotlin使用wrapper"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#kotlin%E4%BD%BF%E7%94%A8wrapper">#</a>kotlin使用wrapper</h3><blockquote>
<p>kotlin 可以使用 <code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 但无法使用 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code><br>如果想使用 lambda 方式的 wrapper 请使用 <code>KtQueryWrapper</code> 和 <code>KtUpdateWrapper</code></p>
</blockquote>
<h3 id="链式调用-lambda-式"><a href="#链式调用-lambda-式" class="headerlink" title="#链式调用 lambda 式"></a><a target="_blank" rel="noopener" href="https://mp.baomidou.com/guide/wrapper.html#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-lambda-%E5%BC%8F">#</a>链式调用 lambda 式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区分:</span></span><br><span class="line"><span class="comment">// 链式调用 普通</span></span><br><span class="line"><span class="function">UpdateChainWrapper&lt;T&gt; <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 链式调用 lambda 式。注意：不支持 Kotlin </span></span><br><span class="line"><span class="function">LambdaUpdateChainWrapper&lt;T&gt; <span class="title">lambdaUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价示例：</span></span><br><span class="line">query().eq(<span class="string">&quot;id&quot;</span>, value).one();</span><br><span class="line">lambdaQuery().eq(Entity::getId, value).one();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价示例：</span></span><br><span class="line">update().eq(<span class="string">&quot;id&quot;</span>, value).remove();</span><br><span class="line">lambdaUpdate().eq(Entity::getId, value).remove();</span><br></pre></td></tr></table></figure>


        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-19T01:23:18.000Z" itemprop="datePublished">2021-11-19</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-Unix程序设计课堂知识点整理"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">Unix程序设计课堂知识点整理</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="Linux编程基础"><a href="#Linux编程基础" class="headerlink" title="Linux编程基础"></a>Linux编程基础</h1><p>[TOC]</p>
<h2 id="1-1-从Unix到Linux"><a href="#1-1-从Unix到Linux" class="headerlink" title="1.1 从Unix到Linux"></a><strong>1.1</strong> 从Unix到Linux</h2><p>为了提升UNICS系统的性能与兼容性，采用高级语言对其进行重构，并确定该操作系统名称为UNIX，这就是最早的 UNIX 操作系统（相对于 Multics ，UNIX 具有单一的意思）</p>
<p>GNU通用公共许可协议（GNU GPL）是一个广泛被使用的自由软件许可协议条款，最初由Stallman为GNU计划而撰写，GPL授予程序接受人以下权利，或称“自由”：</p>
<p>  ⚫ 以任何目的运行此程序的自由；</p>
<p>  ⚫ 再发行复制件的自由；</p>
<p>  ⚫ 改进此程序，并公开发布改进的自由</p>
<h2 id="1-2-Linux概述"><a href="#1-2-Linux概述" class="headerlink" title="1.2 Linux概述"></a>1.2 Linux概述</h2><p>Linux是一个类Unix（Unix-like）的操作系统，在1991年发行了它的第一个版本</p>
<p>1991年11月，芬兰赫尔辛基大学的学生 Linus Torvalds写了个小程序，取名为Linux，放在互联网上。</p>
<p>1993，在一批高水平黑客的参与下，诞生了Linux 1.0 版 </p>
<p>1994年，Linux 的第一个商业发行版 Slackware 问世</p>
<p>1996年，美国国家标准技术局的计算机系统实验室确认 Linux 版本 1.2.13（由 Open Linux 公司打包）符合 POSIX 标准</p>
<h2 id="1-3-GNU-amp-Linux"><a href="#1-3-GNU-amp-Linux" class="headerlink" title="1.3 GNU &amp; Linux"></a><strong>1.3 GNU &amp; Linux</strong></h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611103621201.png" alt="image-20210611103621201"></p>
<h2 id="1-4-Linux-内核"><a href="#1-4-Linux-内核" class="headerlink" title="1.4 Linux 内核"></a><strong>1.4 Linux</strong> <strong>内核</strong></h2><p>Linux内核采用的是双树系统</p>
<p>一棵是稳定树，主要用于发行</p>
<p>另一棵是非稳定树或称为开发树，用于产品开发和改进 </p>
<p>Linux内核版本号由3位数字组成 </p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611103506715.png" alt="image-20210611103506715"></p>
<h2 id="2-2-Vi编辑器使用"><a href="#2-2-Vi编辑器使用" class="headerlink" title="2.2 Vi编辑器使用"></a>2.2 Vi编辑器使用</h2><h3 id="1-vi的工作模式"><a href="#1-vi的工作模式" class="headerlink" title="1.vi的工作模式"></a>1.vi的工作模式</h3><p>输入模式：输入字符为命令，可进行删除、修改、存盘等操作 。</p>
<p>命令模式：输入字符作为文本内容。 </p>
<p>末行模式：命令模式下输入“：/？”三个中任意一个，可移到屏幕最底一行。</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611103853138.png" alt="image-20210611103853138"></p>
<p>（1）命令模式</p>
<p>输入模式下，按ESC可切换到命令模式，常用命令： </p>
<table>
<thead>
<tr>
<th>：q!</th>
<th>离开vi，并放弃刚在缓冲区内编辑的内容</th>
</tr>
</thead>
<tbody><tr>
<td>：wq</td>
<td>将缓冲区内的资料写入磁盘中，并离开vi</td>
</tr>
<tr>
<td>：ZZ</td>
<td>同wq</td>
</tr>
<tr>
<td>：x</td>
<td>同wq</td>
</tr>
<tr>
<td>：w</td>
<td>将缓冲区内的资料写入磁盘中，但并不离开vi</td>
</tr>
<tr>
<td>：q</td>
<td>离开vi，若文件被修改过，则要被要求确认是否放弃修改的内容，此指令可与：w配合使用</td>
</tr>
</tbody></table>
<p>（2）输入模式</p>
<p>输入以下命令即可进入vi输入模式 </p>
<table>
<thead>
<tr>
<th>a(append)</th>
<th>在光标之后加入资料</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>在该行之末加入资料</td>
</tr>
<tr>
<td>i(insert)</td>
<td>在光标之前加入资料</td>
</tr>
<tr>
<td>I</td>
<td>在该行之首加入资料</td>
</tr>
<tr>
<td>o(open)</td>
<td>新增一行于该行之下，供输入资料用</td>
</tr>
<tr>
<td>O</td>
<td>新增一行于该行之上，供输入资料用</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前光标所在行</td>
</tr>
<tr>
<td>x</td>
<td>删除当前光标字符</td>
</tr>
<tr>
<td>X</td>
<td>删除当前光标之前字符</td>
</tr>
<tr>
<td>U</td>
<td>撤消</td>
</tr>
<tr>
<td>F</td>
<td>查找</td>
</tr>
<tr>
<td>ESC</td>
<td>离开输入模式</td>
</tr>
</tbody></table>
<h3 id="2-Vi其他功能命令"><a href="#2-Vi其他功能命令" class="headerlink" title="2.Vi其他功能命令"></a>2.Vi其他功能命令</h3><p>（1）复制粘贴</p>
<table>
<thead>
<tr>
<th>yw</th>
<th>将光标所在之处到字尾的字符复制到缓冲区</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标所在行到缓冲区</td>
</tr>
<tr>
<td>#yy</td>
<td>如：6yy表示拷贝从光标所在行往下数6行文字</td>
</tr>
<tr>
<td>p</td>
<td>将缓冲区内的字符贴到光标所在位置</td>
</tr>
</tbody></table>
<p>（2）查找/替换</p>
<table>
<thead>
<tr>
<th>?字符串</th>
<th>从当前光标位置开始向后查找字符串</th>
</tr>
</thead>
<tbody><tr>
<td>/字符串</td>
<td>从当前光标位置开始向前查找字符串</td>
</tr>
<tr>
<td>n</td>
<td>继续上一次查找</td>
</tr>
<tr>
<td>Shift+n</td>
<td>以相反的方向继续上一次查找</td>
</tr>
</tbody></table>
<p>（3）环境设置</p>
<table>
<thead>
<tr>
<th>:set ai</th>
<th>自动缩进，每一行开头都与上一行的开头对齐</th>
</tr>
</thead>
<tbody><tr>
<td>:set nu</td>
<td>编辑时显示行号</td>
</tr>
<tr>
<td>:set dir=./</td>
<td>将交换文件.swp保存在当前目录</td>
</tr>
<tr>
<td>:set sw=4</td>
<td>设置缩进的字符数为4</td>
</tr>
<tr>
<td>:syntax on  或者  :syntax=on</td>
<td>开启语法着色</td>
</tr>
</tbody></table>
<h2 id="3-1-GCC编译器介绍"><a href="#3-1-GCC编译器介绍" class="headerlink" title="3.1 GCC编译器介绍"></a>3.1 GCC编译器介绍</h2><p>GCC是一个强大的工具集合，它包含了预处理器、编译器、汇编器、链接器等组件。它会在需要的时候调用其他组件。<br> 输入文件的类型和传递给gcc的参数决定了gcc调用具体的哪些组件。</p>
<p><strong>GCC</strong> <strong>参数选项</strong></p>
<p>Usage:</p>
<p>gcc [options] [filename]</p>
<p>Basic options:</p>
<table>
<thead>
<tr>
<th>-E:</th>
<th>只对源程序进行预处理(调用cpp预处理器)</th>
</tr>
</thead>
<tbody><tr>
<td>-S:</td>
<td>只对源程序进行预处理、编译</td>
</tr>
<tr>
<td>-c:</td>
<td>执行预处理、编译、汇编而不链接</td>
</tr>
<tr>
<td>-o:</td>
<td>output_file: 指定输出文件名</td>
</tr>
<tr>
<td>-g:</td>
<td>产生调试工具必需的符号信息</td>
</tr>
<tr>
<td>-O/On:</td>
<td>在程序编译、链接过程中进行优化处理</td>
</tr>
<tr>
<td>-Wall:</td>
<td>显示所有的警告信息</td>
</tr>
<tr>
<td>-I dir:</td>
<td>在头文件的搜索路径中添加dir目录</td>
</tr>
<tr>
<td>-L dir :</td>
<td>在库文件的搜索路径列表中添加dir目录</td>
</tr>
</tbody></table>
<h2 id="3-2-GCC编译过程"><a href="#3-2-GCC编译过程" class="headerlink" title="3.2 GCC编译过程"></a>3.2 GCC编译过程</h2><p>1、预处理</p>
<p>2、编译成汇编代码</p>
<p>3、汇编成目标代码</p>
<p>4、链接</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>预处理：使用-E参数</p>
<p> gcc –E –o gcctest.i gcctest.c</p>
<p>使用wc命令比较预处理后的文件与源文件，可以看到两个文件的差异</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105310558.png" alt="image-20210611105310558"></p>
<h3 id="2-编译成汇编代码"><a href="#2-编译成汇编代码" class="headerlink" title="2.编译成汇编代码"></a>2.编译成汇编代码</h3><p>预处理文件—-&gt;汇编代码<br> 使用-S说明生成汇编代码后停止工作</p>
<p>gcc –S –o gcctest.s gcctest.i</p>
<p>直接编译到汇编代码</p>
<p> gcc –S gcctest.c</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105654986.png" alt="image-20210611105654986"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105702671.png" alt="image-20210611105702671"></p>
<h3 id="3-编译成目标代码"><a href="#3-编译成目标代码" class="headerlink" title="3.编译成目标代码"></a>3.编译成目标代码</h3><p>汇编代码à目标代码</p>
<p> gcc –x assembler –c gcctest.s</p>
<p>直接编译成目标代码</p>
<p> <strong>gcc</strong> <strong>–c</strong> <strong>gcctest.c</strong></p>
<p>使用汇编器生成目标代码</p>
<p>as –o gcctest.o gcctest.s</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105827814.png" alt="image-20210611105827814"></p>
<h3 id="4-编译成执行代码"><a href="#4-编译成执行代码" class="headerlink" title="4.编译成执行代码"></a>4.编译成执行代码</h3><p>目标代码à执行代码</p>
<p> gcc –o gcctest gcctest.o</p>
<p>直接生成执行代码</p>
<p> gcc –o gcctest gcctest.c</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105949690.png" alt="image-20210611105949690"></p>
<h2 id="3-3-GCC编译优化"><a href="#3-3-GCC编译优化" class="headerlink" title="3.3 GCC编译优化"></a>3.3 GCC编译优化</h2><p>优化编译选项有：</p>
<p>-O0<br> 缺省情况，不优化</p>
<p>-O1</p>
<p>-O2</p>
<p>-O3</p>
<p>等等</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611110447409.png" alt="image-20210611110447409"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611110459630.png" alt="image-20210611110459630"></p>
<h2 id="3-4-头文件和库函数目录"><a href="#3-4-头文件和库函数目录" class="headerlink" title="3.4 头文件和库函数目录"></a><strong>3.4</strong> <strong>头文件和库函数目录</strong></h2><h3 id="1-GCC-–I-dir-参数使用"><a href="#1-GCC-–I-dir-参数使用" class="headerlink" title="1. GCC –I dir 参数使用"></a><strong>1. GCC –I</strong> <strong>dir</strong> <strong>参数使用</strong></h3><p>头文件和gcc不在同一目录下，用 –I dir指明头文件所在的目录。</p>
<p>#include &lt;&gt;：在默认路径“/usr/include”中搜索头文件    </p>
<p>#include “”：在本目录中搜索</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111109662.png" alt="image-20210611111109662"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111326888.png" alt="image-20210611111326888"></p>
<p>解决办法：</p>
<ol>
<li><p>gcc opt.c –o opt –I ./</p>
</li>
<li><p>修改main</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;my.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “my.h”</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-GCC创建函数库"><a href="#2-GCC创建函数库" class="headerlink" title="2. GCC创建函数库"></a><strong>2. GCC</strong>创建函数库</h3><p>函数库：公用函数定义为函数库，供其他程序使用。函数库分为静态库和动态库。</p>
<p>静态库：<strong>程序编译时会链接到目标代码中，程序运行时不再需要静态库</strong>。程序生成的可执行程序比较大。<strong>后缀名为“.a”</strong></p>
<p>动态库：程序编译时<strong>不会链接到目标代码</strong>，在程序<strong>运行时载入</strong>，运行时需要动态库存在。动态库可方便多个程序共享一个函数库。<strong>后缀名为”.so”</strong></p>
<p><strong>函数库的生成：由编译过的.o文件生成。</strong></p>
<h3 id="创建静态库："><a href="#创建静态库：" class="headerlink" title="创建静态库："></a>创建静态库：</h3><p>  1.将需要生成函数库的函数执行gcc –c，生成.o文件</p>
<p>​    gcc –c hello.c</p>
<p>  2.由.o文件创建静态库，静态库命名格式为：lib静态库名.a</p>
<p>​    ar -rv libmyhello.a hello.o</p>
<ol start="3">
<li><p>使用静态库：在调用静态库的程序编译时指定静态库名</p>
<p>$gcc –o hello main.c –L. –lmyhello</p>
<p>$./hello</p>
</li>
</ol>
<h3 id="创建动态库："><a href="#创建动态库：" class="headerlink" title="创建动态库："></a>创建动态库：</h3><p>1.由.o文件生成动态库，动态库的命名：lib动态库名.so</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc –shared –fPIC –o libmyhello.so hello.o</span><br><span class="line"></span><br><span class="line">gcc –shared –fPIC –o libmyhello.so hello.c （centos版本）</span><br></pre></td></tr></table></figure>

<p>  2.使用动态库：用gcc命令指定动态库名进行编译，编译之前需将动态库文件复制到系统默认库函数目录/usr/lib中或者设置搜索路径。  sudo ldconfig </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc –o hello main.c –L. –lmyhello</span><br><span class="line"></span><br><span class="line">gcc –o hello main.c –L. –lmyhello -Wl,-rpath=./</span><br></pre></td></tr></table></figure>



<h2 id="gdb-commands"><a href="#gdb-commands" class="headerlink" title="gdb commands"></a><strong>gdb</strong> <strong>commands</strong></h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111727753.png" alt="image-20210611111727753"></p>
<h2 id="Gdb-using"><a href="#Gdb-using" class="headerlink" title="Gdb using"></a><strong>Gdb</strong> <strong>using</strong></h2><p>$gdb filename</p>
<p>gdb将装入名为filename的<strong>可执行文件</strong>。</p>
<p>在编译时需要使用-g选项</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111834934.png" alt="image-20210611111834934"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111847709.png" alt="image-20210611111847709"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111917435.png" alt="image-20210611111917435"></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111947211.png" alt="image-20210611111947211"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111954948.png" alt="image-20210611111954948"></p>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a><strong>help</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112004401-1623381605418.png" alt="image-20210611112004401"></p>
<h4 id="设置断点-break"><a href="#设置断点-break" class="headerlink" title="设置断点 break"></a>设置断点 <strong>break</strong></h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112101376.png" alt="image-20210611112101376"></p>
<h3 id="显示断点信息-info-breakpoints"><a href="#显示断点信息-info-breakpoints" class="headerlink" title="显示断点信息 info breakpoints"></a>显示断点信息 <strong>info breakpoints</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112126359.png" alt="image-20210611112126359"></p>
<h3 id="清除已经定义的断点-clear"><a href="#清除已经定义的断点-clear" class="headerlink" title="清除已经定义的断点  clear"></a>清除已经定义的断点  <strong>clear</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112155046.png" alt="image-20210611112155046"></p>
<h3 id="delete-bkpoints-num-删除指定-全部断点"><a href="#delete-bkpoints-num-删除指定-全部断点" class="headerlink" title="delete [bkpoints-num]删除指定/全部断点"></a>delete [bkpoints-num]删除指定/全部断点</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112342864.png" alt="image-20210611112342864"></p>
<h3 id="print-bkpoints-num-输出断点处变量的值"><a href="#print-bkpoints-num-输出断点处变量的值" class="headerlink" title="print [bkpoints-num] 输出断点处变量的值"></a>print [bkpoints-num] 输出断点处变量的值</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112424180.png" alt="image-20210611112424180"></p>
<h3 id="quit-退出gdb"><a href="#quit-退出gdb" class="headerlink" title="quit:退出gdb"></a>quit:退出gdb</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112436348.png" alt="image-20210611112436348"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112521483.png" alt="image-20210611112521483"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112526161.png" alt="image-20210611112526161"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112545028.png" alt="image-20210611112545028"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112553240.png" alt="image-20210611112553240"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112603726.png" alt="image-20210611112603726"></p>
<h3 id="调试子命令总结"><a href="#调试子命令总结" class="headerlink" title="调试子命令总结"></a><strong>调试子命令总结</strong></h3><p>file ：装入想要调试的可执行文件</p>
<p>kill：终止正在调试的程序</p>
<p>list：列出正在执行的程序清单</p>
<p>next：执行一行代码但不进入函数内部</p>
<p>step：执行一行代码并进入函数内部</p>
<p>run： 执行当前正在调试的程序</p>
<p>quit：终止gdb调试</p>
<p>break：设置断点 （break 行号）</p>
<p>watch：设置观察点，观察表达式的值是否发</p>
<p>​         生变化</p>
<p><strong>info: 查看断点信息</strong></p>
<p>   <strong>info breakpoints、info watchpoints</strong></p>
<p>   <strong>info break 显示当前断点清单，包括到达</strong></p>
<p>​           <strong>断点处的次数等。</strong></p>
<p>   <strong>info files 显示被调试文件的详细信息。</strong></p>
<p>   <strong>info func 显示所有的函数名称。</strong></p>
<p>   <strong>info local 显示当函数中的局部变量信息。</strong></p>
<p>   <strong>info prog 显示被调试程序的执行状态。</strong></p>
<p>   <strong>info var 显示所有的全局和静态变量名称</strong></p>
<p><strong>delete: 删除某个或所有的断点</strong></p>
<p>​    <strong>delete 断点号  或 delete</strong></p>
<p><strong>disable: 使断点失效（但仍存在）</strong></p>
<p><strong>enable: 使断点有效</strong></p>
<p><strong>clear: 清除断点信息</strong></p>
<p>​    <strong>clear 断点所在行号</strong></p>
<p>​    <strong>clear 函数入口</strong></p>
<p><strong>continue: 继续执行程序直到程序结束</strong></p>
<h2 id="5-1-Make-引入"><a href="#5-1-Make-引入" class="headerlink" title="5.1 Make 引入"></a><strong>5.1 Make</strong> <strong>引入</strong></h2><p>Make的引入:</p>
<p>Ø文件数量太大,手工gcc编译不方便</p>
<p>Ø仅需要编译已经做了修改的源代码文件;其他文件只需要重新连接</p>
<p>Ø记录哪些文件已改变且需要编译，哪些文件仅仅需要连接很难</p>
<h3 id="make-amp-makefile"><a href="#make-amp-makefile" class="headerlink" title="make &amp; makefile"></a><strong>make &amp;</strong> <strong>makefile</strong></h3><h4 id="Multi-file-project"><a href="#Multi-file-project" class="headerlink" title="Multi-file project"></a>Multi-file project</h4><p>IDE—Eclipse</p>
<p>make</p>
<h4 id="make-amp-makefile-1"><a href="#make-amp-makefile-1" class="headerlink" title="make &amp; makefile"></a>make &amp; makefile</h4><p>makefile描述模块间的依赖关系；</p>
<p>make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系</p>
<h4 id="make"><a href="#make" class="headerlink" title="make"></a><strong>make</strong></h4><p>make [-f filename] [targetname]</p>
<p>使用方法：</p>
<p>v  <strong>make</strong>  自动找当前目录下名为Makefile/makefile的文件</p>
<p>v  <strong>make</strong> –f <strong>文件名</strong> 找当前目录下指定文件名的文件</p>
<h4 id="makefile的组成"><a href="#makefile的组成" class="headerlink" title="makefile的组成"></a><strong>makefile的组成</strong></h4><ul>
<li>显式规则：明确指出目标文件的生成规则</li>
<li>隐式规则：需要make自动推导的规则</li>
<li>变量定义：声明时赋值，引用时加”$”</li>
<li>文件指示：引用外部的文件</li>
<li>注释：#  </li>
</ul>
<h4 id="Makefile的显式规则"><a href="#Makefile的显式规则" class="headerlink" title="Makefile的显式规则"></a><strong>Makefile</strong>的显式规则</h4><p>规则<br> 一条规则包含3个方面的内容，</p>
<p>1）要创建的目标（文件），</p>
<p>2）创建目标（文件）所依赖的文件列表；</p>
<p>3）通过依赖文件创建目标文件的命令组</p>
<p>规则一般形式</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*target* ... : *prerequisites* ... </span><br><span class="line"></span><br><span class="line">*&lt;tab&gt;command* </span><br><span class="line"></span><br><span class="line">&lt;tab&gt;...</span><br><span class="line"></span><br><span class="line">&lt;tab&gt;...</span><br></pre></td></tr></table></figure>

<p>每条规则由一个带冒号的“依赖行”和一条或多条以<strong>tab</strong>开头的“命令行”组成</p>
<p>目标1 [目标2…]:[依赖文件列表]</p>
<p>[\t 命令]</p>
<p>…</p>
<p><em>ex:</em></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">*make_test:make_main.o* *wrtlog.o*</span></span><br><span class="line"></span><br><span class="line">**&lt;TAB&gt;***gcc* *-o* *make_test* *make_main.o* *wrtlog.o*</span><br></pre></td></tr></table></figure>

<p>冒号左边是目标,冒号右边是依赖文件</p>
<p>目标和依赖文件均是由字母、数字、句点和斜杠组成的字符串</p>
<p>目标或依赖文件的数目多于一个时，以空格分隔</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611160145895.png" alt="image-20210611160145895"></p>
<p><strong>一个简单的</strong>makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">	gcc -o edit main.o kbd.o command.o display.o insert.o \</span><br><span class="line">	search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">	gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">	gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">	gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">	gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">	gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">	gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">	gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">	gcc -c utils.c</span><br><span class="line"></span><br><span class="line">clean : </span><br><span class="line">	rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o </span><br></pre></td></tr></table></figure>

<h3 id="Make的工作过程"><a href="#Make的工作过程" class="headerlink" title="Make的工作过程"></a><strong>Make</strong>的工作过程</h3><p>default goal<br> 在缺省的情况下，make从makefile中的第一个目标开始执行</p>
<p>Make的工作过程类似一次深度优先遍历过程</p>
<h3 id="Makefile的变量"><a href="#Makefile的变量" class="headerlink" title="Makefile的变量"></a><strong>Makefile</strong>的变量</h3><p>自定义变量<br> 例：</p>
<p>   object=main.o Add.o Sub.o Mul.o Div.o</p>
<p>   exe : $(object)</p>
<p>   gcc -o exe $(object)</p>
<p>特殊变量</p>
<p>  $@：表示目标文件；</p>
<p>   $^：表示所有依赖目标的集合，以空格分隔；</p>
<p>   $&lt;：表示第一个依赖文件；</p>
<h3 id="Makefile的隐式规则（自动推导）"><a href="#Makefile的隐式规则（自动推导）" class="headerlink" title="Makefile的隐式规则（自动推导）"></a><strong>Makefile</strong>的隐式规则（自动推导）</h3><p>make能够自动推导文件以及文件依赖关系后面的命令</p>
<p>  例：</p>
<p>  object=main.o Add.o Sub.o Mul.o Div.o</p>
<p>  exe : $(object)</p>
<p>  gcc -o $@ $(object)</p>
<p>  main.o : def.h</p>
<h3 id="Makefile的伪目标"><a href="#Makefile的伪目标" class="headerlink" title="Makefile的伪目标"></a><strong>Makefile</strong>的伪目标</h3><p>lmakefile使用.PHONY关键字来定义一个伪目标，具体格式为：</p>
<p>  .PHONY : 伪目标名称</p>
<p>  例：</p>
<p>  .PHONY : clean</p>
<p>  clean :</p>
<p>​    rm $(object)</p>
<h2 id="总结-C语言编程步骤"><a href="#总结-C语言编程步骤" class="headerlink" title="总结: C语言编程步骤"></a><strong>总结</strong>: C语言编程步骤</h2><ol>
<li>编辑：vi ,emacs,gedit,Eclipse…</li>
<li>编译： gcc</li>
<li>调试：gdb</li>
<li>运行： ./executable file</li>
<li>项目管理：make</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h3><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>解释</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>file &lt;文件名&gt;</td>
<td>加载被调试的可执行程序文件。 因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。</td>
<td>(gdb) file gdb-sample</td>
</tr>
<tr>
<td>r</td>
<td>Run的简写，运行被调试的程序。 如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。</td>
<td>(gdb) r</td>
</tr>
<tr>
<td>c</td>
<td>Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</td>
<td>(gdb) c</td>
</tr>
<tr>
<td>b &lt;行号&gt; b &lt;函数名称&gt; b *&lt;函数名称&gt; b *&lt;代码地址&gt;d [编号]</td>
<td>b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。</td>
<td>(gdb) b 8 (gdb) b main (gdb) b *main (gdb) b *0x804835c(gdb) d</td>
</tr>
<tr>
<td>s, n</td>
<td>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； n: 执行一行源程序代码，此行代码中的函数调用也一并执行。s 相当于其它调试器中的“Step Into (单步跟踪进入)”； n 相当于其它调试器中的“Step Over (单步跟踪)”。这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。</td>
<td>(gdb) s (gdb) n</td>
</tr>
<tr>
<td>si, ni</td>
<td>si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</td>
<td>(gdb) si (gdb) ni</td>
</tr>
<tr>
<td>p &lt;变量名称&gt;</td>
<td>Print的简写，显示指定变量（临时变量或全局变量）的值。</td>
<td>(gdb) p i (gdb) p nGlobalVar</td>
</tr>
<tr>
<td>display …undisplay &lt;编号&gt;</td>
<td>display，设置程序中断后欲显示的数据及其格式。 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 “display /i pc”其中pc”其中pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。undispaly，取消先前的display设置，编号从1开始递增。</td>
<td>(gdb) display /i $pc(gdb) undisplay 1</td>
</tr>
<tr>
<td>i</td>
<td>Info的简写，用于显示各类信息，详情请查阅“help i”。</td>
<td>(gdb) i r</td>
</tr>
<tr>
<td>q</td>
<td>Quit的简写，退出GDB调试环境。</td>
<td>(gdb) q</td>
</tr>
<tr>
<td>help [命令名称]</td>
<td>GDB帮助命令，提供对GDB名种命令的解释说明。 如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</td>
<td>(gdb) help display</td>
</tr>
</tbody></table>
<h3 id="o文件是二进制文件"><a href="#o文件是二进制文件" class="headerlink" title=".o文件是二进制文件"></a>.o文件是二进制文件</h3><h2 id="雨课堂题目整理"><a href="#雨课堂题目整理" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143002794.png" alt="image-20210618143002794"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143011579.png" alt="image-20210618143011579"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143019456.png" alt="image-20210618143019456"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143027894.png" alt="image-20210618143027894"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143042533.png" alt="image-20210618143042533"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143052676.png" alt="image-20210618143052676"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143100984.png" alt="image-20210618143100984"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143111912.png" alt="image-20210618143111912"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143125572.png" alt="image-20210618143125572"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143147555.png" alt="image-20210618143147555"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143155638.png" alt="image-20210618143155638"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143205552.png" alt="image-20210618143205552"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143219860.png" alt="image-20210618143219860"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143233469.png" alt="image-20210618143233469"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143245888.png" alt="image-20210618143245888"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143254740.png" alt="image-20210618143254740"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143302040.png" alt="image-20210618143302040"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143310814.png" alt="image-20210618143310814"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143333036.png" alt="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143340720.png" alt="image-20210618143340720"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143348878.png" alt="image-20210618143348878"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143404564.png" alt="image-20210618143404564"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143416361.png" alt="image-20210618143416361"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143424721.png" alt="image-20210618143424721"></p>
<h1 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h1><h2 id="1-1-文件属性"><a href="#1-1-文件属性" class="headerlink" title="1.1 文件属性"></a><strong>1.1</strong> <strong>文件属性</strong></h2><ol>
<li>文件属性数据结构<strong>struct stat <strong>——</strong>文件控制块</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="keyword">mode_t</span> st_mode;   <span class="comment">/*file type &amp; mode*/</span></span><br><span class="line">  <span class="keyword">ino_t</span>   st_ino;     <span class="comment">/*inode number (serial number)*/</span></span><br><span class="line">  <span class="keyword">dev_t</span>  st_rdev;    <span class="comment">/*device number (file system)*/</span> </span><br><span class="line">  <span class="keyword">nlink_t</span>  st_nlink;    <span class="comment">/*link count*/</span></span><br><span class="line">  <span class="keyword">uid_t</span>   st_uid;     <span class="comment">/*user ID of owner*/</span></span><br><span class="line">  <span class="keyword">gid_t</span>   st_gid;     <span class="comment">/*group ID of owner*/</span></span><br><span class="line">  <span class="keyword">off_t</span>   st_size;     <span class="comment">/*size of file, in bytes*/</span></span><br><span class="line">  <span class="keyword">time_t</span>  st_atime;    <span class="comment">/*time of last access*/</span></span><br><span class="line">  <span class="keyword">time_t</span>  st_mtime;   <span class="comment">/*time of last modification*/</span></span><br><span class="line">  <span class="keyword">time_t</span>  st_ctime;    <span class="comment">/*time of lat file status change*/</span></span><br><span class="line">  <span class="keyword">long</span>   st_blksize;   <span class="comment">/*Optimal block size for I/O*/</span></span><br><span class="line">  <span class="keyword">long</span>   st_blocks;   <span class="comment">/*number 512-byte blocks allocated*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>命令查看：</strong>ls -l file</p>
<ol start="2">
<li>stat/fstat/lstat<strong>函数</strong></li>
</ol>
<p>获取文件属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, struct stat *buf)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-文件类型"><a href="#1-2-文件类型" class="headerlink" title="1.2 文件类型"></a><strong>1.2</strong> <strong>文件类型</strong></h2><h3 id="1-文件类型"><a href="#1-文件类型" class="headerlink" title="**1.**文件类型"></a>**1.**文件类型</h3><p>Unix/Linux系统支持的文件类型：</p>
<ul>
<li>Directory(d):目录文件</li>
<li>Link(l):链接文件</li>
<li>Pipe(p):管道文件</li>
<li>Block Device(b):块设备文件</li>
<li>Character Device(c):字符设备文件</li>
<li>Regular(-):普通文件</li>
<li>Socket(s):套接字文件</li>
</ul>
<p><strong>查看文件类型</strong></p>
<p><strong>使用命令：</strong>ls –l /dev/sda1</p>
<h4 id="例2-1设计一个程序，要求列出当前目录下的文件信息，以及系统“-dev-sda1”和“-dev-lp0”的文件信息。"><a href="#例2-1设计一个程序，要求列出当前目录下的文件信息，以及系统“-dev-sda1”和“-dev-lp0”的文件信息。" class="headerlink" title="例2.1设计一个程序，要求列出当前目录下的文件信息，以及系统“/dev/sda1”和“/dev/lp0”的文件信息。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-1.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-1.c">2.1</a>设计一个程序，要求列出当前目录下的文件信息，以及系统“/dev/sda1”和“/dev/lp0”的文件信息。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>	                </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>                  	<span class="comment">/*文件预处理，包含system函数库*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> newret;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列出当前目录下的文件信息：\n&quot;</span>); </span><br><span class="line">	newret=system(<span class="string">&quot;ls -l&quot;</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列出\&quot;dev/sda1\&quot;的文件信息：\n&quot;</span>); </span><br><span class="line">	newret=system(<span class="string">&quot;ls /dev/sda1 -l&quot;</span>);	<span class="comment">/*列出“/dev/sda1”的文件信息*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列出\&quot;dev/ lp0\&quot;的文件信息：\n&quot;</span>); </span><br><span class="line">	newret=system(<span class="string">&quot;ls /dev/lp0 -l&quot;</span>);      	<span class="comment">/*列出“/dev/ lp0”的文件信息*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-获取文件类型"><a href="#2-获取文件类型" class="headerlink" title="**2.**获取文件类型"></a>**2.**获取文件类型</h3><p>st_mode存储文件类型和许可权限，形式如下：<br> <strong>type3  type2  type1  type0</strong>  <strong>suid</strong>  <strong>sgid</strong>  <strong>sticky</strong>  <strong>rwx</strong>  <strong>rwx</strong>  <strong>rwx</strong></p>
<p><strong>用来确定文件类型的宏</strong>：<br> S_ISBLK – 测试块文件<br> S_ISCHR –　测试字符文件<br> S_ISDIR –　测试目录<br> S_ISFIFO –　测试FIFO<br> S_ISREG – 测试普通文件<br> S_ISLNK – 测试符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> i;  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span>  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc;i++)    </span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s:&quot;</span>,argv[i]);    </span><br><span class="line">    <span class="keyword">if</span>(lstat(argv[i],&amp;statbuf)==<span class="number">-1</span>)  &#123;  <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);  <span class="keyword">continue</span>;  &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(statbuf.st_mode))          <span class="built_in">printf</span>(<span class="string">&quot;%s is a directory\n&quot;</span>,argv[i]);</span><br><span class="line">    <span class="keyword">else</span>      <span class="keyword">if</span>(S_ISREG(statbuf.st_mode))        <span class="built_in">printf</span>(<span class="string">&quot;%s is a regular file\n&quot;</span>,argv[i]);</span><br><span class="line">      <span class="keyword">else</span>    <span class="keyword">if</span>(S_ISBLK(statbuf.st_mode))         <span class="built_in">printf</span>(<span class="string">&quot;%s is a block device\n&quot;</span>,argv[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>(S_ISCHR(statbuf.st_mode))        <span class="built_in">printf</span>(<span class="string">&quot;%s is a charcter device\n&quot;</span>,argv[i]); </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> S_ISLNK        </span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(statbuf.st_mode))      <span class="built_in">printf</span>(<span class="string">&quot;%s is a link file\n&quot;</span>,argv[i]);</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">ifdef</span> S_ISSOCK       </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(statbuf.st_mode))     <span class="built_in">printf</span>(<span class="string">&quot;%s is a socket \n&quot;</span>,argv[i]);</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">         <span class="keyword">else</span>          <span class="built_in">printf</span>(<span class="string">&quot;%s is an unknown type file \n&quot;</span>,argv[i]);     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611162747182.png" alt="image-20210611162747182"></p>
<h2 id="1-3-文件存取权限"><a href="#1-3-文件存取权限" class="headerlink" title="1.3 文件存取权限"></a><strong>1.3</strong> <strong>文件存取权限</strong></h2><h4 id="1-文件存取权限"><a href="#1-文件存取权限" class="headerlink" title="**1.**文件存取权限"></a>**1.**文件存取权限</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611162858324.png" alt="image-20210611162858324"></p>
<p>读的权限：显示目录文件，进入目录</p>
<p>写的权限：目录下创建文件</p>
<p>执行的权限：显示目录文件，进入目录，创建文件</p>
<h4 id="2-改变文件存取权限——命令"><a href="#2-改变文件存取权限——命令" class="headerlink" title="**2.**改变文件存取权限——命令"></a>**2.**改变文件存取权限——命令</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611163120067.png" alt="image-20210611163120067"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611163125022.png" alt="image-20210611163125022"></p>
<h4 id="例2-3-设计一个程序，要求把系统中“-home-mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。"><a href="#例2-3-设计一个程序，要求把系统中“-home-mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。" class="headerlink" title="例2.3 设计一个程序，要求把系统中“/home/mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-2.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-2.c">2.3 </a>设计一个程序，要求把系统中“/home/mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>       </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chmod(<span class="string">&quot;/home/mylinux/myfile&quot;</span>,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chmod 函数</span><br><span class="line">Change permissions of a file</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">// 打开的文件</span></span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="3-改变文件存取权限"><a href="#3-改变文件存取权限" class="headerlink" title="3. 改变文件存取权限"></a><strong>3. 改变文件存取权限</strong></h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611163410933.png" alt="image-20210611163410933"></p>
<h4 id="4-默认文件存取权限——umask"><a href="#4-默认文件存取权限——umask" class="headerlink" title="4. 默认文件存取权限——umask"></a><strong>4. 默认文件存取权限</strong>——umask</h4><p>新创建的文件和目录的默认权限是(root)</p>
<p>File:     -rw-r–r–  644</p>
<p>Directory: drwxr-xr-x 755</p>
<p>Why?</p>
<p>umask: 包含未被设置为权限位的==八进制数字(即无x位（可执行位）)==。默认002为普通用户，022为root用户。666-644=022</p>
<h4 id="例2-4-设计一程序，要求设置系统文件和目录的权限掩码。"><a href="#例2-4-设计一程序，要求设置系统文件和目录的权限掩码。" class="headerlink" title="例2.4 设计一程序，要求设置系统文件和目录的权限掩码。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-3_umask.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-3_umask.c">2.4 </a>设计一程序，要求设置系统文件和目录的权限掩码。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">mode_t</span> new_umask,old_umask;</span><br><span class="line">	new_umask=<span class="number">0666</span>;</span><br><span class="line">	old_umask=umask(new_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统原来的权限掩码是：%o\n&quot;</span>,old_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统新的权限掩码是：%o\n&quot;</span>,new_umask);</span><br><span class="line">	system(<span class="string">&quot;touch liu1&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建了文件liu1\n&quot;</span>);</span><br><span class="line">	new_umask=<span class="number">0444</span>;</span><br><span class="line">	old_umask=umask(new_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统原来的权限掩码是：%o\n&quot;</span>,old_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统新的权限掩码是：%o\n&quot;</span>,new_umask);</span><br><span class="line">	system(<span class="string">&quot;touch liu2&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建了文件liu2\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls liu1 liu2 -l&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">umask 函数</span><br><span class="line">为进程设置文件存取权限屏蔽字，并返回以前的值</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> mask)</span></span>;</span><br><span class="line">建立文件，文件的权限为<span class="number">0666</span>-mask；</span><br><span class="line">建立目录，目录权限为<span class="number">0777</span>-mask。</span><br></pre></td></tr></table></figure>

<h2 id="1-4-文件其他属性"><a href="#1-4-文件其他属性" class="headerlink" title="1.4 文件其他属性"></a><strong>1.4</strong> <strong>文件其他属性</strong></h2><h3 id="1-chown-fchown-lchown-函数"><a href="#1-chown-fchown-lchown-函数" class="headerlink" title="**1.chown/fchown/**lchown 函数"></a>**1.chown/<strong>fchown</strong>/**lchown <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">改变文件所有者</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h3 id="2-获取文件存取时间——stat"><a href="#2-获取文件存取时间——stat" class="headerlink" title="2.获取文件存取时间——stat"></a><strong>2.<strong>获取文件存取时间</strong>——stat</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">char</span> *path=<span class="string">&quot;./2-5.c&quot;</span>;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"> <span class="keyword">if</span> (stat(path,&amp;statbuf)==<span class="number">-1</span>)</span><br><span class="line">   perror(<span class="string">&quot;Failed to get file status&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s last accessed at %s&quot;</span>,path,ctime(&amp;statbuf.st_atime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-获取文件大小——stat"><a href="#3-获取文件大小——stat" class="headerlink" title="**3.**获取文件大小——stat"></a>**3.**获取文件大小——stat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>     	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                 	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">	stat(<span class="string">&quot;/etc/passwd&quot;</span>,&amp;buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\&quot;/etc/passwd\&quot;文件的大小是：%d\n&quot;</span>,buf.st_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-1-两种I-O方式"><a href="#2-1-两种I-O方式" class="headerlink" title="2.1 两种I/O方式"></a><strong>2.1</strong> <strong>两种</strong>I/O<strong>方式</strong></h2><h3 id="1-无缓冲和缓冲I-O"><a href="#1-无缓冲和缓冲I-O" class="headerlink" title="1. 无缓冲和缓冲I/O"></a><strong>1.</strong> <strong>无缓冲和缓冲</strong>I/O</h3><h4 id="无缓冲I-O"><a href="#无缓冲I-O" class="headerlink" title="无缓冲I/O"></a>无缓冲I/O</h4><ul>
<li>read/write -&gt;系统函数</li>
<li>文件描述符</li>
<li>POSIX.1 and XPG3标准</li>
</ul>
<h4 id="缓冲-I-O"><a href="#缓冲-I-O" class="headerlink" title="缓冲 I/O"></a>缓冲 I/O</h4><ol>
<li>标准I/O库实现</li>
<li>处理很多细节, 如缓存分配, 以优化长度执行I/O等.</li>
<li>流 -&gt; FILE类型指针</li>
</ol>
<h3 id="2-无缓冲-I-O-系统调用"><a href="#2-无缓冲-I-O-系统调用" class="headerlink" title="**2.**无缓冲 I/O 系统调用"></a>**2.**无缓冲 <strong>I/O</strong> <strong>系统调用</strong></h3><p>基本 I/O</p>
<ul>
<li>open/creat, close, read, write, lseek</li>
<li>dup/dup2</li>
<li>fcntl</li>
</ul>
<h2 id="2-2-文件描述符"><a href="#2-2-文件描述符" class="headerlink" title="2.2 文件描述符"></a><strong>2.2</strong> <strong>文件描述符</strong></h2><h3 id="1-文件描述符概述"><a href="#1-文件描述符概述" class="headerlink" title="1.文件描述符概述"></a><strong>1.文件描述符概述</strong></h3><p>非负整数</p>
<p>​    int fd;</p>
<p>​        (in &lt;unistd.h&gt;)</p>
<p>​    STDIN_FILENO (0), STDOUT_FILENO (1), STDERR_FILENO (2)</p>
<p>文件操作一般步骤：</p>
<p>   open-read/write-[lseek]-close</p>
<h3 id="2-进程打开文件的内核数据结构"><a href="#2-进程打开文件的内核数据结构" class="headerlink" title="2. 进程打开文件的内核数据结构"></a><strong>2.</strong> <strong>进程打开文件的内核数据结构</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170650485.png" alt="image-20210611170650485"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170732113.png" alt="image-20210611170732113"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170743253.png" alt="image-20210611170743253"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170755032.png" alt="image-20210611170755032"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170805503.png" alt="image-20210611170805503"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170815361.png" alt="image-20210611170815361"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170829150.png" alt="image-20210611170829150"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170853877.png" alt="image-20210611170853877"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170909100.png" alt="image-20210611170909100"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170919482.png" alt="image-20210611170919482"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170928977.png" alt="image-20210611170928977"></p>
<h2 id="2-3-无缓冲-I-O函数"><a href="#2-3-无缓冲-I-O函数" class="headerlink" title="2.3 无缓冲 I/O函数"></a><strong>2.3</strong> <strong>无缓冲</strong> <strong>I/O</strong>函数</h2><h3 id="0-错误处理"><a href="#0-错误处理" class="headerlink" title="**0.**错误处理"></a>**0.**错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UNIX方式</span><br><span class="line">Return value</span><br><span class="line">“errno”变量( defined in /usr/include/errno.h)</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br><span class="line"></span><br><span class="line">strerror &amp; perror</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-creat-函数"><a href="#1-creat-函数" class="headerlink" title="1. creat 函数"></a><strong>1.</strong> <strong>creat</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create a file <span class="keyword">or</span> device </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">(Return: a <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="例2-7-设计一程序，要求在“-home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。"><a href="#例2-7-设计一程序，要求在“-home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。" class="headerlink" title="例2.7 **设计一程序，要求在“/**home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-5.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-5.c">2.7</a> **设计一程序，要求在“/**home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	fd=creat(<span class="string">&quot;./2-7file&quot;</span>,S_IRUSR); </span><br><span class="line">	system(<span class="string">&quot;ls ./2-7file -l&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数-“mode”"><a href="#参数-“mode”" class="headerlink" title="参数 “mode”"></a><strong>参数</strong> <strong>“</strong>mode”</h4><p>“mode”: 指定创建的新文件的存取权限</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611171422005.png" alt="image-20210611171422005"></p>
<h4 id="参数-“mode”-amp-umask"><a href="#参数-“mode”-amp-umask" class="headerlink" title="参数 “mode” &amp; umask"></a><strong>参数</strong> “<strong>mode</strong>” <strong>&amp;</strong> <strong>umask</strong></h4><p>umask: 一种文件保护机制</p>
<p>新建文件的初始存取权限</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611171522883.png" alt="image-20210611171522883"></p>
<h3 id="2-Open-函数"><a href="#2-Open-函数" class="headerlink" title="2. Open 函数"></a><strong>2. Open</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Open <span class="keyword">and</span> possibly create a file <span class="keyword">or</span> device </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>; </span><br><span class="line">(Return: a <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="例2-8设计一个程序，要求在当前目录下以可读写方式打开一个名为“2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。"><a href="#例2-8设计一个程序，要求在当前目录下以可读写方式打开一个名为“2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。" class="headerlink" title="例2.8设计一个程序，要求在当前目录下以可读写方式打开一个名为“2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-6.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-6.c">2.8</a><strong>设计一个程序，要求在当前目录下以可读写方式打开一个名为“</strong>2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>        	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span>         	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                 	 </span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">if</span>((fd=open(<span class="string">&quot;./2-8file&quot;</span>,O_CREAT|O_TRUNC|O_WRONLY,<span class="number">0600</span>))&lt;<span class="number">0</span>)</span><br><span class="line">	  &#123; 	perror(<span class="string">&quot;打开文件出错&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;	<span class="built_in">printf</span>(<span class="string">&quot;打开(创建)文件\&quot;2-8file\&quot;，文件描述符为：%d\n&quot;</span>,fd);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span>(close(fd)&lt;<span class="number">0</span>)</span><br><span class="line">	  &#123;	perror(<span class="string">&quot;关闭文件出错&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	system(<span class="string">&quot;ls ./2-8file -l&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数-“flags”"><a href="#参数-“flags”" class="headerlink" title="参数 “flags”"></a><strong>参数</strong> <strong>“</strong>flags<strong>”</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“flags”: 指定文件存取方式</span><br><span class="line">One of O_RDONLY, O_WRONLY <span class="keyword">or</span> O_RDWR which request opening the file read-only, write-only <span class="keyword">or</span> read/write, respectively, bitwise-<span class="keyword">or</span>’d with zero <span class="keyword">or</span> more of the following: ( All defined in /usr/include/fcntl.h)</span><br><span class="line">O_APPEND: 追加方式打开</span><br><span class="line">O_TRUNC:文件存在清空</span><br><span class="line">O_CREAT: 文件不存在创建.</span><br><span class="line">O_EXCL: 和 O_CREAT一起用时, 文件存在则出错，打开失败</span><br><span class="line">…</span><br><span class="line">“creat” function: 等价于open函数中指定 O_CREAT|O_WRONLY|O_TRUNC</span><br></pre></td></tr></table></figure>

<h3 id="3-close-函数"><a href="#3-close-函数" class="headerlink" title="3. close 函数"></a><strong>3. close</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Close a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h3 id="4-read-write-函数"><a href="#4-read-write-函数" class="headerlink" title="4. read/write 函数"></a><strong>4. read/write</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read from a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line">(返回值: 读到的字节数，若已到文件尾为<span class="number">0</span>，若出错为<span class="number">-1</span>)</span><br><span class="line">Write to a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line">(返回值: 若成功为已写的字节数，若出错为<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="例2-9设计一个程序，完成文件的复制工作。要求通过read函数和write函数复制“-etc-passwd”文件到目标文件中，目标文件名在程序运行时从键盘输入。"><a href="#例2-9设计一个程序，完成文件的复制工作。要求通过read函数和write函数复制“-etc-passwd”文件到目标文件中，目标文件名在程序运行时从键盘输入。" class="headerlink" title="例2.9设计一个程序，完成文件的复制工作。要求通过read函数和write函数复制“/etc/passwd”文件到目标文件中，目标文件名在程序运行时从键盘输入。"></a><strong>例</strong>2.9<strong>设计一个程序，完成文件的复制工作。要求通过</strong>read<strong>函数和</strong>write<strong>函数复制“/<strong>etc/passwd”</strong>文件到目标文件中，目标文件名在程序运行时从键盘输入。</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> fdsrc,fddes,nbytes; <span class="keyword">int</span> z; <span class="keyword">char</span> buf[<span class="number">20</span>], des[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> flags=O_CREAT | O_TRUNC | O_WRONLY;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入目标文件名:&quot;</span>);	</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,des);                 		</span><br><span class="line">	fdsrc=open(<span class="string">&quot;/etc/passwd&quot;</span>,O_RDONLY);	</span><br><span class="line">	<span class="keyword">if</span>(fdsrc&lt;<span class="number">0</span>)	&#123;	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	fddes=open(des,flags,<span class="number">0644</span>);         	</span><br><span class="line">	<span class="keyword">if</span>(fddes&lt;<span class="number">0</span>)	&#123;	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">while</span>((nbytes=read(fdsrc,buf,<span class="number">20</span>))&gt;<span class="number">0</span>)</span><br><span class="line">	   &#123;	z=write(fddes,buf,nbytes);</span><br><span class="line">	<span class="keyword">if</span>(z&lt;<span class="number">0</span>)	&#123;	perror(<span class="string">&quot;写目标文件出错&quot;</span>);	&#125;	&#125;</span><br><span class="line">	close(fddes);</span><br><span class="line">	close(fdsrc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;复制\&quot;/etc/passwd\&quot;文件为\&quot;%s\&quot;文件成功！\n&quot;</span>,des);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-lseek-函数"><a href="#5-lseek-函数" class="headerlink" title="5. lseek 函数"></a><strong>5.</strong> <strong>lseek</strong> <strong>函数</strong></h3><p>read/write 定位文件指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line">(Return: the resulting offset location <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<p>该指令的“那里”:</p>
<p>​    SEEK_SET: the offset is set to “offset” bytes指针位移量为设定值</p>
<p>​    SEEK_CUR: the offset is set to its current location plus “offset” bytes指针位移量为当前位移加设定值</p>
<p>​    SEEK_END: the offset is set to the size of the file plus “offset” bytes指针位移量为文件尾加设定值</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213210597.png" alt="image-20210611213210597"></p>
<h4 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a><strong>空洞文件</strong></h4><p>使用lseek修改文件偏移量后，当前文件偏移量有可能大于文件的长度</p>
<p>在这种情况下，对该文件的下一次写操作，将加长该文件</p>
<p>这样文件中形成了一个空洞。对空洞区域进行读，均返回0</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213233714.png" alt="image-20210611213233714"></p>
<h3 id="6-dup-dup2-函数"><a href="#6-dup-dup2-函数" class="headerlink" title="6. dup/dup2 函数"></a><strong>6. dup/dup2</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制文件描述符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">(Return: the <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213303221.png" alt="image-20210611213303221"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213316880.png" alt="image-20210611213316880"></p>
<p>假设进程已打开文件描述符0、1、2</p>
<p>调用dup2(1, 6)，dup2返回值是多少？</p>
<p>然后再调用dup(6)，dup返回值是多少？</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213407986.png" alt="image-20210611213407986"></p>
<p><strong><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213417786.png" alt="image-20210611213417786"></strong></p>
<h3 id="7-fcntl函数"><a href="#7-fcntl函数" class="headerlink" title="7. fcntl函数"></a><strong>7.</strong> <strong>fcntl</strong>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看、修改打开的文件描述符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> result=fcntl(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd);</span><br><span class="line"><span class="keyword">int</span> result=fcntl(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,<span class="keyword">long</span> arg,…);</span><br></pre></td></tr></table></figure>

<p>lcmd取值：</p>
<p>F_DUPFD 复制文件描述符</p>
<p>F_GETFD 获得文件描述符</p>
<p>F_SETFD 设置文件描述符</p>
<p>F_GETFL 获取文件描述符当前模式</p>
<p>F_SETFL设置文件描述符当前模式</p>
<p>F_GETLK 获得记录锁</p>
<p>F_SETLK 设置记录锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">分析以下程序运行情况</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf1[]=<span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> buf2[]=<span class="string">&quot;ABCDEFGHEIJ&quot;</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;<span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">if</span>((fd=open(<span class="string">&quot;file.hole&quot;</span>,O_WRONLY|O_CREAT<span class="comment">/*|O_APPEND*/</span>,<span class="number">0644</span>))&lt;<span class="number">0</span>) </span><br><span class="line">    perror(<span class="string">&quot;creat error&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(write(fd,buf1,<span class="number">10</span>)!=<span class="number">10</span>)</span><br><span class="line">   perror(<span class="string">&quot;buf1 write error&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(lseek(fd,<span class="number">40</span>,SEEK_SET)==<span class="number">-1</span>) </span><br><span class="line">   perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(write(fd,buf2,<span class="number">10</span>)!=<span class="number">10</span>)</span><br><span class="line">   perror(<span class="string">&quot;buf2 write error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">（<span class="number">1</span>）ls –l 查看文件大小多少字节？</span><br><span class="line">（<span class="number">2</span>）cat 查看文件内容？</span><br><span class="line">（<span class="number">3</span>）od –c 查看文件内容</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">分析以下程序运行结果</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">if</span>((fd=open(<span class="string">&quot;myout&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>))==<span class="number">-1</span>)</span><br><span class="line">   perror(<span class="string">&quot;myout open error&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(dup2(fd,STDOUT_FILENO)==<span class="number">-1</span>)</span><br><span class="line">   perror(<span class="string">&quot;redirect stand output failed&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this is a test program for redirect\n&quot;</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line">（<span class="number">1</span>）查看程序运行结果？</span><br><span class="line">（<span class="number">2</span>）cat 查看文件myout的内容</span><br></pre></td></tr></table></figure>

<h2 id="3-1-标准I-O库"><a href="#3-1-标准I-O库" class="headerlink" title="3.1 标准I/O库"></a><strong>3.1</strong> <strong>标准</strong>I/O<strong>库</strong></h2><p>为什么要设计标准I/O库？</p>
<p>​    直接使用API进行文件访问时，需要考虑许多细节问题</p>
<p>​    例如：read、write时，缓冲区的大小该如何确定，才能使效率最优</p>
<p>标准I/O库封装了诸多细节问题，包括缓冲区分配</p>
<p>I/O效率示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">  <span class="keyword">while</span>((n = read(STDIN_FILENO, buf, BUFFSIZE))&gt;<span class="number">0</span>)       </span><br><span class="line">     <span class="keyword">if</span>(write(STDOUT_FILENO, buf,n)!= n)                   </span><br><span class="line">       perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序中，影响效率的关键：BUFFSIZE的取值</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213732273.png" alt="image-20210611213732273"></p>
<p>原因</p>
<ul>
<li>Linux文件系统采用了某种预读技术</li>
<li>当检测到正在进行顺序读取时，系统就试图读入比应用程序所要求的更多数据</li>
<li>并假设应用程序很快就会读这些数据</li>
<li>当BUFFSIZE增加到一定程度后，预读就停止了</li>
</ul>
<h3 id="标准-I-O-缓冲"><a href="#标准-I-O-缓冲" class="headerlink" title="标准 I/O 缓冲"></a><strong>标准</strong> <strong>I/O</strong> <strong>缓冲</strong></h3><p>标准I/O库提供缓冲的目的：尽可能减少使用read、write调用的次数，以提高I/O效率。</p>
<p>通过标准I/O库进行的读写操作，数据都会被放置在标准I/O库缓冲中中转。</p>
<h2 id="3-2-文件流"><a href="#3-2-文件流" class="headerlink" title="3.2 文件流"></a><strong>3.2</strong> <strong>文件流</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">..............................        </span><br><span class="line"><span class="keyword">char</span>            fd;                        <span class="comment">/* File descriptor      */</span></span><br><span class="line"><span class="keyword">short</span>           bsize;                  <span class="comment">/* Buffer size          */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   *buffer;        <span class="comment">/* Data transfer buffer */</span></span><br><span class="line">....................................</span><br><span class="line">&#125;       FILE;     </span><br><span class="line">标准I/O库</span><br><span class="line">管理的缓冲区</span><br></pre></td></tr></table></figure>

<h2 id="3-3-标准-I-O-函数"><a href="#3-3-标准-I-O-函数" class="headerlink" title="3.3 标准 I/O 函数"></a><strong>3.3</strong> <strong>标准</strong> <strong>I/O</strong> <strong>函数</strong></h2><ul>
<li>流 open/close</li>
<li>流 read/write<ul>
<li>​    每次一个字符的I/O：fgetc,fputc</li>
<li>​    每次一行的I/O: fgets,fputs,gets,puts</li>
<li>​    直接I/O(二进制I/O): fread,fwrite</li>
<li>​    格式化I/O:scanf,printf,fscanf,fprintf</li>
</ul>
</li>
<li>流定位:fseek,ftell,frewind</li>
<li>流刷新:fflush</li>
</ul>
<h3 id="1-流打开-关闭"><a href="#1-流打开-关闭" class="headerlink" title="1. 流打开/关闭"></a><strong>1.</strong> <strong>流打开</strong>/<strong>关闭</strong></h3><h4 id="例2-10设计一个程序，要求用流文件I-O操作打开文件“2-10file”-如果该文件不存在，则创建文件。"><a href="#例2-10设计一个程序，要求用流文件I-O操作打开文件“2-10file”-如果该文件不存在，则创建文件。" class="headerlink" title="例2.10设计一个程序，要求用流文件I/O操作打开文件“2-10file”,如果该文件不存在，则创建文件。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-9.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-9.c">2.10</a><strong>设计一个程序，要求用流文件</strong>I/O<strong>操作打开文件“</strong>2-10file”,如果该文件不存在，则创建文件。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE * fp;                                 		</span><br><span class="line">	<span class="keyword">if</span>((fp=fopen(<span class="string">&quot;./2-10file&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>)       	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开(创建)文件出错&quot;</span>);      	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);                                 		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Open a stream</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line">Parameter “mode”</span><br><span class="line">“r”:  	Open text file <span class="keyword">for</span> reading.</span><br><span class="line">“w”: Truncate file to zero length <span class="keyword">or</span> create text file <span class="keyword">for</span> writing.</span><br><span class="line">“a”: 	Open <span class="keyword">for</span> appending.</span><br><span class="line">“r+”: Open <span class="keyword">for</span> reading <span class="keyword">and</span> writing.</span><br><span class="line">“w+”: Open <span class="keyword">for</span> reading <span class="keyword">and</span> writing. The file is created <span class="keyword">if</span> it does <span class="keyword">not</span> exist, otherwise it is truncated.</span><br><span class="line">“a+”: Open <span class="keyword">for</span> reading <span class="keyword">and</span> appending. The file is created <span class="keyword">if</span> does <span class="keyword">not</span> exist.</span><br><span class="line">    </span><br><span class="line">Close a stream</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-流读-写"><a href="#2-流读-写" class="headerlink" title="**2.流读/**写"></a>**2.<strong>流读</strong>/**写</h3><p>对流有三种读写方式</p>
<ul>
<li><p>每次读写一个字符</p>
</li>
<li><p>每次读写一行</p>
</li>
<li><p>每次读写任意长度的内容</p>
</li>
</ul>
<h4 id="（1）输入-出一个字符"><a href="#（1）输入-出一个字符" class="headerlink" title="（1）输入/出一个字符"></a><strong>（</strong>1<strong>）输入/出一个字符</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">输出</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line">(Return: the character <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="（2）-输入-出一行"><a href="#（2）-输入-出一行" class="headerlink" title="（2） 输入/出一行"></a>（2） 输入/出一行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="（3）-二进制流输入-输出"><a href="#（3）-二进制流输入-输出" class="headerlink" title="（3） 二进制流输入/输出"></a>（3） 二进制流输入/输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="function">size <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line">(Return: the number of a items successfully read <span class="keyword">or</span> written.)</span><br></pre></td></tr></table></figure>

<h4 id="例2-11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I-O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。"><a href="#例2-11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I-O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。" class="headerlink" title="例2.11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I/O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。"></a>例2.11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I/O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序：把帐号信息从文件读出*/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmemb 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>						 </span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> pay;</span><br><span class="line">&#125;s[nmemb];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;	FILE * fp;              		</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	fp = fopen(<span class="string">&quot;2-11file&quot;</span>, <span class="string">&quot;r&quot;</span>);	</span><br><span class="line">	fread(s,<span class="keyword">sizeof</span>(struct test),nmemb,fp); </span><br><span class="line">	fclose(fp);                  			 </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nmemb;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;帐号[%d]:%-20s余额[%d]:%d\n&quot;</span>,i,s[i].name,i,s[i].pay);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*程序：把帐号信息写入文件*/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_s(x,y,z) &#123;strcpy(s[x].name,y);s[x].pay=z;&#125;   <span class="comment">/*自定义宏，用于赋值*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmemb 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>                     	 </span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> pay;</span><br><span class="line">&#125;s[nmemb];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	FILE * fp;                   	</span><br><span class="line">	set_s(<span class="number">0</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">12345</span>);</span><br><span class="line">	set_s(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">200</span>);</span><br><span class="line">	set_s(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>,<span class="number">50000</span>);</span><br><span class="line">	fp=fopen(<span class="string">&quot;2-11file&quot;</span>,<span class="string">&quot;a+&quot;</span>);	<span class="comment">/*打开(创建)文件*/</span></span><br><span class="line">	fwrite(s,<span class="keyword">sizeof</span>(struct test),nmemb,fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;                    	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）-格式化-I-O"><a href="#（4）-格式化-I-O" class="headerlink" title="（4） 格式化 I/O"></a>（4） 格式化 I/O</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-流定位"><a href="#3-流定位" class="headerlink" title="3.流定位"></a>3.流定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="例2-12-设计一程序，要求用fopen函数打开系统文件“-etc-passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。"><a href="#例2-12-设计一程序，要求用fopen函数打开系统文件“-etc-passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。" class="headerlink" title="例2.12 设计一程序，要求用fopen函数打开系统文件“/etc/passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。"></a>例2.12 设计一程序，要求用fopen函数打开系统文件“/etc/passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *stream;</span><br><span class="line">	<span class="keyword">long</span> offset;</span><br><span class="line">	<span class="keyword">fpos_t</span> pos;</span><br><span class="line">	stream=fopen(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	fseek(stream,<span class="number">10</span>,SEEK_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件流的偏移量：%d\n&quot;</span>,ftell(stream));</span><br><span class="line">	fseek(stream,<span class="number">0</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件流的偏移量：%d\n&quot;</span>,ftell(stream));</span><br><span class="line">	rewind(stream);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件流的偏移量：%d\n&quot;</span>,ftell(stream));</span><br><span class="line">	fclose(stream);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210617212155113.png" alt="image-20210617212155113"></p>
<h3 id="4-流刷新"><a href="#4-流刷新" class="headerlink" title="4. 流刷新"></a>4. 流刷新</h3><p>刷新文件流。把流里的数据立刻写入文件—fork前使用fflush<br>#include &lt;stdio.h&gt;<br>int fflush(FILE *stream);</p>
<p>自动刷新：</p>
<ul>
<li>流关闭fclose；</li>
<li>exit终止；</li>
<li>行缓冲“\n”；</li>
<li>缓冲区满；</li>
<li>执行输入操作读文件:printf（“hello”）;scanf（“%d”,&amp;a）</li>
</ul>
<h3 id="5-流缓冲"><a href="#5-流缓冲" class="headerlink" title="5. 流缓冲"></a>5. 流缓冲</h3><ul>
<li>三种类型的缓冲</li>
<li>块（全）缓冲block buffered (fully buffered)：一般C库函数写入文件是全缓冲的</li>
<li>行缓冲line buffered:引用标准交互设备的流stdin,stdout<pre><code>例：    for(i=1;i&lt;=10;i++) fputc(c,stdout);
           fputc(&quot;\n&quot;,stdout);
</code></pre>
</li>
<li>无缓冲Unbuffered：标准错误流stderr</li>
</ul>
<p>全缓冲</p>
<ul>
<li>在填满标准I/O缓冲区后，才进行实际I/O操作（例如调用write函数）</li>
<li>调用fflush函数也能强制进行实际I/O操作</li>
</ul>
<p>行缓冲</p>
<ul>
<li>在输入和输出遇到换行符时，标准I/O库执行I/O操作</li>
<li>因为标准I/O库用来收集每一行的缓存的长度是固定的，所以，只要填满了缓存，即使没有遇到新行符，也进行I/O操作</li>
<li>终端（例如标准输入和标准输出），使用行缓冲</li>
</ul>
<p>不带缓冲</p>
<ul>
<li>标准I/O库不对字符进行缓冲存储</li>
<li>标准出错是不带缓冲的，为了让出错信息尽快显示出来</li>
</ul>
<h3 id="6-流和文件描述符"><a href="#6-流和文件描述符" class="headerlink" title="6. 流和文件描述符"></a>6. <strong>流和文件描述符</strong></h3><p>确定流使用的底层文件描述符<br>#include &lt;stdio.h&gt;<br>int fileno(FILE *fp);<br>根据已打开的文件描述符创建一个流<br>#include &lt;stdio.h&gt;<br>FILE *fdopen(int fildes, const char *mode);</p>
<h2 id="4-1-目录文件"><a href="#4-1-目录文件" class="headerlink" title="4.1 目录文件"></a>4.1 <strong>目录文件</strong></h2><p>mkdir/rmdir<br>chdir/fchdir, getcwd<br>读目录操作<br>opendir/closedir<br>readdir<br>telldir<br>seekdir</p>
<h3 id="例2-13设计一程序，要求读取当前目录文件中所有的目录结构。"><a href="#例2-13设计一程序，要求读取当前目录文件中所有的目录结构。" class="headerlink" title="例2.13设计一程序，要求读取当前目录文件中所有的目录结构。"></a>例2.13设计一程序，要求读取当前目录文件中所有的目录结构。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DIR * dir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">ptr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	dir=opendir(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>((ptr = readdir(dir))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;目录: %s\n&quot;</span>,ptr-&gt;d_name);</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618151814819.png" alt="image-20210618151814819"></p>
<h3 id="1-读目录"><a href="#1-读目录" class="headerlink" title="1. 读目录"></a>1. <strong>读目录</strong></h3><p>数据结构<br>DIR, struct dirent<br>操作函数<br>opendir/closedir<br>readdir<br>telldir<br>seekdir</p>
<h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. <strong>数据结构</strong></h3><p>DIR</p>
<p>​    目录流对象的数据结构</p>
<p>​    in &lt;dirent.h&gt;<br>​    typedef struct __dirstream DIR;</p>
<p>struct dirent</p>
<p>​    目录项</p>
<p>​    Defined in &lt;dirent.h&gt;</p>
<p>​        ino_t d_ino;       /* inode number <em>/<br>​        char  d_name[NAME_MAX + 1];    /</em> file name */</p>
<h3 id="3-操作函数"><a href="#3-操作函数" class="headerlink" title="3. 操作函数"></a>3. 操作函数</h3><p>目录的打开、关闭、读、定位<br>#include &lt;sys/types.h&gt;<br>#include &lt;dirent.h&gt;</p>
<p>DIR *opendir(const char *name);<br>int closedir(DIR *dir);<br>struct dirent *readdir(DIR *dir);<br>off_t telldir(DIR *dir);<br>void seekdir(DIR *dir, off_t offset);</p>
<h4 id="目录扫描程序——ls-R命令"><a href="#目录扫描程序——ls-R命令" class="headerlink" title="目录扫描程序——ls -R命令"></a>目录扫描程序——ls -R命令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DIR *dp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (dp = opendir(dir)) == <span class="literal">NULL</span> )</span><br><span class="line">    err_sys(…);</span><br><span class="line"><span class="keyword">while</span> ( (entry = readdir(dp)) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    lstat(entry-&gt;d_name, &amp;statbuf);</span><br><span class="line">    <span class="keyword">if</span> ( S_ISDIR(statbuf.st_mode) ) </span><br><span class="line">        …</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        …</span><br><span class="line">&#125;</span><br><span class="line">closedir(dp);</span><br></pre></td></tr></table></figure>

<h4 id="mkdir-rmdir-函数"><a href="#mkdir-rmdir-函数" class="headerlink" title="mkdir/rmdir 函数"></a>mkdir/rmdir 函数</h4><p>创建一个空目录<br>#include &lt;sys/stat.h&gt;<br>#include &lt;sys/types.h&gt;<br>int mkdir(const char *pathname, mode_t mode);<br>(Return: 0 if success; -1 if failure)<br>删除一个空目录<br>#include &lt;unistd.h&gt;<br>int rmdir(const char *pathname);<br>(Return: 0 if success; -1 if failure)</p>
<h4 id="chdir-fchdir-函数"><a href="#chdir-fchdir-函数" class="headerlink" title="chdir/fchdir 函数"></a>chdir/fchdir 函数</h4><p>Change working directory<br>#include &lt;unistd.h&gt;<br>int chdir(const char *path);<br>int fchdir(int fd);<br>(Return: 0 if success; -1 if failure)<br>当前工作目录是进程的属性，所以该函数只影响调用chdir的进程本身<br>cd(1) command</p>
<h2 id="4-2-链接文件"><a href="#4-2-链接文件" class="headerlink" title="4.2 链接文件"></a><strong>4.2</strong> <strong>链接文件</strong></h2><p>ln 命令<br>link/unlink 函数<br>给一个文件创建一个链接.<br>#include &lt;unistd.h&gt;<br>int link(const char *oldpath, const char *newpath);<br>(Return: 0 if success; -1 if failure)<br>删除文件链接<br>#include &lt;unistd.h&gt;<br>int unlink(const char *pathname);<br>(Return: 0 if success; -1 if failure)</p>
<h4 id="symlink-readlink"><a href="#symlink-readlink" class="headerlink" title="symlink/readlink"></a>symlink/readlink</h4><p>ln –s命令<br>创建一个符号链接<br>#include &lt;unistd.h&gt;<br>int symlink(const char *oldpath, const char *newpath);<br>(Return: 0 if success; -1 if failure)<br>读取符号链接的值<br>#include &lt;unistd.h&gt;<br>int readlink(const char *path, char *buf, size_t bufsiz);<br>(Return: the count of characters placed in the buffer if success; -1 if failure)</p>
<h4 id="例2-14设计一程序，要求为“-etc-passwd”文件建立软链接“2-14link”，并查看此链接文件和“-etc-passwd”文件。"><a href="#例2-14设计一程序，要求为“-etc-passwd”文件建立软链接“2-14link”，并查看此链接文件和“-etc-passwd”文件。" class="headerlink" title="例2.14设计一程序，要求为“/etc/passwd”文件建立软链接“2-14link”，并查看此链接文件和“/etc/passwd”文件。"></a>例2.14设计一程序，要求为“/etc/passwd”文件建立软链接“2-14link”，并查看此链接文件和“/etc/passwd”文件。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	symlink(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;2-14link&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls 2-14link -l&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls /etc/passwd -l&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618152519176.png" alt="image-20210618152519176"></p>
<h4 id="例2-15设计一程序，要求为“-etc-passwd”文件建立硬链接“2-15link”，并查看此链接文件和“-etc-passwd”文件。"><a href="#例2-15设计一程序，要求为“-etc-passwd”文件建立硬链接“2-15link”，并查看此链接文件和“-etc-passwd”文件。" class="headerlink" title="例2.15设计一程序，要求为“/etc/passwd”文件建立硬链接“2-15link”，并查看此链接文件和“/etc/passwd”文件。"></a>例2.15设计一程序，要求为“/etc/passwd”文件建立硬链接“2-15link”，并查看此链接文件和“/etc/passwd”文件。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link(<span class="string">&quot;./myfile&quot;</span>,<span class="string">&quot;2-15link&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls 2-15link -l&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls /etc/passwd -l&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-设备文件"><a href="#4-3-设备文件" class="headerlink" title="4.3 设备文件"></a><strong>4.3</strong> <strong>设备文件</strong></h2><p>1.设备文件名</p>
<p>  ls –C 列出当前系统加载的设备对应的文件</p>
<p>  ls –li 列出当前终端设备的属性</p>
<p>2.设备文件读写</p>
<p>   open，read，write，close，stat</p>
<h4 id="例2-16-向终端pts1写入100个“unix”。"><a href="#例2-16-向终端pts1写入100个“unix”。" class="headerlink" title="例2-16 向终端pts1写入100个“unix”。"></a>例2-16 向终端pts1写入100个“unix”。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">int</span> i,fd;</span><br><span class="line">      fd=open(<span class="string">&quot;/dev/pts/1&quot;</span>,O_WRONLY);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        write(fd, <span class="string">&quot;Unix&quot;</span>,<span class="number">4</span>);</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h3><p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>下面是 fseek() 函数的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位。</li>
<li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SEEK_SET</td>
<td align="left">文件的开头</td>
</tr>
<tr>
<td align="left">SEEK_CUR</td>
<td align="left">文件指针的当前位置</td>
</tr>
<tr>
<td align="left">SEEK_END</td>
<td align="left">文件的末尾</td>
</tr>
</tbody></table>
<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><p>将文件指针重新指向文件开头</p>
<h3 id="readdir"><a href="#readdir" class="headerlink" title="readdir()"></a>readdir()</h3><p>头文件：#include &lt;sys/types.h&gt;  #include &lt;dirent.h&gt;</p>
<p>定义函数：struct dirent * readdir(DIR * dir);</p>
<p>函数说明：readdir()返回参数dir 目录流的下个目录进入点。结构dirent 定义如下：<br>struct dirent<br>{<br>  ino_t d_ino; //d_ino 此目录进入点的inode<br>  ff_t d_off; //d_off 目录文件开头至此目录进入点的位移<br>  signed short int d_reclen; //d_reclen _name 的长度, 不包含NULL 字符<br>  unsigned char d_type; //d_type d_name 所指的文件类型 d_name 文件名<br>  har d_name[256];<br>};</p>
<p>返回值：成功则返回下个目录进入点. 有错误发生或读取到目录文件尾则返回NULL.</p>
<h3 id="fdopen"><a href="#fdopen" class="headerlink" title="fdopen()"></a>fdopen()</h3><p>头文件：#include &lt;stdio.h&gt;</p>
<p>定义函数：FILE * fdopen(int fildes, const char * mode);</p>
<p>**函数说明：fdopen()会将参数fildes 的文件描述词, 转换为对应的文件指针后返回.参数mode 字符串则代表着文件指针的流形态, 此形态必须和原先文件描述词读写模式相同. 关于mode 字符串格式请参考fopen(). **</p>
<p>返回值：转换成功时返回<strong>指向该流的文件指针</strong>. 失败则返回NULL, 并把错误代码存在errno 中.</p>
<h3 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h3><p>头文件：#include &lt;sys/types.h&gt;  #include &lt;dirent.h&gt;</p>
<p>函数：DIR *opendir（const char *name）;</p>
<p>含义： opendir()用来打开参数name 指定的目录, 并返回DIR*形态的目录流, 和open()类似, 接下来对目录的读取和搜索都要使用此返回值.</p>
<h3 id="readdir-1"><a href="#readdir-1" class="headerlink" title="readdir()"></a>readdir()</h3><p>头文件：#include&lt;sys/types.h&gt; #include &lt;dirent.h&gt;</p>
<p>函数：struct dirent *readdir(DIR *dir);</p>
<p>含义:readdir()返回参数dir 目录流的下个目录进入点。</p>
<p>struct dirent<br>{<br>    ino_t d_ino; //d_ino 此目录进入点的inode<br>    ff_t d_off; //d_off 目录文件开头至此目录进入点的位移<br>    signed short int d_reclen; //d_reclen _name 的长度, 不包含NULL 字符<br>    unsigned char d_type; //d_type d_name 所指的文件类型 d_name 文件名<br>    har d_name[256];<br>};</p>
<h3 id="fileno"><a href="#fileno" class="headerlink" title="fileno()"></a>fileno()</h3><p>功  能：<strong>把文件流指针转换成文件描述符</strong><br>相关函数：open, fopen<br>表头文件：#include &lt;stdio.h&gt;<br>定义函数：int fileno(FILE *stream)<br>函数说明：fileno()用来取得参数stream指定的文件流所使用的文件描述词<br>返回值 ：返回和stream文件流对应的文件描述符。如果失败，返回-1。<br>范例：<br>#include &lt;stdio.h&gt;<br>main()<br>{<br>   FILE  *fp;<br>   int  fd;<br>   fp = fopen(“/etc/passwd”, “r”);<br>   fd = fileno(fp);<br>   printf(“fd = %d\n”, fd);<br>   fclose(fp);<br>}</p>
<p><strong>文件描述词是Linux编程中的一个术语。当一个文件打开后，系统会分配一部分资源来保存该文件的信息，以后对文件的操作就可以直接引用该部分资源了。文件描述词可以认为是该部分资源的一个索引，在打开文件时返回。</strong>在使用fcntl函数对文件的一些属性进行设置时就需要一个文件描述词参数。<br>以前知道，当程序执行时，就已经有三个文件流打开了，它们分别是标准输入stdin，标准输出stdout和标准错误输出stderr。和流式文件相对应的是，也有三个文件描述符被预先打开，它们分别是0，1，2，代表标准输入、标准输出和标准错误输出。需要指出的是，上面的流式文件输入、输出和文件描述符的输入输出方式不能混用，否则会造成混乱。</p>
<h3 id="telldir"><a href="#telldir" class="headerlink" title="telldir()"></a>telldir()</h3><p>头文件：#include &lt;dirent.h&gt;</p>
<p>定义函数：off_t telldir(DIR *dir);</p>
<p>函数说明：<strong>telldir()返回参数dir 目录流目前的读取位置. 此返回值代表距离目录文件开头的偏移量返回值返回下个读取位置, 有错误发生时返回-1.</strong></p>
<h3 id="exit-和-eixt-区别"><a href="#exit-和-eixt-区别" class="headerlink" title="exit()和_eixt()区别"></a>exit()和_eixt()区别</h3><p><strong>_exit()函数的作用最为简单：直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构；exit() 函数则在这些基础上作了一些包装，在执行退出之前加了若干道工序。<br>exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是”清理I/O缓冲”。</strong></p>
<h3 id="文件流指针"><a href="#文件流指针" class="headerlink" title="文件流指针"></a>文件流指针</h3><p>在应用编程层面，程序对流的操作体现在文件流指针FILE上，在操作一个文件前，需要打开该文件，而使用ANSI　C库函数fopen()打开一个文件后，将返回一个文件流指针与该文件关联，所有针对该文件的读写操作都通过该文件流指针完成，以下是应用层所能访问的FILE结构体，因此，结构体成员可以在用户空间中访问。<br>typedef struct _IO_FILE FILE;<br>struct _IO_FILE{<br>int _flags;<br>char* _IO_read_ptr; //如果以读打开，当前读指针<br>char* _IO_read_end; //如果以读打开，读区域结束位置<br>char* _IO_read_base; //Start of putback+get area<br>char* _IO_write_base; //如果以写打开，写区起始区<br>char* _IO_write_ptr; //如果以写打开，当前写指针<br>char* _IO_write_end; //如果以写打开，写区域结束位置<br>char* _IO_buf_base; //如果显示设置缓冲区，其起始位置<br>char* _IO_buf_end; //如果显示设置缓冲区，其结束位置。<br>…<br>int _fileno; //文件描述符<br>…<br>}<br>在此结构体中，包含了I/O库为管理该流所需要的所有信息，如用于实现I/O的文件描述符、指向流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数和出错标志等。</p>
<h3 id="Linux文件存储结构"><a href="#Linux文件存储结构" class="headerlink" title="Linux文件存储结构"></a>Linux文件存储结构</h3><p>大部分的Linux文件系统（如ext2、ext3）规定，<strong>一个文件由目录项、inode和数据块组成</strong>：</p>
<ul>
<li>目录项：包括<strong>文件名和inode节点号</strong>。</li>
<li>Inode：又称<strong>文件索引节点，包含文件的基础信息以及数据块的指针</strong>。</li>
<li>数据块：包含文件的具体内容。</li>
</ul>
<p>Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>
<p>目录文件的结构非常简单，就是一系列目录项（<em><strong>dirent</strong></em>）的列表。<strong>每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码</strong>。</p>
<h2 id="雨课堂题目整理-1"><a href="#雨课堂题目整理-1" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214812080.png" alt="image-20210610214812080"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214821927.png" alt="image-20210610214821927"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214834210.png" alt="image-20210610214834210"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214845524.png" alt="image-20210610214845524"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214854641.png" alt="image-20210610214854641"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214906327.png" alt="image-20210610214906327"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214915564.png" alt="image-20210610214915564"></p>
<p>!==[image-20210610214926804]==(D:\SyncDisk\笔记整理\Linux\image-20210610214926804.png)</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214936008.png" alt="image-20210610214936008"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214944544.png" alt="image-20210610214944544"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610215005400.png" alt="image-20210610215005400"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610215953437.png" alt="image-20210610215953437"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220011507.png" alt="image-20210610220011507"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220021904.png" alt="image-20210610220021904"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220032690.png" alt="==image-20210610220032690"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220042546.png" alt="image-20210610220042546"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220052131.png" alt="image-20210610220052131"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220104981.png" alt="image-20210610220104981"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220118232.png" alt="image-20210610220118232"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220131685.png" alt="image-20210610220131685"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214618550.png" alt="image-20210610214618550"></p>
<p><img src="https://qn-sc0.yuketang.cn/ue_i/20210412/ed409440-6383-449f-80b4-d692f0abd914.png" alt="image.png"><img src="https://qn-sc0.yuketang.cn/ue_i/20210412/88aa10b5-c10f-4e78-a476-aa0b1042460f.png" alt="image.png"><img src="https://qn-sc0.yuketang.cn/ue_i/20210412/78291e04-149d-44ad-a612-86b4c9fabaf1.png" alt="image.png"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214629301.png" alt="image-20210610214629301"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214639221.png" alt="image-20210610214639221"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143645924.png" alt="image-20210618143645924"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143654774.png" alt="image-20210618143654774"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143702180.png" alt="image-20210618143702180"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143710258.png" alt="image-20210618143710258"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143719274.png" alt="image-20210618143719274"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143727064.png" alt="image-20210618143727064"></p>
<h1 id="进程编程"><a href="#进程编程" class="headerlink" title="进程编程"></a>进程编程</h1><h2 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1. 进程"></a>1.1. <strong>进程</strong></h2><p>进程：一个或多个线程执行的地址空间，线程执行时需要系统资源</p>
<h2 id="1-2-进程启动"><a href="#1-2-进程启动" class="headerlink" title="1.2. 进程启动"></a>1.2. <strong>进程启动</strong></h2><p>System call “fork” 系统调用fork<br>   Process resources<br>struct task_struct<br>System space stack<br>…<br>System call “exec”系统调用exec<br>The entry of C programs  C程序入口</p>
<h2 id="1-3-进程终止"><a href="#1-3-进程终止" class="headerlink" title="1.3. 进程终止"></a>1.3. 进程终止</h2><p>进程终止的五种方式<br>Normal termination 正常终止<br>Return from “main” function 从main函数返回<br>Call “exit” function 调用exit函数<br>Call “_exit” function 调用_exit函数<br>Abnormal termination 异常终止<br>Call “abort” function 调用abort函数<br>Terminated by a signal 信号终止</p>
<h2 id="1-4-进程分类"><a href="#1-4-进程分类" class="headerlink" title="1.4. 进程分类"></a>1.4. 进程分类</h2><p>Foreground process前台进程<br>要求用户启动它们或与它们交互的进程称为前台进程。<br>前台进程不结束，终端就不会出现系统提示符，直到进程终止。<br>缺省情况下，程序和命令作为前台进程运行。</p>
<p>Background process 后台进程<br>独立于用户运行的进程称为后台进程。<br>用户在输入命令行后加上“&amp;”字符然后按<Enter>键就启动了后台进程。<br>Shell不等待命令终止，就立即出现系统提示符，让该命令进程在后台运行，用户可以继续执行新的命令。 </p>
<p>Daemon 守护进程<br>总是运行在后台的系统进程。<br>守护程序通常<strong>在系统启动时启动，并且它们一直运行到系统停止</strong>。<br>守护进程常常用于向用户提供各种类型的服务和执行系统管理任务。<br>守护程序进程由 root 用户或 root  shell 启动，并只能由 root 用户停止。</p>
<h2 id="2-1-进程标识符"><a href="#2-1-进程标识符" class="headerlink" title="2.1. 进程标识符"></a>2.1. 进程标识符</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618161417909.png" alt="image-20210618161417909"></p>
<h2 id="2-2-进程创建"><a href="#2-2-进程创建" class="headerlink" title="2.2. 进程创建"></a>2.2. 进程创建</h2><h3 id="1-fork"><a href="#1-fork" class="headerlink" title="1.fork"></a>1.fork</h3><p>fork: create a child process<br>#include &lt;sys/types.h&gt;<br>#include &lt;unistd.h&gt;<br>pid_t fork(void);<br>returned value:<br>pid of child (in the current (parent) process),<br>0 (in child process),<br>-1 (failure)</p>
<p>fork创建子进程代码结构</p>
<p>……</p>
<p> pid = fork();</p>
<p> if (pid&lt;0) {perror(“fork()”);exit(1);}</p>
<p> else if (pid==0) { child process }</p>
<p> else  { parent process }</p>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a><strong>文件共享</strong></h4><p>所有由父进程打开的描述符都被复制到子进程中。父、子进程每个相同的打开描述符共享一个文件表项</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618161638801.png" alt="image-20210618161638801"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">pid_t</span> pid;    </span><br><span class="line">  <span class="keyword">int</span> fd;    </span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> status; </span><br><span class="line">  <span class="keyword">char</span> *ch1=<span class="string">&quot;hello&quot;</span>; </span><br><span class="line">  <span class="keyword">char</span> *ch2=<span class="string">&quot;world&quot;</span>; </span><br><span class="line">  <span class="keyword">char</span> *ch3=<span class="string">&quot;IN&quot;</span>; </span><br><span class="line">  <span class="keyword">if</span>((fd=open(<span class="string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>))==<span class="number">-1</span>) </span><br><span class="line">    &#123;   perror(<span class="string">&quot;parent open&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; </span><br><span class="line">  <span class="keyword">if</span>(write(fd,ch1,<span class="built_in">strlen</span>(ch1))==<span class="number">-1</span>)  </span><br><span class="line">    &#123; perror(<span class="string">&quot;parent write&quot;</span>);    <span class="built_in">exit</span>(EXIT_FAILURE); &#125; </span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">-1</span>) </span><br><span class="line">  &#123; perror(<span class="string">&quot;fork&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)  </span><br><span class="line">    &#123; i=<span class="number">2</span>; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;in child\n&quot;</span>);   <span class="comment">//打印 i 值，以示与父亲进程区别 </span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i); </span><br><span class="line">      <span class="keyword">if</span>(write(fd,ch2,<span class="built_in">strlen</span>(ch2))==<span class="number">-1</span>)     <span class="comment">//写文件 test.txt，与父进程共享 </span></span><br><span class="line">        perror(<span class="string">&quot;child write&quot;</span>); </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;   &#125; </span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    &#123;    sleep(<span class="number">1</span>);                       <span class="comment">//等待子进程先执行 </span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;in parent\n&quot;</span>); </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i);          <span class="comment">//打印 i 值，以示与子进程区别 </span></span><br><span class="line">         <span class="keyword">if</span>(write(fd,ch3,<span class="built_in">strlen</span>(ch3))==<span class="number">-1</span>)       <span class="comment">//写操作，结果添加到文件后 </span></span><br><span class="line">            perror(<span class="string">&quot;parent,write&quot;</span>); </span><br><span class="line">         wait(&amp;status);                        <span class="comment">//等待子进程结束 </span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">&#125; </span><br><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">      &#123; <span class="keyword">if</span> (i%j==<span class="number">0</span>)</span><br><span class="line">        &#123; mark=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">单个进程</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200main()</span></span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">      &#123; <span class="keyword">if</span> (i%j==<span class="number">0</span>)</span><br><span class="line">        &#123; mark=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">多个进程</span><br><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)</span><br><span class="line">    &#123;     <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">          &#123; <span class="keyword">if</span> (i%j==<span class="number">0</span>)             &#123; mark=<span class="number">0</span>;               <span class="keyword">break</span>;              &#125; </span><br><span class="line">          &#125;</span><br><span class="line">         <span class="keyword">if</span> (mark)     <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i); <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">     &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="fork-应用场合"><a href="#fork-应用场合" class="headerlink" title="fork 应用场合"></a><strong>fork</strong> 应用场合</h4><p>进程复制自己，使父子进程同一时刻执行不同的代码——网络服务<br>进程要执行另一个不同的程序：fork-exec——shell<br>Question：效率问题？父子进程各自占一段逻辑地址空间，fork之后立即exec，地址空间浪费。<br>    “写—复制”</p>
<h3 id="2-vfork"><a href="#2-vfork" class="headerlink" title="2. vfork"></a>2. vfork</h3><p>vfork</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t vfork(void);</p>
<p>功能：类似fork，创建一个新进程，效率髙。</p>
<p>与fork区别：</p>
<p>  <strong>(1) vfork创建的进程与父进程共用地址空间</strong></p>
<p>  <strong>(2) vfork创建子进程后，阻塞父进程，直到子进程调用exec或exit，内核才唤醒父进程。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global=<span class="number">5</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;<span class="keyword">int</span> pid; <span class="keyword">char</span> *<span class="built_in">string</span>=<span class="string">&quot;I am father:&quot;</span>; <span class="keyword">int</span> local=<span class="number">10</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;before vfork\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>) &#123;perror(<span class="string">&quot;vfork failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">   &#123;<span class="built_in">string</span>=<span class="string">&quot;I am child.&quot;</span>;</span><br><span class="line">    global++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s global=%d, local=%d\n&quot;</span>,<span class="built_in">string</span>,global,local);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;local++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s my pid is %d \n&quot;</span>    <span class="string">&quot;global=%d\n local=%d\n&quot;</span>, <span class="built_in">string</span>,getpid(),global,local);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;&#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">int</span> global=<span class="number">5</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;<span class="keyword">int</span> pid; <span class="keyword">char</span> *<span class="built_in">string</span>=<span class="string">&quot;I am father:&quot;</span>; <span class="keyword">int</span> local=<span class="number">10</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;before vfork\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>((pid=vfork())&lt;<span class="number">0</span>) &#123;perror(“vfork failed”);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;  </span><br><span class="line">                           <span class="comment">//共用进程空间，子进程先执行</span></span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">   &#123;<span class="built_in">string</span>=<span class="string">&quot;I am child.&quot;</span>;</span><br><span class="line">    global++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s global=%d, local=%d\n&quot;</span>,<span class="built_in">string</span>,global,local);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;local++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s my pid is %d \n&quot;</span>    <span class="string">&quot;global=%d\n local=%d\n&quot;</span>, <span class="built_in">string</span>,getpid(),global,local);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep函数"><a href="#sleep函数" class="headerlink" title="sleep函数"></a>sleep函数</h3><p>函数原型：</p>
<p> #include &lt;unistd.h&gt;</p>
<p>  unsigned int sleep(unsigned int seconds);</p>
<p>  seconds:暂停时间（秒）</p>
<h3 id="3-exec-系列函数"><a href="#3-exec-系列函数" class="headerlink" title="3.exec 系列函数"></a><strong>3.exec</strong> <strong>系列函数</strong></h3><p>用一个新的进程映像替换当前的进程映像,执行新程序的进程保持原进程的一系列特征：</p>
<p>pid, ppid, uid, gid, working directory, root directory …</p>
<p>#include &lt;unistd.h&gt;</p>
<p>extern char **environ;</p>
<p>int execl(const char *path, const char *arg, …);</p>
<p>int execlp(const char *file, const char *arg, …);</p>
<p>int execle(const char *path, const char *arg, …, char * const envp[]);</p>
<p>int execv(const char *path, char * const argv[]);</p>
<p>int execvp(const char *file, char * const argv[]);</p>
<p>int execve(const char *filename, char * const argv[], char * const envp[]);</p>
<p>1.两大类：</p>
<p>  execl开头：参数以列表形式arg0,arg1…NULL结束。</p>
<p>  execv开头：参数以指向字符串数组argv[]指针形式，arg[0]必须为程序名。</p>
<p>2.含有字母p的函数可以使用相对路径，根据环境变量PATH查找文件；其他函数必须使用绝对路径；</p>
<p>3.含有字母e的函数，需要通过指向envp[]数组的指针指明新的环境变量，其他函数使用当前环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用exec函数使新进程执行“/bin/ps” 程序。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ps_argv[]=&#123;“ps”,”-af”, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ps_envp[] = &#123;“PATH=/bin:/usr/bin”, “TERM=console”, <span class="literal">NULL</span>&#125;;</span><br><span class="line">六种情况：</span><br><span class="line">execl(“/bin/ps”,”ps”,”-af”,<span class="literal">NULL</span>);</span><br><span class="line">execlp(“ps”,”ps”,”-af”,<span class="literal">NULL</span>);</span><br><span class="line">execle(“/bin/ps”,”ps”,”-af”,<span class="literal">NULL</span>,ps_envp);</span><br><span class="line">execv(“/bin/ps”,ps_argv);</span><br><span class="line">execvp(“ps”,ps_argv);</span><br><span class="line">execve(“/bin/ps”,ps_argv,ps_envp);</span><br></pre></td></tr></table></figure>

<h4 id="fork和exec一起使用"><a href="#fork和exec一起使用" class="headerlink" title="fork和exec一起使用"></a>fork和exec一起使用</h4><p>父子进程各自执行不同的代码,进程要执行另一个程序.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);	<span class="comment">/* print prompt  */</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;     <span class="comment">/* replace newline with null */</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) </span><br><span class="line">        err_sys(“fork error”);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;		<span class="comment">/* child */</span></span><br><span class="line">        execlp(buf, buf, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;couldn&#x27;t execute: %s&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">/* parent */</span></span><br><span class="line">        err_sys(“waitpid error”);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-进程终止"><a href="#2-3-进程终止" class="headerlink" title="2.3 进程终止"></a><strong>2.3</strong> <strong>进程终止</strong></h2><h3 id="1-exit函数"><a href="#1-exit函数" class="headerlink" title="1.exit函数"></a>1.exit函数</h3><p>函数原型：</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>void exit(int status);</p>
<p>status:进程状态</p>
<p>功能：正常终止目前进程的执行，把参数status返回给父进程，进程所有的缓冲区数据会自动写回并关闭未关闭的文件。</p>
<h3 id="2-exit函数"><a href="#2-exit函数" class="headerlink" title="2._exit函数"></a>2._exit函数</h3><p>函数原型：</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>void ——exit(int status);</p>
<p>status:进程状态</p>
<p>功能：立刻终止目前进程的执行，把参数status返回给父进程，并关闭未关闭的文件。不处理标准I/O缓冲区。</p>
<h2 id="2-4-父子进程关系"><a href="#2-4-父子进程关系" class="headerlink" title="2.4 父子进程关系"></a><strong>2.4</strong> <strong>父子进程关系</strong></h2><h3 id="1-两种进程概念"><a href="#1-两种进程概念" class="headerlink" title="1. 两种进程概念"></a><strong>1.</strong> <strong>两种进程概念</strong></h3><p>父进程在子进程前终止——<strong>孤儿进程</strong></p>
<p>​    Orphan process——init</p>
<p>子进程在父进程前终止——可能成为<strong>僵尸进程</strong></p>
<p>​    SIGCHLD signal 忽略SIGCHLD信号</p>
<p>​    Handled by wait/waitpid in parent 父进程中用wait/waitpid处理</p>
<p>​    Not handled by wait/waitpid in parent -&gt; zombie父进程没有用wait/waitpid处理-&gt;僵尸进程</p>
<h3 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2. 僵尸进程"></a><strong>2.</strong> <strong>僵尸进程</strong></h3><p>僵尸进程：已终止运行，但尚未被清除的进程。</p>
<p>子进程运行结束后（正常或异常），它并没有马上从系统的进程分配表中被删掉，而是进入僵死状态（Zombie），一直等到父进程来回收它的结束状态信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> pid;          <span class="keyword">char</span> *message;              <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork program starting\n&quot;</span>);</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;  <span class="keyword">case</span> <span class="number">-1</span>:      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:      message=<span class="string">&quot;this is child&quot;</span>;    n=<span class="number">2</span>;      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:      n=<span class="number">5</span>;      message=<span class="string">&quot;this is parent&quot;</span>;      sleep(<span class="number">60</span>);       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;n&gt;<span class="number">0</span>;n--)</span><br><span class="line">      &#123;  <span class="built_in">puts</span>(message);</span><br><span class="line">         sleep(n<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-僵尸进程解决方法"><a href="#3-僵尸进程解决方法" class="headerlink" title="**3.**僵尸进程解决方法"></a>**3.**僵尸进程解决方法</h3><p>僵尸进程的proc结构一直存在直到父进程正常结束或系统重启</p>
<p>如何消除僵尸进程？</p>
<p>方法一：wait/waitpid阻塞父进程，子进程先终止</p>
<p>方法二：父进程不阻塞，两次fork</p>
<p>方法三：使用signal信号处理</p>
<h4 id="方法一：wait-example"><a href="#方法一：wait-example" class="headerlink" title="方法一：wait example"></a>方法一：wait example</h4><h4 id="例3-5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。"><a href="#例3-5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。" class="headerlink" title="例3.5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。"></a>例3.5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">      <span class="keyword">if</span> (i%j==<span class="number">0</span>)        &#123; mark=<span class="number">0</span>;          <span class="keyword">break</span>;        &#125; </span><br><span class="line">      <span class="keyword">if</span> (mark)        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i);</span><br><span class="line">      sleep(<span class="number">100</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">     wait(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="wait-amp-waitpid-functions"><a href="#wait-amp-waitpid-functions" class="headerlink" title="wait &amp; waitpid functions"></a><strong>wait &amp;</strong> <strong>waitpid</strong> <strong>functions</strong></h5><p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/wait.h&gt;</p>
<p>pid_t wait(int *status);</p>
<p>pid_t waitpid(pid_t pid, int *status, int options);</p>
<p>waitpid的第一个参数pid的意义：</p>
<p>  pid &gt; 0: 等待进程id为pid的子进程。</p>
<p>  pid == 0: 等待与自己同组的任意子进程。</p>
<p>  pid == -1: 等待任意一个子进程</p>
<p>  pid &lt; -1: 等待进程组号为-pid的任意子进程。因此，wait(&amp;stat)等价于waitpid(-1, &amp;stat, 0)</p>
<p>waitpid例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>           	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>       	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span>        	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                  	 </span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">pid_t</span> pid,wpid;	<span class="keyword">int</span> status,i;</span><br><span class="line">	pid=fork();          		</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">	&#123;	<span class="built_in">printf</span>(<span class="string">&quot;这是子进程,进程号(pid)是:%d\n&quot;</span>,getpid());</span><br><span class="line">		sleep(<span class="number">5</span>);        	<span class="built_in">exit</span>(<span class="number">6</span>);	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="built_in">printf</span>(<span class="string">&quot;这是父进程,正在等待子进程……\n&quot;</span>);</span><br><span class="line">		wpid=waitpid(pid,&amp;status,<span class="number">0</span>);    	</span><br><span class="line">		i=WEXITSTATUS(status);			</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;等待的进程的进程号(pid)是:%d ,结束状态:%d\n&quot;</span>,wpid,i);</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：两次fork-Example"><a href="#方法二：两次fork-Example" class="headerlink" title="方法二：两次fork Example"></a><strong>方法二：两次</strong>fork Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">pid_t</span> pid;</span><br><span class="line"> <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)  perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)    <span class="comment">/*first child*/</span></span><br><span class="line">   &#123; <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>) perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/*parent of second child=first child*/</span></span><br><span class="line">         sleep(<span class="number">10</span>);          <span class="comment">/*second child*/</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;second child,parent pid=%d\n&quot;</span>,getppid());</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>)!=pid)  <span class="comment">/*wait for first child,parent(the original process)*/</span></span><br><span class="line">    perror(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;parent exit&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：singnal函数处理"><a href="#方法三：singnal函数处理" class="headerlink" title="方法三：singnal函数处理"></a><strong>方法三：</strong>singnal<strong>函数处理</strong></h4><p>Singnal函数处理：</p>
<p>  （1）设置信号处理函数</p>
<p>​       signal(SIGCHLD,fun)</p>
<p>  （2）忽略子进程终止信号</p>
<p>​       signal(SIGCHLD,SIG_IGN)</p>
<p>​       内核回收</p>
<h2 id="4-1-登录方式"><a href="#4-1-登录方式" class="headerlink" title="4.1 登录方式"></a><strong>4.1</strong> <strong>登录方式</strong></h2><h3 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618204829654.png" alt="image-20210618204829654"></p>
<h3 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618204928040.png" alt="image-20210618204928040"></p>
<h2 id="4-2-进程组和会话期"><a href="#4-2-进程组和会话期" class="headerlink" title="4.2 进程组和会话期"></a><strong>4.2</strong> <strong>进程组和会话期</strong></h2><p>进程组</p>
<p>一个或多个过程的集合</p>
<p>getpgrp/setpgid functions</p>
<p>会话期Session</p>
<p>一个或多个进程组的集合。</p>
<p>getsid/setsid function</p>
<p>setsid函数</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618211351096.png" alt="image-20210618211351096"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618211443043.png" alt="image-20210618211443043"></p>
<h2 id="4-3-守护进程Daemon"><a href="#4-3-守护进程Daemon" class="headerlink" title="4.3 守护进程Daemon"></a><strong>4.3</strong> <strong>守护进程</strong>Daemon</h2><p>精灵进程或守护进程</p>
<p>后台执行, 没有控制终端或登录 Shell 的进程</p>
<h3 id="ps-–aux-命令查看"><a href="#ps-–aux-命令查看" class="headerlink" title="ps –aux 命令查看"></a><strong>ps</strong> <strong>–aux</strong> <strong>命令查看</strong></h3><p>Init:进程1，启动系统服务</p>
<p>Keventd：为内核中运行的函数提供进程上下文</p>
<p>Kswapd：页面调出守护进程</p>
<p>bdflush，kupdated：调整缓存中的数据写到磁盘</p>
<p>portmap：将RPC程序号映射为端口号</p>
<p>inetd(xinetd)：侦听网络接口，获取网络服务进程请求</p>
<p>注意：大多数守护进程都以超级用户（用户ID为0）特权运行。没有一个守护进程具有控制终端，其终端名设置为问号（？）。</p>
<h3 id="ps-axj命令查看"><a href="#ps-axj命令查看" class="headerlink" title="ps axj命令查看"></a><strong>ps</strong> <strong>axj命令查看</strong></h3><p>daemon特征：</p>
<p>sid，pid，pgid相同，均为pid</p>
<p>ppid为1</p>
<p>tty为？</p>
<h3 id="daemon进程实现规则"><a href="#daemon进程实现规则" class="headerlink" title="daemon进程实现规则"></a><strong>daemon</strong>进程实现规则</h3><p>编程规则<br>首先调用fork，然后使父进程exit<br>调用setsid创建一个新的会话期 setsid()<br>将当前工作目录更改为特定目录chdir(./)<br>进程的umask设为0 umask(0)<br>关闭不需要的文件描述符 close()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">/* parent goes bye-bye */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* child continues */</span></span><br><span class="line">	setsid();		<span class="comment">/* become session leader */</span></span><br><span class="line">	chdir(<span class="string">&quot;/tmp&quot;</span>);		<span class="comment">/* change working directory */</span></span><br><span class="line">	umask(<span class="number">0</span>);		<span class="comment">/* clear our file mode creation mask */</span>   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)  	  </span><br><span class="line">		close(i);       <span class="comment">/* close file */</span> </span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写守护进程的要点"><a href="#编写守护进程的要点" class="headerlink" title="编写守护进程的要点"></a><strong>编写守护进程的要点</strong></h3><p>（1）创建子进程，终止父进程</p>
<p>pid=fork();</p>
<p>if(pid&gt;0)</p>
<p>{exit(0);}  /<em>终止父进程</em>/</p>
<p>（2）在子进程中创建新会话</p>
<p>setsid函数用于创建一个新的会话，并担任该会话组的组长，其作用：</p>
<p>①让进程摆脱原会话的控制；</p>
<p>②让进程摆脱原进程组的控制；</p>
<p>③让进程摆脱原控制终端的控制。</p>
<p>而setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。</p>
<p>（3）改变工作目录</p>
<p>改变工作目录的常见函数是chdir。</p>
<p>（4）重设文件创建掩码</p>
<p>文件创建掩码是指屏蔽掉文件创建时的对应位。</p>
<p>把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。</p>
<p>设置文件创建掩码的函数是umask。</p>
<p>（5）关闭文件描述符</p>
<p>通常按如下方式关闭文件描述符：</p>
<p>for(i=0;i&lt;NOFILE;i++)</p>
<p>close(i);</p>
<p>或者也可以用如下方式：</p>
<p>for(i=0;i&lt;MAXFILE;i++)</p>
<p>close(i);</p>
<h3 id="守护进程编写"><a href="#守护进程编写" class="headerlink" title="守护进程编写"></a><strong>守护进程编写</strong></h3><h4 id="例3-7-设计两个程序，主程序和初始化程序。要求主程序每隔10秒向-tmp目录中的日志报告运行状态。初始化程序中的init-daemon函数负责生成守护进程。"><a href="#例3-7-设计两个程序，主程序和初始化程序。要求主程序每隔10秒向-tmp目录中的日志报告运行状态。初始化程序中的init-daemon函数负责生成守护进程。" class="headerlink" title="例3.7 设计两个程序，主程序和初始化程序。要求主程序每隔10秒向/tmp目录中的日志报告运行状态。初始化程序中的init_daemon函数负责生成守护进程。"></a>例3.7 设计两个程序，主程序和初始化程序。要求主程序每隔10秒向/tmp目录中的日志报告运行状态。初始化程序中的init_daemon函数负责生成守护进程。</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618211952186.png" alt="image-20210618211952186"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*主程序每隔一分钟向/tmp目录中的日志3-7.log报告运行状态*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> 	          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span>                </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_daemon</span><span class="params">(<span class="keyword">void</span>)</span></span>;        	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	FILE *fp; </span><br><span class="line">	<span class="keyword">time_t</span> t; </span><br><span class="line">	init_daemon();  				</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)                       		</span><br><span class="line">	&#123;  sleep(<span class="number">10</span>);                     	</span><br><span class="line">	  <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;./3-7.log&quot;</span>,<span class="string">&quot;a+&quot;</span>)) &gt;=<span class="number">0</span></span><br><span class="line">	    &#123; t=time(<span class="number">0</span>); </span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;守护进程还在运行，时间是： %s&quot;</span>,asctime(localtime(&amp;t)) ); </span><br><span class="line">		  fclose(fp); </span><br><span class="line">	&#125; &#125; &#125;</span><br><span class="line"><span class="keyword">void</span> init_daemon(<span class="keyword">void</span>) </span><br><span class="line">&#123;	<span class="keyword">pid_t</span> child1,child2; 	<span class="keyword">int</span> i; </span><br><span class="line">	child1=fork();</span><br><span class="line">	<span class="keyword">if</span>(child1&gt;<span class="number">0</span>)          <span class="built_in">exit</span>(<span class="number">0</span>);                       	</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(child1&lt; <span class="number">0</span>) </span><br><span class="line">	&#123; perror(<span class="string">&quot;创建子进程失败&quot;</span>);				<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	setsid();               			</span><br><span class="line">   chdir(<span class="string">&quot;/tmp&quot;</span>);          				</span><br><span class="line">  umask(<span class="number">0</span>);               				</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; NOFILE;++i)  					close(i); </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：fopen函数必须具有root权限。如果没有root权限，可以看到守护进程的运行，但不会在文件里写入任何字符。</p>
<h4 id="例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。"><a href="#例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。" class="headerlink" title="例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。"></a>例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618212139554.png" alt="image-20210618212139554"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> child1,child2; </span><br><span class="line">	<span class="keyword">int</span> i; </span><br><span class="line">	child1=fork();</span><br><span class="line">	<span class="keyword">if</span>(child1&gt;<span class="number">0</span>)        		<span class="comment">/*(1)创建子进程，终止父进程*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);        		<span class="comment">/*这是第一子进程，后台继续执行*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(child1&lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;创建子进程失败&quot;</span>);	<span class="comment">/*fork失败，退出*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setsid();               		<span class="comment">/*(2)在子进程中创建新会话*/</span></span><br><span class="line">	chdir(<span class="string">&quot;/&quot;</span>);             		<span class="comment">/*(3)改变工作目录到“/”*/</span> </span><br><span class="line">	umask(<span class="number">0</span>);               		<span class="comment">/*(4)重设文件创建掩码*/</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; NOFILE;++i)  	<span class="comment">/*(5)关闭文件描述符*/</span> </span><br><span class="line">		close(i); </span><br><span class="line">	openlog(<span class="string">&quot;例3-8程序信息&quot;</span>,LOG_PID,LOG_DAEMON);<span class="comment">/* 调用openlog,打开日志文件*/</span></span><br><span class="line">	child2=fork();</span><br><span class="line"><span class="keyword">if</span>(child2==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;创建子进程失败&quot;</span>);	</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(child2==<span class="number">0</span>)</span><br><span class="line">	&#123;	syslog(LOG_INFO,<span class="string">&quot;第二子进程暂停5秒！&quot;</span>); </span><br><span class="line">		sleep(<span class="number">5</span>);              <span class="comment">/*睡眠5秒钟*/</span></span><br><span class="line">		syslog(LOG_INFO,<span class="string">&quot;第二子进程结束运行。&quot;</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	&#123;</span><br><span class="line">		waitpid(child2,<span class="literal">NULL</span>,<span class="number">0</span>); </span><br><span class="line">		syslog(LOG_INFO, <span class="string">&quot;第一子进程在等待第二子进程结束后，也结束运行。&quot;</span>);</span><br><span class="line">		closelog();         	   <span class="comment">/*调用closelog，关闭日志服务*/</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) 	&#123;	sleep(<span class="number">10</span>);      	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：调用openlog、syslog函数，操作的系统日志文件“/var/log/syslog”或“/var/log/messages ”，必须具有root权限。</p>
<p>openlog函数说明 </p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618212254955.png" alt="image-20210618212254955"></p>
<p>syslog函数说明</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618212315332.png" alt="image-20210618212315332"></p>
<h2 id="5-1-信号概念"><a href="#5-1-信号概念" class="headerlink" title="5.1 信号概念"></a><strong>5.1</strong> <strong>信号概念</strong></h2><p>信号<br>Software interrupt软件中断<br>Mechanism for handling asynchronous events异步事件<br>Having a name (beginning with SIG)<br>Defined as a positive integer (in &lt;signal.h&gt;)<br>信号产生<br>按终端键，硬件异常，kill(2)函数，kill(1)命令，软件条件，…</p>
<p>SIG信号（1-31）是从UNIX系统中继承下来的称为不可靠信号(也称为非实时信号)。<br>SIGRTMIN~SIGRTMAX是为了解决前面“不可靠信号”问题而进行更改和扩充的信号，称为可靠信号(也称为实时信号)。</p>
<p>可靠信号(实时信号)：支持排队，发送用户进程一次就注册一次，发现相同信号已经在进程中注册，也要再注册。<br>不可靠信号(非实时信号)：不支持排队，发送用户进程判断后注册，发现相同信号已经在进程中注册，就不再注册，忽略该信号。</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th>**说明 **</th>
<th><strong>默认操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SIGABRT</td>
<td>进程异常终止（调用abort函数产生此信号）</td>
<td></td>
</tr>
<tr>
<td><strong>SIGALRM</strong></td>
<td><strong>超时（<strong><strong>alarm</strong></strong>）</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td>SIGFPE</td>
<td>算术运算异常（除以0，浮点溢出等）</td>
<td></td>
</tr>
<tr>
<td><strong>SIGHUP</strong></td>
<td><strong>连接断开</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法硬件指令</td>
<td></td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td><strong>终端终端符</strong>(Clt**-C)**</td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td><strong>立即结束程序运行（不能被捕捉、阻塞或忽略）</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>向没有读进程的管道写数据</td>
<td></td>
</tr>
<tr>
<td><strong>SIGQUIT</strong></td>
<td><strong>终端退出符</strong>(Clt-\)</td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td><strong>SIGTERM</strong></td>
<td><strong>终止（由</strong>kill<strong>命令发出的系统默认终止信号）</strong></td>
<td><strong>退出</strong></td>
</tr>
<tr>
<td><strong>SIGUSR1</strong></td>
<td><strong>用户定义信号</strong></td>
<td><strong>退出</strong></td>
</tr>
<tr>
<td><strong>SIGUSR2</strong></td>
<td><strong>用户定义信号</strong></td>
<td><strong>退出</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>SIGSEGV</th>
<th>无效存储访问（段违例）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SIGCHLD</strong></td>
<td><strong>子进程停止或退出</strong></td>
<td><strong>忽略</strong></td>
</tr>
<tr>
<td><strong>SIGCONT</strong></td>
<td><strong>使暂停进程继续</strong></td>
<td><strong>继续</strong>/<strong>忽略</strong></td>
</tr>
<tr>
<td><strong>SIGSTOP</strong></td>
<td><strong>暂停一个进程（不能被捕捉、阻塞或忽略）</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td><strong>SIGTSTP</strong></td>
<td><strong>终端挂起符</strong>(<strong>Clt</strong>-Z)</td>
<td><strong>停止进程</strong></td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>后台进程请求从控制终端读</td>
<td></td>
</tr>
<tr>
<td>SIGTTOUT</td>
<td>后台进程请求向控制终端写</td>
<td></td>
</tr>
</tbody></table>
<h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a><strong>信号处理</strong></h4><p>忽略信号<br>不能忽略的信号：<br>    SIGKILL, SIGSTOP<br>    一些硬件异常信号<br>执行系统默认动作<br>捕捉信号</p>
<h2 id="5-2-信号相关命令"><a href="#5-2-信号相关命令" class="headerlink" title="5.2 信号相关命令"></a><strong>5.2</strong> <strong>信号相关命令</strong></h2><p>Kill</p>
<p>•   暂停 kill –STOP <pid></p>
<p>• 恢复 kill –CONT <pid></p>
<p>• 终止 kill –KILL  <pid></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>kill</td>
<td>发送信号给进程或进程组</td>
</tr>
<tr>
<td>raise</td>
<td>发送信号给进程自身</td>
</tr>
<tr>
<td>alarm</td>
<td>定时器时间到，向进程发送SIGALRM信号</td>
</tr>
<tr>
<td>pause</td>
<td>没有捕捉信号前一直将进程挂起</td>
</tr>
<tr>
<td>signal</td>
<td>捕捉信号SIGINT,  SIGQUIT时执行信号处理函数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>sigemptyset</th>
<th>初始化信号集合为空</th>
</tr>
</thead>
<tbody><tr>
<td>sigfillset</td>
<td>初始化信号集合为所有信号集合</td>
</tr>
<tr>
<td>sigaddset</td>
<td>将指定信号加入到指定集合</td>
</tr>
<tr>
<td>sigdelset</td>
<td>将指定信号从信号集中删除</td>
</tr>
<tr>
<td>sigprocmask</td>
<td>判断检测或更改信号屏蔽字</td>
</tr>
</tbody></table>
<h3 id="1-信号发送——kill-amp-raise"><a href="#1-信号发送——kill-amp-raise" class="headerlink" title="1 信号发送——kill &amp; raise"></a><strong>1</strong> <strong>信号发送</strong>——kill &amp; raise</h3><p>kill: send signal to a process</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>int kill(pid_t pid, int sig);</p>
<p> (Returned Value: 0 if success, -1 if failure)</p>
<p>The “pid” parameter</p>
<p>  pid &gt; 0: 发送信号给进程id为pid的进程。</p>
<p>  pid =0:发送信号给与自己同组的所有进程。</p>
<p>  pid = -1: 发送系统内所有进程</p>
<p>  pid &lt; -1: 发送给进程组号为-pid的所有进程。</p>
<p>raise: send a signal to the current process</p>
<p>#include &lt;signal.h&gt;</p>
<p>int raise(int sig);</p>
<p> (Returned Value: 0 if success, -1 if failure)</p>
<h4 id="例3-9-设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。"><a href="#例3-9-设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。" class="headerlink" title="例3-9 设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。"></a>例3-9 设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。</h4><p>分析：用户进程fork子进程后，子进程使用raise函数发送SIGSTOP信号，使自己暂停；父进程使用kill函数向子进程发送SIGKILL信号，子进程收到信号结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>             	</span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="keyword">pid_t</span> result;	<span class="keyword">int</span> ret;	<span class="keyword">int</span> newret;</span><br><span class="line">       result=fork();        		</span><br><span class="line">       <span class="keyword">if</span>(result&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;    perror(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line">	     <span class="built_in">exit</span>(<span class="number">1</span>);       &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (result==<span class="number">0</span>)  	</span><br><span class="line">	&#123;    raise(SIGSTOP);    <span class="comment">/*调用raise函数，发送SIGSTOP 使子进程暂停*/</span></span><br><span class="line">	     <span class="built_in">exit</span>(<span class="number">0</span>);      &#125;</span><br><span class="line">	<span class="keyword">else</span>                    	</span><br><span class="line">	&#123;     <span class="built_in">printf</span>(<span class="string">&quot;子进程的进程号(PID)是：%d\n&quot;</span>,result);</span><br><span class="line">	      <span class="keyword">if</span>((waitpid(result,<span class="literal">NULL</span>,WNOHANG))==<span class="number">0</span>)</span><br><span class="line">	  &#123;  <span class="keyword">if</span>((ret=kill(result,SIGKILL))==<span class="number">0</span>)</span><br><span class="line">	      <span class="built_in">printf</span>(<span class="string">&quot;用kill函数返回值是：%d，发出的SIGKILL信号结束的进程进程号：%d\n&quot;</span>,ret,result);</span><br><span class="line">	    <span class="keyword">else</span>  &#123;   perror(<span class="string">&quot;kill函数结束子进程失败&quot;</span>); waitpid(result,<span class="literal">NULL</span>,<span class="number">0</span>); &#125;</span><br><span class="line">	  &#125;	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Waitpid（pid，<span class="literal">NULL</span>，WNOHANG）没有子进程终止立即返回，返回值为<span class="number">0</span></span><br><span class="line">由此例可知，系统调用kill函数和raise函数，都是简单地向某一进程发送信号。kill函数用于给特定的进程或进程组发送信号，raise函数用于向一个进程自身发送信号。</span><br></pre></td></tr></table></figure>

<h3 id="2-信号处理——-“signal”-函数"><a href="#2-信号处理——-“signal”-函数" class="headerlink" title="2 信号处理—— “signal” 函数"></a><strong>2</strong> <strong>信号处理</strong>—— “signal” <strong>函数</strong></h3><p>为编号为sgn的信号安装一个新的信号处理程序。</p>
<p>#include &lt;signal.h&gt;</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p> (Returned Value: the previous handler if success, SIG_ERR if error)</p>
<p>The “handler” parameter</p>
<p>​    a user specified function, or</p>
<p>​    SIG_DFL, or</p>
<p>​    SIG_IGN</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR) </span><br><span class="line">        err_sys(<span class="string">&quot;can&#x27;t catch SIGUSR1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">&quot;can&#x27;t catch SIGUSR2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">        pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-alarm-amp-pause-函数"><a href="#3-alarm-amp-pause-函数" class="headerlink" title="3 alarm &amp; pause 函数"></a><strong>3 alarm &amp; pause</strong> <strong>函数</strong></h3><p>alarm: 为信号的传送设置闹钟</p>
<p>#include &lt;unistd.h&gt;</p>
<p>unsigned int alarm(unsigned int seconds);</p>
<p> (Returned value: 0, or the number of seconds remaining of previous alarm)</p>
<p>pause: wait for a signal</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int pause(void);</p>
<p> (Returned value: -1, errno is set to be EINTR)</p>
<h3 id="4-信号阻塞"><a href="#4-信号阻塞" class="headerlink" title="**4.**信号阻塞"></a>**4.**信号阻塞</h3><p>有时既不希望进程在接收到信号时立刻中断进程的执行，也不希望此信号完全被忽略掉，而是延迟一段时间再去调用信号处理函数，这个时候就需要信号阻塞来完成。</p>
<h4 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a><strong>信号集处理函数</strong></h4><p>#include &lt;signal.h&gt;</p>
<p>int sigemptyset(sigset_t *set);</p>
<p>int sigfillset(sigset_t *set);</p>
<p>int sigaddset(sigset_t *set,int signum);</p>
<p>int sigdelset(sigset_t *set,int signum);</p>
<p>int sigismember(const sigset_t *set,int signum);</p>
<p>  参数：set 信号集 ；signum 信号</p>
<p>  返回值：若成功返回0，若出错返回-1。</p>
<p>  sigismember若真返回1，若假返回0，若出错返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;     <span class="keyword">sigset_t</span> *<span class="built_in">set</span>;</span><br><span class="line">      <span class="built_in">set</span>=(<span class="keyword">sigset_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>));</span><br><span class="line">      sigemptyset(<span class="built_in">set</span>);</span><br><span class="line">      sigaddset(<span class="built_in">set</span>,SIGUSR1);</span><br><span class="line">      sigaddset(<span class="built_in">set</span>,SIGINT);</span><br><span class="line">      <span class="keyword">if</span>((sigismember(<span class="built_in">set</span>,SIGUSR1))==<span class="number">1</span>)           <span class="built_in">printf</span>(<span class="string">&quot;SIGUSR1\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((sigismember(<span class="built_in">set</span>,SIGUSR2))==<span class="number">1</span>)           <span class="built_in">printf</span>(<span class="string">&quot;SIGUSR2\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((sigismember(<span class="built_in">set</span>,SIGINT))==<span class="number">1</span>)                  <span class="built_in">printf</span>(<span class="string">&quot;SIGINT\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号集处理函数sigprocmask"><a href="#信号集处理函数sigprocmask" class="headerlink" title="信号集处理函数sigprocmask"></a><strong>信号集处理函数</strong>sigprocmask</h4><p>#include &lt;signal.h&gt;</p>
<p>功能：检测或更改信号屏蔽字</p>
<p>函数：int sigprocmask(int how,const sigsett_t *set,sigset_t *oldset);</p>
<p>参数：how 操作方式set  </p>
<p>  how决定函数的操作方式。</p>
<p>  SIG_BLOCK：增加一个信号集合到当前进程的阻塞集合之中。</p>
<p>  SIG_UNBLOCK：从当前的阻塞集合之中删除一个信号集合。</p>
<p>  SIG_SETMASK：将当前的信号集合设置为信号阻塞集合。 </p>
<p>返回值：若成功返回0，若出错返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">sigset_t</span> *<span class="built_in">set</span>;</span><br><span class="line">  <span class="built_in">set</span>=(<span class="keyword">sigset_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>));</span><br><span class="line">  sigemptyset(<span class="built_in">set</span>);</span><br><span class="line">  sigaddset(<span class="built_in">set</span>,SIGINT);</span><br><span class="line">  sigprocmask(SIG_SETMASK,<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//也可以使用：sigprocmask(SIG_BLOCK,set,NULL);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序先定义信号集set，然后把信号SIGINT添加到set信号集中，最后把set设置为信号阻塞集合。运行程序时，进程进入死循环。按“ctrl+c”系统并没有中断程序，SIGINT信号屏蔽掉了。按”ctrl+z”来结束程序。 </p>
<h4 id="信号实例"><a href="#信号实例" class="headerlink" title="信号实例"></a><strong>信号实例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;        alarm(<span class="number">1</span>);          &#125;</span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">     signal(SIGALRM,handler);</span><br><span class="line">     alarm(<span class="number">1</span>);</span><br><span class="line">     sfd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"> 	<span class="comment">/*do</span></span><br><span class="line"><span class="comment">      &#123; sfd = open(argv[1],O_RDONLY);</span></span><br><span class="line"><span class="comment">         if (sfd&lt;0)</span></span><br><span class="line"><span class="comment">           &#123;  if (errno!= EINTR)</span></span><br><span class="line"><span class="comment">              &#123;  perror(&quot;open()&quot;);</span></span><br><span class="line"><span class="comment">                 exit(1);          &#125;      &#125;</span></span><br><span class="line"><span class="comment">    &#125;while(sfd&lt;0);*/</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;  pause();</span><br><span class="line">       len = read(sfd,buf,<span class="number">10</span>);</span><br><span class="line">      <span class="comment">/* while((len = read(sfd,buf,BUFSIZE))&lt;0)</span></span><br><span class="line"><span class="comment">     &#123;  if (errno == EINTR)</span></span><br><span class="line"><span class="comment">         continue;</span></span><br><span class="line"><span class="comment">        perror(&quot;read()&quot;);</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">      if (len==0) break;*/</span></span><br><span class="line"></span><br><span class="line">       ret = write(<span class="number">1</span>,buf,len);  </span><br><span class="line">     <span class="comment">/*while(len&gt;0)</span></span><br><span class="line"><span class="comment">     &#123;  ret = write(1,buf,len);</span></span><br><span class="line"><span class="comment">        if (ret &lt;0)</span></span><br><span class="line"><span class="comment">        &#123;  if (errno == EINTR)</span></span><br><span class="line"><span class="comment">             continue;</span></span><br><span class="line"><span class="comment">            perror(&quot;write&quot;);</span></span><br><span class="line"><span class="comment">            exit(1);</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">         len -= ret;</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-1-进程间通信"><a href="#6-1-进程间通信" class="headerlink" title="6.1 进程间通信"></a><strong>6.1</strong> <strong>进程间通信</strong></h2><p>IPC: Inter-Process Communication 进程间通信</p>
<p>IPC机制</p>
<p>​    shared file</p>
<p>​    signal</p>
<p>​    pipe, FIFO (named pipe), message queue, semaphore, shared memory</p>
<p>​    socket</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618215455459.png" alt="image-20210618215455459"></p>
<p><strong>Simple Client-Server or IPC model</strong></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618215509159.png" alt="image-20210618215509159"></p>
<h2 id="6-2-pipe-概念"><a href="#6-2-pipe-概念" class="headerlink" title="6.2 pipe 概念"></a><strong>6.2 pipe</strong> <strong>概念</strong></h2><p>Pipe</p>
<p>Pipe mechanism in a shellShell中的管道机构</p>
<p>​    e.g. cmd1 | cmd2</p>
<p>Pipe is half-duplex 半双工</p>
<p>管道只能在共同祖先的进程间使用</p>
<p>管道也是文件</p>
<p>命名管道(FIFO)</p>
<h3 id="pipe-函数"><a href="#pipe-函数" class="headerlink" title="pipe 函数"></a><strong>pipe</strong> <strong>函数</strong></h3><p>The pipe function: create a pipe</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int pipe(int filedes[2]);</p>
<p> (Returned value: 0 if success, -1 if failure)</p>
<p>A pipe: First In, First Out</p>
<p>filedes[0]:read, filedes[1]: write</p>
<h3 id="单个进程使用管道"><a href="#单个进程使用管道" class="headerlink" title="单个进程使用管道"></a><strong>单个进程使用管道</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121308293.png" alt="image-20210619121308293"></p>
<h3 id="父子进程使用管道"><a href="#父子进程使用管道" class="headerlink" title="父子进程使用管道"></a><strong>父子进程使用管道</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121321411.png" alt="image-20210619121321411"></p>
<h3 id="管道使用-1-：单个进程"><a href="#管道使用-1-：单个进程" class="headerlink" title="管道使用(1)：单个进程"></a>管道使用(1)：单个进程</h3><p>类似共享文件</p>
<p>pipe—write——read</p>
<h3 id="管道使用（2）多进程"><a href="#管道使用（2）多进程" class="headerlink" title="管道使用（2）多进程"></a>管道使用（2）多进程</h3><p>父-子进程/子-子进程</p>
<p>使用模式：</p>
<p>  pipe——fork——write（写进程）</p>
<p>​            ——read（读进程）</p>
<p>注意：pipe-fork顺序</p>
<h3 id="管道使用（3）用于标准输入输出"><a href="#管道使用（3）用于标准输入输出" class="headerlink" title="管道使用（3）用于标准输入输出"></a>管道使用（3）用于标准输入输出</h3><p>管道：shell中的形式</p>
<p>​    cmd1 | cmd2</p>
<p>​    重定向 cmd &gt; file</p>
<p>实现代码</p>
<p>​    执行cmd1前</p>
<p>​    if (fd[1] != STDOUT_FILENO) {</p>
<p>​     if (dup2(fd[1], STDOUT_FILENO) != STDOUT_FILENO)</p>
<p>​        err_sys(“dup2 error to stdout); </p>
<p>​    }</p>
<p>执行cmd2前</p>
<p>​    if (fd[0] != STDIN_FILENO) {</p>
<p>​     if (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)</p>
<p>​        err_sys(“dup2 error to stdin); </p>
<p>​    }</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121557088.png" alt="image-20210619121557088"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span> data_processed;    <span class="keyword">int</span> file_pipes[<span class="number">2</span>];    </span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> some_data[] = <span class="string">&quot;123&quot;</span>;    <span class="keyword">pid_t</span> fork_result;    </span><br><span class="line">   <span class="keyword">if</span> (pipe(file_pipes) == <span class="number">0</span>) </span><br><span class="line">      &#123;     fork_result = fork();       </span><br><span class="line">            <span class="keyword">if</span> (fork_result == (<span class="keyword">pid_t</span>)<span class="number">-1</span>)</span><br><span class="line">                &#123;    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork failure&quot;</span>);   </span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);        &#125;             </span><br><span class="line">            <span class="keyword">if</span> (fork_result == (<span class="keyword">pid_t</span>)<span class="number">0</span>) </span><br><span class="line">                &#123;   close(<span class="number">0</span>);          </span><br><span class="line">                    dup(file_pipes[<span class="number">0</span>]);           </span><br><span class="line">                    close(file_pipes[<span class="number">0</span>]);            </span><br><span class="line">                    close(file_pipes[<span class="number">1</span>]);            </span><br><span class="line">                    execlp(<span class="string">&quot;od&quot;</span>, <span class="string">&quot;od&quot;</span>, <span class="string">&quot;-c&quot;</span>, (<span class="keyword">char</span> *)<span class="number">0</span>);            </span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);        </span><br><span class="line">                   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">    &#123;  close(file_pipes[<span class="number">0</span>]);           </span><br><span class="line">        data_processed = write(file_pipes[<span class="number">1</span>], some_data,<span class="built_in">strlen</span>(some_data)); </span><br><span class="line">        close(file_pipes[<span class="number">1</span>]);           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - wrote %d bytes\n&quot;</span>, (<span class="keyword">int</span>)getpid(),data_processed);       </span><br><span class="line">      &#125;    </span><br><span class="line">   &#125;    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>od –c file</strong> <strong>以字符方式显示文件内容，如果没指定文件则以标准输入作为默认输入</strong></p>
<h2 id="6-3-popen-amp-pclose-函数"><a href="#6-3-popen-amp-pclose-函数" class="headerlink" title="6.3 popen &amp; pclose 函数"></a><strong>6.3</strong> <strong>popen</strong> <strong>&amp;</strong> <strong>pclose</strong> <strong>函数</strong></h2><p>#include &lt;stdio.h&gt;<br>FILE *popen(const char *command, const char *type);<br>int pclose(FILE *stream);</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121713195.png" alt="image-20210619121713195"></p>
<p>fp=popen(cmd,”r”)的pipe实现：<br>    FILE * popen(char * cmd,char * type)<br>    {  int fd; int p;<br>       pipe(fd);<br>       p=fork();<br>       if(p==0)  {  close(1);dup(fd[1]);<br>                     execl(cmd,cmd,NULL);  }<br>       else       {   wait();<br>                         fp=fdopen(fd[0],”r”); return fp;  }<br>      }</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121805879.png" alt="image-20210619121805879"></p>
<h4 id="例3-13-设计一程序，要求用popen创建管道，实现“ls-–l-grep-fifo”的功能。"><a href="#例3-13-设计一程序，要求用popen创建管道，实现“ls-–l-grep-fifo”的功能。" class="headerlink" title="例3-13 设计一程序，要求用popen创建管道，实现“ls –l|grep fifo”的功能。"></a>例3-13 设计一程序，要求用popen创建管道，实现“ls –l|grep fifo”的功能。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>	</span></span><br><span class="line"><span class="function"></span>&#123; 	FILE *fp;	<span class="keyword">int</span> num;   	<span class="keyword">char</span> buf[<span class="number">500</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf)); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;建立管道……\n&quot;</span>);</span><br><span class="line">	fp=popen(<span class="string">&quot;ls -l&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line">	<span class="keyword">if</span>(fp!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;  num=fread(buf,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">500</span>,fp);</span><br><span class="line">	   <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">	    &#123; <span class="built_in">printf</span>(<span class="string">&quot;第一个命令是“ls–l”，运行结果如下：\n&quot;</span>);</span><br><span class="line">	      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);	    &#125;</span><br><span class="line">	   pclose(fp);	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123; <span class="built_in">printf</span>(<span class="string">&quot;用popen创建管道错误\n&quot;</span>);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;	&#125;</span><br><span class="line">	fp=popen(“grep fifo<span class="string">&quot;,&quot;</span>w<span class="string">&quot;);   </span></span><br><span class="line"><span class="string">	printf(&quot;</span>第二个命令是“grep fifo”，运行结果如下：\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	fwrite(buf,sizeof(char),500,fp);</span></span><br><span class="line"><span class="string">	pclose(fp);</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用popen函数读写管道，实际上也是调用pipe函数建立一个管道，再调用fork函数建立子进程，接着会建立一个shell环境，并在这个shell环境中执行参数指定的进程。</p>
<h4 id="例3-14-在程序中获得另一个程序的输出"><a href="#例3-14-在程序中获得另一个程序的输出" class="headerlink" title="例3-14 在程序中获得另一个程序的输出"></a>例3-14 在程序中获得另一个程序的输出</h4><p>popen_two.c</p>
<p>gcc myuclc.c -o myuclc</p>
<p>gcc popen_two.c -o two</p>
<p>输入大写字母</p>
<p>按Ctrl+D结束程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">程序头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> line[MAXLINE];      FILE *fpin;  </span><br><span class="line">    fpin = popen(<span class="string">&quot;./myuclc&quot;</span>, <span class="string">&quot;r&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == fpin )          error_quit(<span class="string">&quot;popen error&quot;</span>);  </span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;prompt&gt; &quot;</span>, <span class="built_in">stdout</span>);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        <span class="keyword">if</span>( fgets(line, MAXLINE, fpin) == <span class="literal">NULL</span> )              <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF ) perror(<span class="string">&quot;fputs error to pipe&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>( pclose(fpin) == <span class="number">-1</span> )          perror (<span class="string">&quot;pclose error&quot;</span>);  </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Myuclc.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> c;  </span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        c = getchar();  </span><br><span class="line">        <span class="keyword">if</span>( EOF == c )  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isupper</span>(c) )  </span><br><span class="line">            c = <span class="built_in">tolower</span>(c);  </span><br><span class="line">        <span class="built_in">putchar</span>(c);  </span><br><span class="line">        <span class="keyword">if</span>( <span class="string">&#x27;\n&#x27;</span> == c )  </span><br><span class="line">            fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="6-4-FIFO-named-pipe命名管道"><a href="#6-4-FIFO-named-pipe命名管道" class="headerlink" title="6.4 FIFO: named pipe命名管道"></a>6.4 FIFO: named pipe命名管道</h2><p>管道和命名管道<br>相同点<br>不同点<br>    文件系统中<br>    内存传输数据<br>    同步：一个重要的考虑<br>mkfifo(1), mkfifo(3), mknod(1), mknod(2)</p>
<h3 id="创建FIFO"><a href="#创建FIFO" class="headerlink" title="创建FIFO"></a><strong>创建</strong>FIFO</h3><p>命令行方式：mknod filename p</p>
<p>​             mkfifo filename</p>
<p>程序方式：mkfifo: make a FIFO special file (a named pipe)</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/stat.h&gt;</p>
<p>int mkfifo(const char *pathname, mode_t mode);</p>
<p> (Returned value: 0 if success, -1 if failure)</p>
<p> 例： mkfifo(“/tmp/myfifo”,0666)</p>
<h3 id="访问FIFO"><a href="#访问FIFO" class="headerlink" title="访问FIFO"></a><strong>访问</strong>FIFO</h3><p>命令行方式</p>
<p>  (1)cat &lt; /tmp/myfifo       读FIFO文件</p>
<p>  (2)echo hello &gt;/tmp/myfifo 向FIFO写数据</p>
<p>  (3)cat &lt; /tmp/myfifo &amp;</p>
<p>​    echo “hello” &gt;/tmp/myfifo</p>
<h3 id="程序方式：用open打开一个FIFO"><a href="#程序方式：用open打开一个FIFO" class="headerlink" title="程序方式：用open打开一个FIFO"></a>程序方式：用open打开一个FIFO</h3><p>Review: “open” system call</p>
<p>int open(const char *pathname, int flags);</p>
<p>“flags” parameter</p>
<p>​    必须指定的互斥模式:</p>
<p>​        O_RDONLY, O_WRONLY, O_NONBLOCK</p>
<p>​    O_RDONLY：若无进程写方式打开FIFO，open阻塞</p>
<p>​    O_RDONLY |O_NONBLOCK：若无进程写方式打开FIFO，open立即返回文件描述符</p>
<p>​    O_WRONLY：若无进程读方式打开FIFO，open阻塞</p>
<p>​    O_WRONLY| O_NONBLOCK：若无进程读方式打开FIFO，open返回ENXIO错误,-1</p>
<h4 id="例3-15-两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo-p-c）一个消费者程序，从FIFO中读取数据（3-15fifo-c-c）。"><a href="#例3-15-两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo-p-c）一个消费者程序，从FIFO中读取数据（3-15fifo-c-c）。" class="headerlink" title="例3-15 两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo_p.c）一个消费者程序，从FIFO中读取数据（3-15fifo_c.c）。"></a>例3-15 两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo_p.c）一个消费者程序，从FIFO中读取数据（3-15fifo_c.c）。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO_NAME <span class="meta-string">&quot;/tmp/my_fifo“</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define BUFFER_SIZE PIPE_BUF</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define TEN_MEG (1024 * 1024 * 10)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">int main()</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;    int pipe_fd;    int res;    int open_mode = O_WRONLY;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     int bytes_sent = 0;    char buffer[BUFFER_SIZE + 1];    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     if (access(FIFO_NAME, F_OK) == -1) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     /*int access(const char *filenpath, int mode) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 F_OK 只判断是否存在</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 有效，则函数返回0，否则函数返回-1 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 */</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     &#123;    res = mkfifo(FIFO_NAME, 0777);        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">          if (res != 0) &#123;   fprintf(stderr, &quot;</span>Could not create fifo %s\n<span class="meta-string">&quot;, FIFO_NAME);            exit(EXIT_FAILURE);        &#125;    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">      &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        printf(&quot;</span>Process %d opening FIFO O_WRONLY\n<span class="meta-string">&quot;, getpid());    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">       pipe_fd = open(FIFO_NAME, open_mode);    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">       printf(&quot;</span>Process %d result %d\n<span class="meta-string">&quot;, getpid(), pipe_fd);    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">      if (pipe_fd != -1)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">          &#123;  while(bytes_sent &lt; TEN_MEG) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">               &#123; res = write(pipe_fd, buffer, BUFFER_SIZE);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                 if (res == -1) &#123;  fprintf(stderr, &quot;</span>Write <span class="meta-keyword">error</span> on pipe\n<span class="meta-string">&quot;); exit(EXIT_FAILURE);     &#125;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                 bytes_sent += res;        &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">             (void)close(pipe_fd);     &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">         else &#123;        exit(EXIT_FAILURE);            &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  printf(&quot;</span>Process %d finished\n<span class="meta-string">&quot;, getpid());    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  exit(EXIT_SUCCESS);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define FIFO_NAME &quot;</span>/tmp/my_fifo<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define BUFFER_SIZE PIPE_BUF</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">int main()</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;   int pipe_fd;    int res;    int open_mode = O_RDONLY;    char buffer[BUFFER_SIZE + 1];</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    int bytes_read = 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    memset(buffer, &#x27;\0&#x27;, sizeof(buffer));    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    printf(&quot;</span>Process %d opening FIFO O_RDONLY\n<span class="meta-string">&quot;, getpid());</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    pipe_fd = open(FIFO_NAME, open_mode);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    printf(&quot;</span>Process %d result %d\n<span class="meta-string">&quot;, getpid(), pipe_fd);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    if (pipe_fd != -1) &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        do &#123;       res = read(pipe_fd, buffer, BUFFER_SIZE);      </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                     bytes_read += res;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              &#125; while (res &gt; 0);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        (void)close(pipe_fd);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">      &#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    else &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        exit(EXIT_FAILURE);    &#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    printf(&quot;</span>Process %d finished, %d bytes read\n<span class="meta-string">&quot;, getpid(), bytes_read);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    exit(EXIT_SUCCESS);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>

<h3 id="FIFO的应用-1"><a href="#FIFO的应用-1" class="headerlink" title="FIFO的应用(1)"></a>FIFO的应用(1)</h3><p>用FIFO复制输出流</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619124043625.png" alt="image-20210619124043625"></p>
<p>mkfifo fifo1</p>
<p>prog3 &lt; fifo1 &amp;</p>
<p>prog1 &lt; infile | tee fifo1 | prog2</p>
<p><strong>tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中</strong> </p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619124101884.png" alt="image-20210619124101884"></p>
<h3 id="FIFO的应用-2"><a href="#FIFO的应用-2" class="headerlink" title="FIFO的应用(2)"></a>FIFO的应用(2)</h3><p>C/S应用程序</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619124145265.png" alt="image-20210619124145265"></p>
<h4 id="例3-16-client-c-server-c"><a href="#例3-16-client-c-server-c" class="headerlink" title="例3-16 client.c, server.c"></a>例3-16 client.c, server.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_FIFO_NAME <span class="meta-string">&quot;/tmp/serv_fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_FIFO_NAME <span class="meta-string">&quot;/tmp/cli_%d_fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_to_pass_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span>  client_pid;</span><br><span class="line">    <span class="keyword">char</span>   some_data[BUFFER_SIZE - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     <span class="comment">// 客户端程序</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">int</span> server_fifo_fd, client_fifo_fd;    <span class="class"><span class="keyword">struct</span> <span class="title">data_to_pass_st</span> <span class="title">my_data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> times_to_send;    <span class="keyword">char</span> client_fifo[<span class="number">256</span>];</span><br><span class="line">    server_fifo_fd = open(SERVER_FIFO_NAME, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (server_fifo_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, no server\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);    &#125;</span><br><span class="line">    my_data.client_pid = getpid();</span><br><span class="line">    <span class="built_in">sprintf</span>(client_fifo, CLIENT_FIFO_NAME, my_data.client_pid);</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(client_fifo, <span class="number">0777</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, can&#x27;t make %s\n&quot;</span>, client_fifo);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);    &#125; </span><br><span class="line">    <span class="keyword">for</span> (times_to_send = <span class="number">0</span>; times_to_send &lt; <span class="number">5</span>; times_to_send++) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(my_data.some_data, <span class="string">&quot;Hello from %d&quot;</span>, my_data.client_pid); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d sent %s, &quot;</span>, my_data.client_pid, my_data.some_data);</span><br><span class="line">        write(server_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data));</span><br><span class="line">        client_fifo_fd = open(client_fifo, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (client_fifo_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(client_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received: %s\n&quot;</span>, my_data.some_data);            &#125;</span><br><span class="line">            close(client_fifo_fd);        &#125;    &#125;</span><br><span class="line">    close(server_fifo_fd);</span><br><span class="line">    unlink(client_fifo);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//服务端程序</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span> server_fifo_fd, client_fifo_fd;    <span class="class"><span class="keyword">struct</span> <span class="title">data_to_pass_st</span> <span class="title">my_data</span>;</span>    <span class="keyword">int</span> read_res;    <span class="keyword">char</span> client_fifo[<span class="number">256</span>];    <span class="keyword">char</span> *tmp_char_ptr;</span><br><span class="line">     mkfifo(SERVER_FIFO_NAME, <span class="number">0777</span>);</span><br><span class="line">    server_fifo_fd = open(SERVER_FIFO_NAME, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (server_fifo_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Server fifo failure\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">/* lets clients queue for demo purposes */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;   read_res = read(server_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data));</span><br><span class="line">             <span class="keyword">if</span> (read_res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             tmp_char_ptr = my_data.some_data;</span><br><span class="line">            <span class="keyword">while</span> (*tmp_char_ptr) &#123; </span><br><span class="line">              *tmp_char_ptr = <span class="built_in">toupper</span>(*tmp_char_ptr);   </span><br><span class="line">               tmp_char_ptr++;       &#125;</span><br><span class="line">            <span class="built_in">sprintf</span>(client_fifo, CLIENT_FIFO_NAME, my_data.client_pid);</span><br><span class="line">            client_fifo_fd = open(client_fifo, O_WRONLY);</span><br><span class="line">            <span class="keyword">if</span> (client_fifo_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">                write(client_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data));</span><br><span class="line">                close(client_fifo_fd);    &#125;</span><br><span class="line">        &#125;    &#125; <span class="keyword">while</span> (read_res &gt; <span class="number">0</span>);</span><br><span class="line">    close(server_fifo_fd);</span><br><span class="line">    unlink(SERVER_FIFO_NAME);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例3-17-l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。"><a href="#例3-17-l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。" class="headerlink" title="例3-17 l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。"></a>例3-17 l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。</h4><p>Zhang.c</p>
<p>Li.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span> i, rfd,wfd,len=<span class="number">0</span>,fd_in;    <span class="keyword">char</span> str[<span class="number">32</span>];    <span class="keyword">int</span> flag,stdinflag;    fd_set write_fd,read_fd;    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">net_timer</span>;</span></span><br><span class="line">    mkfifo(<span class="string">&quot;fifo1&quot;</span>,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span><br><span class="line">    mkfifo(<span class="string">&quot;fifo2&quot;</span>,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span><br><span class="line">    wfd =open(<span class="string">&quot;fifo1&quot;</span>,O_WRONLY);     rfd =open(<span class="string">&quot;fifo2&quot;</span>,O_RDONLY);     <span class="keyword">if</span>(rfd&lt;=<span class="number">0</span>||wfd&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;      <span class="built_in">printf</span>(“这是张三端!\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    while(1)</span></span><br><span class="line"><span class="string">    &#123;   FD_ZERO(&amp;read_fd);   	</span></span><br><span class="line"><span class="string">        FD_SET(rfd,&amp;read_fd); 	</span></span><br><span class="line"><span class="string">        FD_SET(fileno(stdin),&amp;read_fd); /**/</span></span><br><span class="line"><span class="string">        net_timer.tv_sec=5;</span></span><br><span class="line"><span class="string">        net_timer.tv_usec=0;</span></span><br><span class="line"><span class="string">        memset(str,0,sizeof(str)); </span></span><br><span class="line"><span class="string">        if(i=select(rfd+1, &amp;read_fd,NULL, NULL, &amp;net_timer) &lt;= 0)            continue;</span></span><br><span class="line"><span class="string">        if(FD_ISSET(rfd,&amp;read_fd))</span></span><br><span class="line"><span class="string">    	&#123;      read(rfd,str,sizeof(str));             printf(&quot;</span>----------------------------\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">            printf(&quot;</span>李四:%s\n<span class="string">&quot;,str);     	&#125;</span></span><br><span class="line"><span class="string">        if(FD_ISSET(fileno(stdin),&amp;read_fd)) </span></span><br><span class="line"><span class="string">    	&#123;     printf(&quot;</span>----------------------------\n<span class="string">&quot;);            fgets(str,sizeof(str),stdin);</span></span><br><span class="line"><span class="string">            len=write(wfd,str,strlen(str)); </span></span><br><span class="line"><span class="string">    	&#125;    &#125;</span></span><br><span class="line"><span class="string">    close(rfd);</span></span><br><span class="line"><span class="string">    close(wfd);&#125;</span></span><br><span class="line"><span class="string">                                                                                                              </span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;	int i, rfd,wfd,len=0,fd_in;	char str[32];	int flag,stdinflag;</span></span><br><span class="line"><span class="string">	fd_set write_fd,read_fd;	struct timeval net_timer;</span></span><br><span class="line"><span class="string">	mkfifo(&quot;</span>fifo1<span class="string">&quot;,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span></span><br><span class="line"><span class="string">	mkfifo(&quot;</span>fifo2<span class="string">&quot;,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span></span><br><span class="line"><span class="string">	rfd =open(&quot;</span>fifo1<span class="string">&quot;,O_RDONLY); 	wfd =open(&quot;</span>fifo2<span class="string">&quot;,O_WRONLY); </span></span><br><span class="line"><span class="string">	if(rfd&lt;=0||wfd&lt;=0)return 0;		printf(&quot;</span>这是李四端!\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	while(1)</span></span><br><span class="line"><span class="string">	&#123; FD_ZERO(&amp;read_fd); 	FD_SET(rfd,&amp;read_fd);	</span></span><br><span class="line"><span class="string">	  FD_SET(fileno(stdin),&amp;read_fd);		net_timer.tv_sec=5;</span></span><br><span class="line"><span class="string">	  net_timer.tv_usec=0;		memset(str,0,sizeof(str)); </span></span><br><span class="line"><span class="string">	  if(i=select(rfd+1,&amp;read_fd,NULL, NULL, &amp;net_timer) &lt;= 0)	continue;</span></span><br><span class="line"><span class="string">		if(FD_ISSET(rfd,&amp;read_fd))</span></span><br><span class="line"><span class="string">		&#123;	read(rfd,str,sizeof(str)); </span></span><br><span class="line"><span class="string">			printf(&quot;</span>----------------------------\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			printf(&quot;</span>张三:%s\n<span class="string">&quot;,str); 		&#125;</span></span><br><span class="line"><span class="string">		if(FD_ISSET(fileno(stdin),&amp;read_fd))</span></span><br><span class="line"><span class="string">		&#123;	printf(&quot;</span>----------------------------\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			fgets(str,sizeof(str),stdin);</span></span><br><span class="line"><span class="string">			len=write(wfd,str,strlen(str)); /*写入管道*/		&#125;</span></span><br><span class="line"><span class="string">	&#125;	close(rfd);</span></span><br><span class="line"><span class="string">	close(wfd);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-1-System-V-IPC的共同特征"><a href="#7-1-System-V-IPC的共同特征" class="headerlink" title="7.1 System V IPC的共同特征"></a><strong>7.1 System V IPC</strong>的共同特征</h2><p>进程间通信（interprocess communication）</p>
<p>IPC objects</p>
<ul>
<li><p>信号量(semaphore set)</p>
</li>
<li><p>消息队列(message queue)</p>
</li>
<li><p>共享内存(shared memory)</p>
</li>
</ul>
<p>shell命令</p>
<ul>
<li><p>ipcs  -q/-m/-s</p>
</li>
<li><p>ipcrm –q/-m/-s <id></p>
</li>
<li><p>ipcrm -Q/-M/-S <key></p>
</li>
</ul>
<p>标识符与关键字<br>    创建IPC对象时指定关键字(key_t key;)<br>        key的选择；预定义常数IPC_PRIVATE；ftok函数<br>    引用IPC对象：标识符<br>    内核将关键字转换成标识符<br>许可权结构<br>    和文件类比<br>    struct ipc_perm</p>
<h3 id="SV-IPC-System-Calls-Overview"><a href="#SV-IPC-System-Calls-Overview" class="headerlink" title="SV IPC System Calls Overview"></a><strong>SV IPC System Calls Overview</strong></h3><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>消息队列</strong></th>
<th><strong>信号量</strong></th>
<th><strong>共享内存</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分配一个IPC对象，获得对IPC的访问</td>
<td>msgget</td>
<td>semget</td>
<td>shmget</td>
</tr>
<tr>
<td>IPC操作:  发送/接收消息，信号量操作，连接/释放共享内存</td>
<td>msgsnd/  msgrcv</td>
<td>semop</td>
<td>shmat/  shmdt</td>
</tr>
<tr>
<td>IPC控制：获得/修改状态信息，取消IPC</td>
<td>msgctl</td>
<td>semctl</td>
<td>shmctl</td>
</tr>
</tbody></table>
<h3 id="ftok函数"><a href="#ftok函数" class="headerlink" title="ftok函数"></a><strong>ftok</strong>函数</h3><p>创建函数</p>
<p>key_t ftok( char * filename, int id)；</p>
<p>功能说明</p>
<p>将一个已存在的文件名(该文件必须是存在而且可以访问的)和一个整数标识符id转换成一个key_t值</p>
<p>在Linux系统实现中，调用该函数时，系统将文件的索引节点号取出，并在前面加上子序号，从而得到key_t的返回值</p>
<h3 id="创建IPC对象"><a href="#创建IPC对象" class="headerlink" title="创建IPC对象"></a>创建IPC对象</h3><p>key：可由ftok()函数产生或定义为IPC_PRIVATE常量</p>
<p>flag：包括读写权限，还可包含IPC_CREATE和IPC_EXCL标志位，组合效果如下</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133437323.png" alt="image-20210619133437323"></p>
<h2 id="7-2-Message-queue"><a href="#7-2-Message-queue" class="headerlink" title="7.2 Message queue"></a><strong>7.2 Message queue</strong></h2><p>消息队列<br><strong>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</strong><br>First in, first out<br>message type: 优先级=<br>块数据</p>
<h3 id="消息队列——程序结构"><a href="#消息队列——程序结构" class="headerlink" title="消息队列——程序结构"></a>消息队列——程序结构</h3><p>proto.h:约定的消息队列通信格式<br>send.c<br>receive.c</p>
<p>proto.h:约定的消息队列通信格式:</p>
<p>  #define KEYPATH “/etc/services”</p>
<p>  #define KEYPROJ ‘a’</p>
<p>  struct msg_st {</p>
<p>​     char * msg;</p>
<p>​     long  type;</p>
<p>​     …</p>
<p>   }</p>
<h3 id="消息队列——系统函数"><a href="#消息队列——系统函数" class="headerlink" title="消息队列——系统函数"></a>消息队列——系统函数</h3><p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/ipc.h&gt;<br>#include &lt;sys/msg.h&gt;</p>
<p>int msgget(key_t key, int flag);<br>int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);<br>int msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);<br>int msgctl(int msqid, int cmd, struct shmid_ds *buf);</p>
<h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a><strong>msgget</strong></h3><p>Ø函数原型  int msgget(key_t key, int flag);</p>
<p>Ø参数说明</p>
<p>ü  key：待创建/打开队列的键值</p>
<p>ü  flag：创建/打开方式</p>
<p>​    常取IPC_CREAT|IPC_EXCL|0666</p>
<p>​    若不存在key值的队列，则创建；否则，若存在，则打开队列</p>
<p>​    0666表示与一般文件权限一样</p>
<p>Ø返回值</p>
<p>​    成功返回消息队列描述字，否则返回-1</p>
<p>Ø说明</p>
<p>   IPC_CREAT一般由服务器程序创建消息队列时使用</p>
<p>   若是客户程序，须打开现有消息队列，而不用IPC_CREAT </p>
<h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a><strong>msgsnd</strong></h3><p>Ø函数原型</p>
<p>int msgsnd(int msqid, struct msgbuf *msgp, size_t size, int flag);</p>
<p>Ø说明</p>
<p>flag有意义的标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待</p>
<p>Ø内核须对msgsnd( )函数完成的工作</p>
<p>ü检查消息队列描述符、许可权及消息长度</p>
<p>​    若合法，继续执行;否则，返回</p>
<p>ü内核为消息分配数据区，将消息正文拷贝到消息数据区</p>
<p>ü分配消息首部，并将它链入消息队列的末尾</p>
<p>ü修改消息队列头数据，如队列中的消息数、字节总数等</p>
<p>ü唤醒等待消息的进程</p>
<h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a><strong>msgrcv</strong></h3><p>Øint msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);</p>
<p>Ø参数说明</p>
<p>l   msgid：消息队列描述字</p>
<p>l   msgp：消息存储位置</p>
<p>l   size：消息内容的长度</p>
<p>l   type：请求读取的消息类型</p>
<p>l   flag：规定队列无消息时内核应做的操作 </p>
<p>​     IPC_NOWAIT：无满足条件消息时返回，此时errno=ENOMSG</p>
<p>​     IPC_EXCEPT：type&gt;0时使用，返回第一个类型不为type的消息 </p>
<p>​     IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的size字节，则把该消息截断，截断部分将丢失</p>
<h3 id="msgctl-message-control-operations"><a href="#msgctl-message-control-operations" class="headerlink" title="msgctl: message control operations"></a>msgctl: message control operations</h3><p>函数原型<br>int msgctl(int msqid, int cmd, struct msqid_ds *buf);<br>“cmd” 参数<br>IPC_STAT: 把msqid_ds结构中的数据置为消息队列的当前关联值<br>IPC_SET: 在进程有足够权限的前提下，把消息队列的当前关联值置为msqid_ds结构给出的值<br>IPC_RMID: 删除消息队列</p>
<h3 id="消息队列——Example"><a href="#消息队列——Example" class="headerlink" title="消息队列——Example"></a>消息队列——Example</h3><p>A C/S application<br>一台服务器，多个客户机：只需要一个队列。与FIFO实现相比</p>
<h3 id="消息队列属性"><a href="#消息队列属性" class="headerlink" title="消息队列属性"></a><strong>消息队列属性</strong></h3><p>消息队列创建后，操作系统在内核中分配了一个名称为msqid_ds的数据结构用于管理该消息队列。<br>在程序中可以通过函数msgctl对该结构进行读写，从而实现对消息队列的控制功能。 </p>
<p>成员说明：<br>1）msg_perm：IPC许可权限结构。<br>2）msg_stime：最后一次向该消息队列发送消息（msgsnd）的时间。<br>3）msg_rtime：最后一次从该消息队列接收消息（msgrcv）的时间。<br>4）msg_ctime：最后一次调用msgctl的时间。<br>5）msg_cbytes：当前该消息队列中的消息长度，以字节为单位。<br>6）msg_qnum：当前该消息队列中的消息条数。<br>7）msg_qbytes：该消息队列允许存储的最大长度，以字节为单位。<br>8）msg_lspid：最后一次向该消息队列发送消息（msgsnd）的进程ID。<br>9）msg_lrpid：最后一次从该消息队列接收消息（msgrcv）的进程ID。</p>
<p>使用：<br>    msg_sinfo.msg_qbytes = 1666;<br>    msgctl(msgqid,IPC_SET,&amp;msg_sinfo)</p>
<h4 id="例3-18-msg-stat-c"><a href="#例3-18-msg-stat-c" class="headerlink" title="例3-18 msg_stat.c"></a>例3-18 msg_stat.c</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133908134.png" alt="image-20210619133908134"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133920223.png" alt="image-20210619133920223"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133947032.png" alt="image-20210619133947032"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133957944.png" alt="image-20210619133957944"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619134026407.png" alt="image-20210619134026407"></p>
<h2 id="7-3-Shared-memory"><a href="#7-3-Shared-memory" class="headerlink" title="7.3 Shared memory"></a><strong>7.3 Shared memory</strong></h2><p>共享内存是内核为进程创建的一个特殊内存段，它可连接(attach)到自己的地址空间，也可以连接到其它进程的地址空间</p>
<p>​    最快的进程间通信方式</p>
<p>​    不提供任何同步功能</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619134117718.png" alt="image-20210619134117718"></p>
<h3 id="共享内存实现途径"><a href="#共享内存实现途径" class="headerlink" title="共享内存实现途径"></a><strong>共享内存实现途径</strong></h3><p>mmap()系统调用</p>
<p>  将普通文件在不同的进程中打开并映射到内存</p>
<p>  不同进程通过访问映射来达到共享内存目的</p>
<p>POSIX共享内存机制（Linux 2.6未实现）</p>
<p>System V共享内存</p>
<p>  在内存文件系统tmpfs中建立文件</p>
<p>  文件映射到不同进程空间</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h3><p>lmmap()系统调用使得==进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write()等操作。==</p>
<p>#include &lt; unistd.h &gt;</p>
<p>#include &lt;sys/mman.h &gt;</p>
<p>void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset )</p>
<p>int munmap( void * addr, size_t len ) </p>
<p>int msync ( void * addr , size_t len, int flags) </p>
<p>void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset ) </p>
<p>addr:指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。</p>
<p>len:映射到调用进程地址空间的字节数，从被映射文件开头offset个字节开始算起。 </p>
<p>prot :指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。</p>
<p>flags;指定映射对象的类型，映射选项和映射页是否可以共享。由以下几个常值指定：MAP_SHARED , MAP_PRIVATE 必选其一。</p>
<p>fd:为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANONYMOUS，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，只能用于具有亲缘关系的进程间通信）。</p>
<p>offset参数一般设为0，表示从文件头开始映射。</p>
<p>函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。</p>
<p>mmap()用于共享内存的两种方式 ：</p>
<p> （1）使用普通文件提供的内存映射：适用于任何进程之间；需要打开或创建一个文件，然后再调用mmap()；调用代码如下：</p>
<p>   fd=open(name, flag, mode);</p>
<p>   if(fd&gt;0)</p>
<p>   ptr=mmap(NULL, len , PROT_READ|PROT_WRITE,  </p>
<p>​            MAP_SHARED , fd , 0); </p>
<p>（2） 使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；</p>
<p>l调用代码如下：</p>
<p>  ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS ,-1 , 0); </p>
<p>由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。在调用fork()之后，子进程继承父进程匿名映射后的地址空间，也继承mmap()返回的地址 </p>
<p>  不必指定具体的文件，只要设置相应的标志即可 </p>
<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap()"></a><strong>munmap()</strong></h3><p>int munmap( void * addr, size_t len )<br> 该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<h3 id="msync"><a href="#msync" class="headerlink" title="msync()"></a><strong>msync</strong>()</h3><p>  int msync ( void * addr , size_t len, int flags)<br> 一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。 </p>
<h4 id="例3-19mmap-c-l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。"><a href="#例3-19mmap-c-l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。" class="headerlink" title="例3-19mmap.c l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。"></a>例3-19mmap.c l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>     	</span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) 	</span><br><span class="line"> &#123; 	<span class="keyword">pid_t</span> result;   	<span class="keyword">int</span> i;	people *p_map;	<span class="keyword">char</span> temp;</span><br><span class="line">	p_map=(people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);   </span><br><span class="line">  result=fork();      	</span><br><span class="line">	<span class="keyword">if</span>(result&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;	perror(<span class="string">&quot;创建子进程失败&quot;</span>);	<span class="built_in">exit</span>(<span class="number">0</span>);	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (result==<span class="number">0</span>)	</span><br><span class="line">	&#123;	sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子进程读取: 第 %d 个人的年龄是： %d\n&quot;</span>,i+<span class="number">1</span>,(*(p_map+i)).age);</span><br><span class="line">		(*p_map).age = <span class="number">110</span>;</span><br><span class="line">		munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>); <span class="comment">/*解除内存映射关系*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">		temp = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		&#123;	temp += <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memcpy</span>((*(p_map+i)).name, &amp;temp,<span class="number">1</span>);</span><br><span class="line">			(*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;父进程读取: 五个人的年龄和是： %d\n&quot;</span>,(*p_map).age );</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;解除内存映射……\n&quot;</span>);</span><br><span class="line">		munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;解除内存映射成功！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用特殊文件提供匿名内存映射，适用于具有亲缘关系的进程之间。==一般而言，子进程单独维护从父进程继承下来的一些变量。而mmap函数的返回地址，由父子进程共同维护。==</p>
<h3 id="System-V-IPC共享内存的实现"><a href="#System-V-IPC共享内存的实现" class="headerlink" title="System V IPC共享内存的实现"></a><strong>System V IPC</strong>共享内存的实现</h3><p>通过映射到tmpfs中的shm文件对象实现共享主存</p>
<ul>
<li>  每个共享主存区对应tmpfs中的一个文件（通过shmid_kernel关联）</li>
</ul>
<p>创建过程</p>
<ol>
<li>从主存申请共享主存管理结构，初始化相应shmid_kernel结构</li>
<li>在tmpfs中创建并打开一个同名文件</li>
<li>在主存中建立与该文件对应的dentry及inode结构</li>
<li>返回相应标识符</li>
</ol>
<h3 id="System-V-shared-memory"><a href="#System-V-shared-memory" class="headerlink" title="System V shared memory"></a><strong>System V shared memory</strong></h3><p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/ipc.h&gt;</p>
<p>#include &lt;sys/shm.h&gt;</p>
<p>int shmget(key_t key, int size, int flag);</p>
<p>void *shmat(int shmid, void *addr, int flag);</p>
<p>int shmdt(void *addr);</p>
<p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</p>
<h3 id="mmap和System-V"><a href="#mmap和System-V" class="headerlink" title="mmap和System V"></a>mmap和System V</h3><p>1.System V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。</p>
<p>2.System V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。</p>
<h2 id="7-4-信号量"><a href="#7-4-信号量" class="headerlink" title="7.4 信号量"></a><strong>7.4</strong> <strong>信号量</strong></h2><p>用来协调进程对共享资源的访问 </p>
<p>相关函数semget，semop，semctl</p>
<p>所需头文件</p>
<p>  #include &lt;sys/types.h&gt;</p>
<p>  #include &lt;sys/ipc.h&gt;</p>
<p>  #include &lt;sys/sem.h&gt;</p>
<h3 id="相关函数——semget"><a href="#相关函数——semget" class="headerlink" title="相关函数——semget"></a>相关函数——semget</h3><p>创建一个新信号量或取得一个已有信号量，原型为：int semget(key_t key, int num_sems, int sem_flags); </p>
<p><strong>参数key****：</strong>整数值 </p>
<p><strong>参数num_sems</strong>：指定需要的信号量数目，几乎总是1。 </p>
<p><strong>参数sem_flags</strong>：一组标志，信号量不存在时创建一个新的信号量，指定IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。</p>
<p>   指定IPC_CREAT | IPC_EXCL，创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。 </p>
<p><strong>返回值</strong>：成功返回一个相应信号标识符（非零），失败返回-1. </p>
<h3 id="相关函数——semop"><a href="#相关函数——semop" class="headerlink" title="相关函数——semop"></a>相关函数——semop</h3><p>操作一个或一组信号 ，原型为：</p>
<p>int semop(int sem_id, struct sembuf *sem_opa, size_t nsops); </p>
<p>​    semid：信号集的识别码，可通过<a target="_blank" rel="noopener" href="http://baike.baidu.com/subview/5298141/5328468.htm">semget</a>获取。</p>
<p>​    sem_opa：指向存储信号操作结构的<a target="_blank" rel="noopener" href="http://baike.baidu.com/subview/3026322/3026322.htm">数组指针</a>，信号操作结构的原型如下</p>
<p>  <strong>struct</strong> sembuf{ </p>
<p>​    <strong>short</strong> sem_num;  //信号量集中的信号量编号0，1…… </p>
<p>​    <strong>short</strong> sem_op;   //信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，一个是+1。 </p>
<p>​    <strong>short</strong> sem_flg;//通常为SEM_UNDO,使操作系统跟踪信号并在进程没有释放该信号量而终止时，操作系统释放信号量 </p>
<p>   }; </p>
<p>lnsops：信号量操作结构的数量，大于或等于1</p>
<h3 id="相关函数——semctl"><a href="#相关函数——semctl" class="headerlink" title="相关函数——semctl"></a>相关函数——semctl</h3><p>该函数用来直接控制信号量信息，它的原型为</p>
<p>int semctl(int sem_id, int sem_num, int command, …); </p>
<p>第四个参数，它通常是一个union semum结构，定义如下： </p>
<p><strong>union</strong> semun{ </p>
<p>  <strong>int</strong> val; </p>
<p>  <strong>struct</strong> semid_ds *buf; </p>
<p>  unsigned <strong>short</strong> *arry; </p>
<p>}; </p>
<h4 id="例3-20sem1-c"><a href="#例3-20sem1-c" class="headerlink" title="例3-20sem1.c"></a>例3-20sem1.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">char</span> message = <span class="string">&#x27;X&#x27;</span>;      <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)          </span><br><span class="line">        message = argv[<span class="number">1</span>][<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  </span><br><span class="line">    &#123;   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        sleep(rand() % <span class="number">3</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        sleep(rand() % <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    sleep(<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d - finished\n&quot;</span>, getpid());  </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="例3-21sem2-c"><a href="#例3-21sem2-c" class="headerlink" title="例3-21sem2.c"></a>例3-21sem2.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span>  </span><br><span class="line">    sem_union.val = <span class="number">1</span>; <span class="comment">//用于初始化信号量 </span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span>  </span><br><span class="line">      <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to delete semaphore\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;      <span class="comment">//对信号量做减1操作，即等待P（sv）  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span>  </span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;  </span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;<span class="comment">//P()  </span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;  </span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_p failed\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//这是一个释放操作，它使信号量变为可用，即发送信号V（sv）  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span>  </span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;  </span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;<span class="comment">//V()  </span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;  </span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_v failed\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span>  </span></span><br><span class="line"><span class="class">&#123;</span>   <span class="keyword">int</span> val;      <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>      <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;  &#125;;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sem_id = <span class="number">0</span>;    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="keyword">char</span> message = <span class="string">&#x27;X&#x27;</span>;      <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">     sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT); <span class="comment">//创建信号量  </span></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)  </span><br><span class="line">    &#123;  <span class="keyword">if</span>(!set_semvalue())         <span class="comment">//程序第一次被调用，初始化信号量     </span></span><br><span class="line">             &#123;  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “Failed to initialize semaphore\n”);          </span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE); &#125;  </span><br><span class="line">       message = argv[<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//设置要输出到屏幕中的信息，即其参数的第一个字符 </span></span><br><span class="line">        sleep(<span class="number">2</span>);     </span><br><span class="line">      &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  </span><br><span class="line">    &#123;   <span class="keyword">if</span>(!semaphore_p())   <span class="comment">//进入临界区 前执行P操作</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message);          fflush(<span class="built_in">stdout</span>);          sleep(rand() % <span class="number">3</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message); <span class="comment">//离开临界区前再一次向屏幕输出数据 </span></span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        <span class="keyword">if</span>(!semaphore_v())  </span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">//离开临界区，休眠随机时间后继续循环 </span></span><br><span class="line">        sleep(rand() % <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    sleep(<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d - finished\n&quot;</span>, getpid());  </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)      &#123;   sleep(<span class="number">3</span>);          del_semvalue();      &#125; </span><br><span class="line">         <span class="comment">//如果程序是第一次被调用，则在退出前删除信号量 </span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h2 id="雨课堂题目整理-2"><a href="#雨课堂题目整理-2" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220213435.png" alt="image-20210610220213435"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220229500.png" alt="image-20210610220229500"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220240603.png" alt="image-20210610220240603"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220250059.png" alt="image-20210610220250059"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220300339.png" alt="image-20210610220300339"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220310461.png" alt="image-20210610220310461"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220321107.png" alt="image-20210610220321107"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220333714.png" alt="image-20210610220333714"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220410424.png" alt="image-20210610220410424"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220418478.png" alt="image-20210610220418478"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220429370.png" alt="image-20210610220429370"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220438832.png" alt="image-20210610220438832"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220449449.png" alt="image-20210610220449449"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220502760-1623333903786.png" alt="image-20210610220502760"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220526628.png" alt="image-20210610220526628"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220536612.png" alt="image-20210610220536612"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220544837.png" alt="image-20210610220544837"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220603324.png" alt="image-20210610220603324"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220612511.png" alt="image-20210610220612511"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220619429.png" alt="image-20210610220619429"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220627025.png" alt="image-20210610220627025"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220637248.png" alt="image-20210610220637248"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220655591.png" alt="image-20210610220655591"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220705258.png" alt="image-20210610220705258"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220715535.png" alt="image-20210610220715535"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220730081.png" alt="image-20210610220730081"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220748981.png" alt="image-20210610220748981"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220804988.png" alt="image-20210610220804988"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220811818.png" alt="image-20210610220811818"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220821845.png" alt="image-20210610220821845"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220829105.png" alt="image-20210610220829105"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220836629.png" alt="image-20210610220836629"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220844183.png" alt="image-20210610220844183"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220851954.png" alt="image-20210610220851954"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220908753.png" alt="image-20210610220908753"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220915232.png" alt="image-20210610220915232"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220927300.png" alt="image-20210610220927300"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220935403.png" alt="image-20210610220935403"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220943592.png" alt="image-20210610220943592"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220952495.png" alt="image-20210610220952495"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220959961.png" alt="image-20210610220959961"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221006902.png" alt="image-20210610221006902"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221014835.png" alt="image-20210610221014835"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221021551.png" alt="image-20210610221021551"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221029470.png" alt="image-20210610221029470"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  num;</span><br><span class="line"></span><br><span class="line">&#125; number;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    number *p_map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p_map=(number*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(number)*<span class="number">10000</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS ,fp,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    result=fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程开始读取&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tempC;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>,length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            temp = read(fp, &amp;tempC, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tempC);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tempC==<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                readSize = readSize+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程读取: 第 %d 个a\n&quot;</span>,++i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程读取wan: 第 %d 个a\n&quot;</span>,++i);</span><br><span class="line"></span><br><span class="line">        (*p_map).num = readSize;</span><br><span class="line"></span><br><span class="line">        munmap(p_map,<span class="keyword">sizeof</span>(number)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;父进程读取: a的个数是： %d\n&quot;</span>,(*p_map).num );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;解除内存映射……\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        munmap(p_map,<span class="keyword">sizeof</span>(number)*<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;解除内存映射成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="0-服务器和客户机的信息函数"><a href="#0-服务器和客户机的信息函数" class="headerlink" title="0 服务器和客户机的信息函数"></a><strong>0</strong> <strong>服务器和客户机的信息函数</strong></h2><h3 id="1-字节序列转换"><a href="#1-字节序列转换" class="headerlink" title="**1.**字节序列转换"></a>**1.**字节序列转换</h3><p>每一台机器内部对变量的字节存储顺序不同，而网络传输的数据是一定要统一顺序的。所以对内部字节表示顺序与网络字节顺序（大端）不同的机器，一定要对数据进行转换</p>
<p>真正转换还是不转换是由系统函数自己来决定的。 </p>
<p>头文件：include &lt;arpa/inet.h&gt; </p>
<p> unsigned short int htons（unsigned short int hostshort）：<br> 主机字节顺序转换成网络字节顺序，对无符号短型进行操作4bytes<br> unsigned long int htonl（unsigned long int hostlong）：<br> 主机字节顺序转换成网络字节顺序，对无符号长型进行操作8bytes<br> unsigned short int ntohs（unsigned short int netshort）：<br> 网络字节顺序转换成主机字节顺序，对无符号短型进行操作4bytes<br> unsigned long int ntohl（unsigned long int netlong）：<br> 网络字节顺序转换成主机字节顺序，对无符号长型进行操作8bytes</p>
<h3 id="2-地址格式转换"><a href="#2-地址格式转换" class="headerlink" title="**2.**地址格式转换"></a>**2.**地址格式转换</h3><p><strong>头文件</strong>：#include &lt;sys/types.h&gt; 　　</p>
<p>​       #include &lt;sys/socket.h&gt; 　　</p>
<p>​       #include &lt;arpa/inet.h&gt; </p>
<p><strong>int</strong> inet_pton(<strong>int</strong> family, <strong>const</strong> <strong>char</strong> *strptr, <strong>void</strong> *addrptr); </p>
<p>转换字符串到网络地址 。 返回：1成功；-1出错 </p>
<p><strong>const</strong> <strong>char</strong>* inet_ntop(<strong>int</strong> family, <strong>const</strong> <strong>void</strong> *addrptr, <strong>char</strong> *strptr, <strong>size_t</strong> len); </p>
<p>转换网络二进制结构到ASCII类型的地址</p>
<p> 返回：成功，指向结果的指针；出错，NULL  </p>
<h2 id="1-Socket-基础"><a href="#1-Socket-基础" class="headerlink" title="1 Socket 基础"></a><strong>1 Socket</strong> <strong>基础</strong></h2><p>socket是网络编程的一种接口，它是一种特殊的I/O，用socket函数建立一个Socket连接，此函数返回一个整型的socket描述符，随后进行数据传输。</p>
<p>一个IP地址，一个通讯端口，就能确定一个通讯程序的位置。为此开发人员专门设计了一个套接结构，就是把网络程序中所用到的网络地址和端口信息放在一个结构体中。</p>
<p>一般套接口地址结构都以“sockaddr”开头。socket根据所使用的协议的不同可以分TCP套接口和UDP套接口，又称为流式套接口和数据套接口。</p>
<p>UDP是一个无连接协议，TCP是个可靠的端对端协议。传输UDP数据包时，LINUX不知道也不关心它们是否已经安全到达目的地，而传输TCP数据包时，则应先建立连接以保证传输的数据被正确接收。</p>
<p><strong>三种类型套接字</strong></p>
<p>流套接字(SOCK_STREAM)</p>
<p>​    可靠的、面向连接的通信。</p>
<p>​    使用TCP协议</p>
<p>数据报套接字(SOCK_DGRAM)</p>
<p>​    无连接服务</p>
<p>​    使用UDP协议</p>
<p>原始套接字(SOCK_RAW)</p>
<p>​    允许对底层协议如IP、ICMP直接访问</p>
<h3 id="1-socket套接字的数据结构"><a href="#1-socket套接字的数据结构" class="headerlink" title="1. socket套接字的数据结构"></a><strong>1. socket</strong>套接字的数据结构</h3><p>两个重要的数据类型：sockaddr和sockaddr_in，这两个结构类型都是用来保存socket信息的，如IP地址、通信端口等。</p>
<p>sockaddr——虚拟定义的地址（取决于协议）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;</span><br><span class="line">      <span class="comment">/*可以为AF_INET，代表TCP/IP地址族*/</span></span><br><span class="line">   <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">      <span class="comment">/*14个字节，包含IP地址和端口号*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sockaddr_in（AF_INET中使用的地址定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class"> &#123;</span>   <span class="keyword">short</span> sin_family;         <span class="comment">/*AF_INET（地址族）*/</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;</span><br><span class="line">        <span class="comment">/*端口号(必须要采用网络数据格式)*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">          <span class="comment">/*网络字节序的IP地址*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">         <span class="comment">/*与SOCKADDR结构保持同样大小*/</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于连接的服务"><a href="#2-基于连接的服务" class="headerlink" title="2. 基于连接的服务"></a><strong>2.</strong> <strong>基于连接的服务</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619170114870.png" alt="image-20210619170114870"></p>
<h4 id="Server程序的作用"><a href="#Server程序的作用" class="headerlink" title="Server程序的作用"></a><strong>Server程序</strong>的作用</h4><p>程序初始化</p>
<p>持续监听一个固定的端口</p>
<p>收到Client的连接后建立一个socket连接</p>
<p>与Client进行通信和信息处理</p>
<p>​    接收Client通过socket连接发送来的数据，进行相应处理并返回处理结果</p>
<p>​    通过socket连接向Client发送信息</p>
<p>通信结束后中断与Client的连接</p>
<h4 id="Client程序的作用"><a href="#Client程序的作用" class="headerlink" title="Client程序的作用"></a><strong>Client程序</strong>的作用</h4><p>程序初始化</p>
<p>连接到某个Server上，建立socket连接</p>
<p>与Server进行通信和信息处理</p>
<p>​    接收Server通过socket连接发送来的数据，进行相应处理</p>
<p>​    通过socket连接向Server发送请求信息</p>
<p>通信结束后中断与Server的连接</p>
<h3 id="3-无连接的服务"><a href="#3-无连接的服务" class="headerlink" title="3. 无连接的服务"></a>3. 无连接的服务</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619170325054.png" alt="image-20210619170325054"></p>
<h4 id="UDP编程的适用范围"><a href="#UDP编程的适用范围" class="headerlink" title="UDP编程的适用范围"></a>UDP编程的适用范围</h4><p>部分满足以下几点要求时，应该用UDP</p>
<p>​    面向数据报</p>
<p>​    网络数据大多为短消息</p>
<p>​    拥有大量Client</p>
<p>​    对数据安全性无特殊要求</p>
<p>​    网络负担非常重，但对响应速度要求高</p>
<p>例子：ICQ、视频点播</p>
<h4 id="具体编程时的区别"><a href="#具体编程时的区别" class="headerlink" title="具体编程时的区别"></a><strong>具体编程时的区别</strong></h4><p>socket()的参数不同</p>
<p>UDP Server不需要调用listen和accept</p>
<p>UDP收发数据用sendto/recvfrom函数</p>
<p>TCP：地址信息在connect/accept时确定</p>
<p>UDP：在sendto/recvfrom函数中每次均需指定地址信息</p>
<p>UDP：shutdown函数无效</p>
<h2 id="2-TCP编程"><a href="#2-TCP编程" class="headerlink" title="2 TCP编程"></a>2 TCP编程</h2><p>基于TCP协议的编程，其最主要的特点是建立完连接后，才进行通信。</p>
<p>常用的基于TCP网络编程函数及功能 </p>
<p>头文件</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619170614129.png" alt="image-20210619170614129"></p>
<h3 id="1-基于TCP网络编程函数"><a href="#1-基于TCP网络编程函数" class="headerlink" title="1.基于TCP网络编程函数"></a>1.基于TCP网络编程函数</h3><p>socket: 创建用于通信的端点并返回描述符.</p>
<p>​    int socket(int domain, int type, int protocol);</p>
<p>“domain” parameter</p>
<p>​    指定通信域，即选择协议族，如 AF_INET,AF_INET6 …</p>
<p>“type” parameter</p>
<p>​    指定通信语义。 三种主要类型: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW</p>
<p>“protocol” parameter</p>
<p>​    usually 0 (default). </p>
<p>bind: binds a name to a socket</p>
<p>int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen);</p>
<p>struct sockaddr {</p>
<p>  sa_family_t sa_family;</p>
<p>  char sa_data[14];</p>
<p>}</p>
<h3 id="inet-aton-amp-inet-ntoa"><a href="#inet-aton-amp-inet-ntoa" class="headerlink" title="inet_aton &amp; inet_ntoa"></a><strong>inet_aton</strong> <strong>&amp;</strong> <strong>inet_ntoa</strong></h3><p>互联网地址操作例程</p>
<p>​    int inet_aton(const char *cp, struct in_addr *inp);</p>
<p>​    char* inet_ntoa (struct in_addr in);</p>
<p>inet_ntoa将一个32位数字表示的IP地址转换成点分十进制IP地址字符串</p>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a><strong>listen</strong></h3><p>listen: listen for connections on a socket</p>
<p>int listen(int s, int backlog);</p>
<p>参数说明：</p>
<p> s：socket()返回的套接口文件描述符。</p>
<p> backlog：进入队列中允许的连接的个数。进入的连接请求在使用系统调用accept()应答之前要在进入队列中等待。这个值是队列中最多可以拥有的请求的个数。大多数系统的缺省设置为20。</p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a><strong>accept</strong></h3><p>accept()函数将响应连接请求，建立连接</p>
<p>int accept(int sockfd,struct sockaddr *addr,int *addrlen);</p>
<p>accept缺省是阻塞函数，阻塞直到有连接请求</p>
<p>sockfd: 被动(倾听)的socket描述符</p>
<p>如果成功，返回一个新的socket描述符(connected socket descriptor)来描述该连接。这个连接用来与特定的Client交换信息</p>
<p>addr将在函数调用后被填入连接对方的地址信息，如对方的IP、端口等。</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a><strong>connect</strong></h3><p>connect: initiate a connection on a socket (connect to a server).</p>
<p>int connect(int sockfd, struct sockaddr *servaddr, int addrlen);</p>
<p>主动的socket</p>
<p>servaddr是事先填写好的结构，Server的IP和端口都在该数据结构中指定。</p>
<h3 id="send-recv"><a href="#send-recv" class="headerlink" title="**send/**recv"></a>**send/**recv</h3><p> send/recv: 面向连接</p>
<p>int send(int s, const void *msg, size_t len, int flag);</p>
<p>s：发送数据的套接口文件描述符。 </p>
<p>msg：发送的数据的指针 </p>
<p>len：数据的字节长度 </p>
<p>flag：标志设置为0。 </p>
<p>int recv(int s, void *buf, size_t len, int flag);</p>
<p>s：读取的套接口文件描述符。 </p>
<p>buf：保存读入信息的地址。</p>
<p>len：缓冲区的最大长度。 </p>
<p>flag：设置为0。 </p>
<h3 id="sendto-recvfrom"><a href="#sendto-recvfrom" class="headerlink" title="sendto/recvfrom"></a>sendto/recvfrom</h3><p>int sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socketlen_t tolen);</p>
<p>int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</p>
<h3 id="close-amp-shutdown"><a href="#close-amp-shutdown" class="headerlink" title="close &amp; shutdown"></a><strong>close &amp; shutdown</strong></h3><p>close</p>
<p>​    int close(int sockfd);</p>
<p>shutdown</p>
<p>​    int shutdown(int sockfd, int how);</p>
<p>​    how: SHUT_RD, SHUT_WR, SHUT_RDWR</p>
<p>shutdown直接对TCP连接进行操作，close只是对套接字描述符操作。</p>
<h4 id="例4-1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。"><a href="#例4-1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。" class="headerlink" title="例4.1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。"></a>例4.1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619171521320.png" alt="image-20210619171521320"></p>
<p>主要语句说明：<br>服务端<br>建立socket：socket(AF_INET, SOCK_STREAM, 0);<br>绑定bind：bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(struct sockaddr);<br>建立监听listen：listen(sockfd, BACKLOG);<br>响应客户请求：accept(sockfd,(struct sockaddr *)&amp;remote_addr, &amp;sin_size);<br>发送数据send：send(client_fd, “连接上了 \n”, 26, 0);<br>关闭close：close(client_fd);</p>
<p>客户端：<br>建立socket：socket(AF_INET, SOCK_STREAM, 0);<br>请求连接connect：connect(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(struct sockaddr))；<br>接收数据recv：recv(sockfd, buf, MAXDATASIZE, 0)；<br>关闭close：close(sockfd);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端源程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVPORT 3333 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> sockfd,client_fd;     <span class="keyword">int</span> sin_size;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span>     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span> </span><br><span class="line">     sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ;</span><br><span class="line">	my_addr.sin_family=AF_INET;</span><br><span class="line">	my_addr.sin_port=htons(SERVPORT);</span><br><span class="line">	my_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	bzero(&amp;(my_addr.sin_zero),<span class="number">8</span>); </span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;my_addr, <span class="keyword">sizeof</span>(my_addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;		perror(<span class="string">&quot;bind 出错！&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">if</span> (listen(sockfd, BACKLOG) == <span class="number">-1</span>) </span><br><span class="line">       &#123;	perror(<span class="string">&quot;listen 出错！&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);     &#125;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="keyword">if</span> ((client_fd = accept(sockfd, (struct sockaddr *)&amp;remote_addr, &amp;sin_size)) == <span class="number">-1</span>) </span><br><span class="line">       &#123;	perror(<span class="string">&quot;accept error&quot;</span>);		<span class="keyword">continue</span>;		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;收到一个连接来自： %s\n&quot;</span>, inet_ntoa(remote_addr.sin_addr));</span><br><span class="line">	<span class="keyword">if</span> (!fork()) </span><br><span class="line">        &#123; </span><br><span class="line">		<span class="keyword">if</span> (send(client_fd, <span class="string">&quot;连接上了 \n&quot;</span>, <span class="number">26</span>, <span class="number">0</span>) == <span class="number">-1</span>)			error(<span class="string">&quot;send 出错！&quot;</span>);	close(client_fd);	<span class="built_in">exit</span>(<span class="number">0</span>);		</span><br><span class="line">        &#125;</span><br><span class="line">	close(client_fd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端源程序代码 ：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> #<span class="meta-keyword">define</span> SERVPORT 3333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd, recvbytes;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Please enter the server&#x27;s hostname!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">if</span>((host=gethostbyname(argv[<span class="number">1</span>]))==<span class="literal">NULL</span>)</span><br><span class="line">           &#123;	herror(<span class="string">&quot;gethostbyname error！&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">           &#123;  perror(<span class="string">&quot;socket create error！&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_port=htons(SERVPORT);</span><br><span class="line">	serv_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr);</span><br><span class="line">	bzero(&amp;(serv_addr.sin_zero),<span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;connect error！&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">if</span> ((recvbytes=recv(sockfd, buf, MAXDATASIZE, <span class="number">0</span>)) ==<span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;connect 出错！&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	buf[recvbytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;收到: %s&quot;</span>,buf);</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="3-UDP编程"><a href="#3-UDP编程" class="headerlink" title="3 UDP编程"></a>3 UDP编程</h2><p>基于UDP协议的编程，其最主要的特点是不需要用函数bind把本地IP地址与端口号进行绑定，也能进行通信。</p>
<p>常用的基UDP网络编程函数及功能：</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619171733752.png" alt="image-20210619171733752"></p>
<h3 id="例4-2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。"><a href="#例4-2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。" class="headerlink" title="例4.2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。"></a>例4.2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619171749586.png" alt="image-20210619171749586"></p>
<p>主要语句说明：<br>服务端：<br>建立socket：socket(AF_INET,SOCK_DGRAM,0)<br>绑定bind：bind(sockfd,(struct sockaddr *)&amp;adr_inet,sizeof(adr_inet));<br>接收数据recvfrom：recvfrom(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;adr_clnt,&amp;len);<br>关闭close：close(sockfd);</p>
<p>客户端：<br>建立socket：socket(AF_INET, SOCK_STREAM, 0);<br>读取liu文件：fopen(“liu”,”r”);<br>发送数据sendto：sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;adr_srvr,sizeof(adr_srvr));<br>关闭close：close(sockfd);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端源程序代码：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port=<span class="number">8888</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> sockfd;	<span class="keyword">int</span> len;	<span class="keyword">int</span> z;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_inet</span>;</span>	</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_clnt</span>;</span> <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;等待客户端....\n&quot;</span>);</span><br><span class="line">	adr_inet.sin_family=AF_INET;</span><br><span class="line">	adr_inet.sin_port=htons(port);</span><br><span class="line">	adr_inet.sin_addr.s_addr =htonl(INADDR_ANY);</span><br><span class="line">	bzero(&amp;(adr_inet.sin_zero),<span class="number">8</span>);</span><br><span class="line">	len=<span class="keyword">sizeof</span>(adr_clnt);</span><br><span class="line">	sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;socket 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	   z=bind(sockfd,(struct sockaddr *)&amp;adr_inet,<span class="keyword">sizeof</span>(adr_inet));</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;bind 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	   z=recvfrom(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;adr_clnt,&amp;len);</span><br><span class="line">	  <span class="keyword">if</span>(z&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;	perror(<span class="string">&quot;recvfrom 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);		&#125;</span><br><span class="line">	  buf[z]=<span class="number">0</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">&quot;接收:%s&quot;</span>,buf);</span><br><span class="line">	  <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">&quot;stop&quot;</span>,<span class="number">4</span>)==<span class="number">0</span>)</span><br><span class="line">		&#123;	<span class="built_in">printf</span>(<span class="string">&quot;结束....\n&quot;</span>);	<span class="keyword">break</span>;	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端源程序代码 ：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> port=<span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;	<span class="keyword">int</span> i=<span class="number">0</span>;	<span class="keyword">int</span> z;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">80</span>],str1[<span class="number">80</span>];	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_srvr</span>;</span></span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开文件......\n&quot;</span>);</span><br><span class="line">	fp=fopen(<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;打开文件失败&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;连接服务端...\n&quot;</span>);</span><br><span class="line">	adr_srvr.sin_family=AF_INET;</span><br><span class="line">	adr_srvr.sin_port=htons(port);</span><br><span class="line">	adr_srvr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	bzero(&amp;(adr_srvr.sin_zero),<span class="number">8</span>);</span><br><span class="line">	sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;socket 出错&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;发送文件 ....\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;	fgets(str1,<span class="number">80</span>,fp);		<span class="built_in">printf</span>(<span class="string">&quot;%d:%s&quot;</span>,i,str1);</span><br><span class="line">		<span class="built_in">sprintf</span>(buf,<span class="string">&quot;%d:%s&quot;</span>,i,str1);</span><br><span class="line">		z=sendto(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;adr_srvr,	<span class="keyword">sizeof</span>(adr_srvr));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;发送.....\n&quot;</span>);	<span class="built_in">sprintf</span>(buf,<span class="string">&quot;stop\n&quot;</span>);</span><br><span class="line">	z=sendto(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;adr_srvr,</span><br><span class="line">	<span class="keyword">sizeof</span>(adr_srvr));</span><br><span class="line">	<span class="keyword">if</span>(z&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;sendto 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	fclose(fp);	close(sockfd);	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-网络高级编程"><a href="#4-网络高级编程" class="headerlink" title="4 网络高级编程"></a>4 网络高级编程</h2><p>I/O Models<br>Block mode 阻塞模式<br>Non-block mode 非阻塞模式<br>I/O multiplexing  I/O多路复用<br>多进程并发<br>多线程并发</p>
<h3 id="阻塞方式"><a href="#阻塞方式" class="headerlink" title="阻塞方式"></a><strong>阻塞方式</strong></h3><p>阻塞方式:在数据通信中，当服务器运行函数accept() 时，假设没有客户机连接请求到来，那么服务器就一直会停止在accept（）语句上，等待客户机连接请求到来，出现这样的情况就称为阻塞。</p>
<h3 id="非阻塞方式"><a href="#非阻塞方式" class="headerlink" title="非阻塞方式"></a><strong>非阻塞方式</strong></h3><p>阻塞与非阻塞方式的比较<br>errno - EWOULDBLOCK<br>非阻塞的实现<br>int flags;<br>if ( (flags=fcntl(sock_fd, F_GETFL, 0)) &lt; 0)<br>    err_sys();<br>flags |= O_NONBLOCK;<br>if ( fcntl(sock_fd, F_SETFL, flags) &lt; 0)<br>    err_sys();</p>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a><strong>I/O</strong> <strong>多路复用</strong></h3><p>基本思想：</p>
<p>先构造一张有关描述符的表，然后调用一个函数(如select)，该函数到这些描述符中的一个已准备好进行I/O时才返回，返回时告诉进程哪个描述符已准备好进行I/O.</p>
<h3 id="“select”"><a href="#“select”" class="headerlink" title="“select”"></a><strong>“select”</strong></h3><p>select: synchronous I/O multiplexing.</p>
<p>#include &lt;sys/select.h&gt;</p>
<p>int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>
<p>FD_ZERO(fd_set *set);</p>
<p>FD_SET(int fd, fd_set *set);</p>
<p>FD_CLR(int fd, fd_set *set);</p>
<p>FD_ISSET(int fd, fd_set *set);</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619172130327.png" alt="image-20210619172130327"></p>
<h3 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a><strong>多进程并发</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listenfd = socket(...);</span><br><span class="line">bind(...);</span><br><span class="line">listen(...);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       connectfd = accpet(...);</span><br><span class="line">       <span class="keyword">if</span>(fork() == <span class="number">0</span>)   &#123;  close(listenfd);</span><br><span class="line">           process(...);</span><br><span class="line">           close(...);</span><br><span class="line">           <span class="built_in">exit</span>();   &#125;</span><br><span class="line">         <span class="keyword">else</span>    &#123;   close(connectfd);    ...  <span class="keyword">continue</span>;&#125;   close(...);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="雨课堂题目整理-3"><a href="#雨课堂题目整理-3" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101124982.png" alt="image-20210611101124982"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101135283.png" alt="image-20210611101135283"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101144547.png" alt="image-20210611101144547"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101151866.png" alt="image-20210611101151866"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101159284.png" alt="image-20210611101159284"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101205637.png" alt="image-20210611101205637"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101212054-1623377532896.png" alt="image-20210611101212054"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101220777.png" alt="image-20210611101220777"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101228856.png" alt="image-20210611101228856"></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-19T01:23:18.000Z" itemprop="datePublished">2021-11-19</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unix/" rel="tag">Unix</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-Unix程序设计头歌知识点整理"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%B4%E6%AD%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">Unix程序设计头歌知识点整理</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="Linux编程基础"><a href="#Linux编程基础" class="headerlink" title="Linux编程基础"></a>Linux编程基础</h1><h2 id="vi-vim工作模式切换"><a href="#vi-vim工作模式切换" class="headerlink" title="vi/vim工作模式切换"></a>vi/vim工作模式切换</h2><p><code>vi/vim</code>编辑器有三种工作模式，每种工作模式都有不同的作用，以下是这三种工作模式的详细介绍:</p>
<ol>
<li>**命令模式: **查看当前文件内容，此时不能对文件内容进行写入操作，从该模式可以切换为插入模式和底线命令模式。</li>
<li>**插入模式: **可以对文件内容进行编辑操作，从该模式可以切换为命令模式。</li>
<li>**底线命令模式: **不可以对文件内容进行编辑，在此模式下可以执行一些<code>vi/vim</code>的命令，例如: 退出命令、保存内容命令等等。从该模式可以切换为命令模式。</li>
</ol>
<p><img src="https://data.educoder.net/api/attachments/188050" alt="img"></p>
<p><strong>注意: 启动<code>vi/vim</code>后，首先进入的是命令模式。</strong></p>
<h5 id="命令模式与插入模式相互切换"><a href="#命令模式与插入模式相互切换" class="headerlink" title="命令模式与插入模式相互切换"></a>命令模式与插入模式相互切换</h5><p>首先启动<code>vi/vim</code>编辑器后，首先进入的工作模式是命令模式，在当前模式下，我们只能查看文件内容，不能对文件内容进行写入操作。如果想对文件进行写入操作，那么我们只有进入插入模式下。</p>
<ol>
<li><strong>命令模式－&gt;插入模式方法</strong> 从命令模式到插入模式的切换方法有多种，我们介绍如下３中常用方法:</li>
</ol>
<table>
<thead>
<tr>
<th>输入命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i, I</td>
<td>i 为『从目前光标所在处输入』，I 为『在目前所在行的第一个非空格符处开始输入』。</td>
</tr>
<tr>
<td>a, A</td>
<td>a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。</td>
</tr>
<tr>
<td>o, O</td>
<td>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行。</td>
</tr>
</tbody></table>
<ol>
<li><strong>插入模式－&gt;命令模式方法</strong> 由插入模式切换到命令模式比较简单，我们只需要点击<code>ESC</code>键即可返回到命令模式。</li>
</ol>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>testFile</code>，并且将工作模式切换到插入模式，输入<code>Hello vi/vim</code>字符串，最后保存文件并退出，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi testFile` 或 `vim testFile</span><br></pre></td></tr></table></figure>

<p>打卡<code>testFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/186930" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/186931" alt="img"></p>
<p>按下字母<code>i</code>后进入插入模式； <img src="https://data.educoder.net/api/attachments/188053" alt="img"></p>
<p>输入<code>Hello vi/vim</code>字符后，按下<code>ESC</code>键后返回命令模式，最后输入<code>:wq</code>保存退出文件； <img src="https://data.educoder.net/api/attachments/188054" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="命令模式与底线命令模式相互切换"><a href="#命令模式与底线命令模式相互切换" class="headerlink" title="命令模式与底线命令模式相互切换"></a>命令模式与底线命令模式相互切换</h5><p><code>vi/vim</code>底线命令模式下如何执行写复杂的命令，例如我们常用的保存退出命令(<code>wq</code>)等。</p>
<ol>
<li><strong>命令模式－&gt;底线命令模式方法</strong> 从命令模式到底线命令模式的切换比较简单，我们只需要输入<code>:</code>字符即可，<strong>注意<code>:</code>是英文输入法下的冒号。</strong></li>
<li><strong>底线命令模式－&gt;命令模式方法</strong> 由底线命令模式切换到命令模式比较简单，我们只需要点击<code>ESC</code>键即可返回到命令模式。</li>
</ol>
<h2 id="vi-vim命令模式"><a href="#vi-vim命令模式" class="headerlink" title="vi/vim命令模式"></a>vi/vim命令模式</h2><p>在<code>vi/vim</code>命令模式下，我们可以对文件进行删除、复制和粘贴操作。</p>
<h5 id="命令模式移动光标操作"><a href="#命令模式移动光标操作" class="headerlink" title="命令模式移动光标操作"></a>命令模式移动光标操作</h5><p><code>vi/vim</code>编辑器与其它编辑器最大的不同之处是不能使用鼠标进行操作(可以在配置文件中设置鼠标属性，默认是禁止使用鼠标)，我们可以在命令模式下移动光标位置，常见移动命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td>k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td>l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，移动当前光标到第一行的第二字符处，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188089" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188090" alt="img"></p>
<p>移动光标到第一行的第５个字符处(按5次→)； <img src="https://data.educoder.net/api/attachments/188091" alt="img"></p>
<p>最后输入<code>:q</code>退出文件； <img src="https://data.educoder.net/api/attachments/188092" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="命令模式删除操作"><a href="#命令模式删除操作" class="headerlink" title="命令模式删除操作"></a>命令模式删除操作</h5><p>我们不光可以在插入模式下可以对文件内容进行删除操作，我们可以直接在命令模式下对文件进行删除操作，常见删除命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)</td>
</tr>
<tr>
<td>nx</td>
<td>n 为数字，连续向后删除 n 个字符。例如，我要连续删除 5 个字符 ，则可以使用<code>5x</code></td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在的那一整行</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如<code>10dd</code>则是删除 10 行</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，删除当前文件的第二行所有内容，最后保存文件并退出，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188093" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188094" alt="img"></p>
<p>移动光标到文件第二行； <img src="https://data.educoder.net/api/attachments/188095" alt="img"></p>
<p>输入<code>dd</code>字符后删除当前行内容，最后输入<code>:wq</code>保存退出文件； <img src="https://data.educoder.net/api/attachments/188096" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="命令模式复制粘贴操作"><a href="#命令模式复制粘贴操作" class="headerlink" title="命令模式复制粘贴操作"></a>命令模式复制粘贴操作</h5><p>常见复制命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标所在的那一行</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 <code>10yy</code> 则是复制 10 行</td>
</tr>
<tr>
<td>y1G</td>
<td>复制光标所在行到第一行的所有数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制光标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
</tbody></table>
<p>常见粘贴命令为<code>p, P</code>，<code>p</code> 为将已复制的数据在光标下一行贴上，<code>P</code> 则为贴在游标上一行！</p>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，将第一行内容复制，然后粘贴到文件的末尾，最后保存文件并退出，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188093" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188097" alt="img"></p>
<p>复制第一行内容(<code>yy</code>)，移动光标到最后一行，粘贴(<code>p</code>)内容到当前行的下一行，最后输入<code>:wq</code>保存退出文件； <img src="https://data.educoder.net/api/attachments/188098" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h2 id="vi-vim底线命令模式"><a href="#vi-vim底线命令模式" class="headerlink" title="vi/vim底线命令模式"></a>vi/vim底线命令模式</h2><h5 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h5><p><code>vi/vim</code>编辑器在底线命令模式下可以对文件内容进行查找和替换操作，常见查找和替换命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可。</td>
</tr>
<tr>
<td>?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td>n</td>
<td>这个 n 是英文字母。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。</td>
</tr>
<tr>
<td>N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td>[:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 。</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2。</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代。</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，将所有<code>line</code>单词替换为<code>words</code>单词，并保存退出，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188089" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188090" alt="img"></p>
<p>首先输入<code>:</code>切换当前模式为底线命令模式，然后输入<code>1,$s/line/words/g</code>后回车； <img src="https://data.educoder.net/api/attachments/188108" alt="img"></p>
<p><img src="https://data.educoder.net/api/attachments/188109" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="底线命令模式下执行特殊命令"><a href="#底线命令模式下执行特殊命令" class="headerlink" title="底线命令模式下执行特殊命令"></a>底线命令模式下执行特殊命令</h5><p>常见在底线命令模式执行的命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td>:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td>:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td>:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，显示当前文件行号，将当前文件的第1-3行内容另存为<code>oldFileCpy</code>文件，使用<code>cat</code>命令查看新生成文件内容，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188093" alt="img"></p>
<p>输入<code>:set nu</code>后回车，显示行号； <img src="https://data.educoder.net/api/attachments/188110" alt="img"></p>
<p><img src="https://data.educoder.net/api/attachments/188111" alt="img"></p>
<p>输入<code>:1,3 w oldFileCpy</code>后回车 <img src="https://data.educoder.net/api/attachments/188112" alt="img"></p>
<p>最后在<code>vi</code>中使用<code>cat</code>命令查看新生成的文件<code>oldFileCpy</code>内容； <img src="https://data.educoder.net/api/attachments/188113" alt="img"></p>
<p><img src="https://data.educoder.net/api/attachments/188114" alt="img"></p>
<p>按下回车键后返回当前<code>vi</code>编辑器，最后输入<code>q</code>退出文件； <img src="https://data.educoder.net/api/attachments/188115" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h2 id="Linux之静态库编写"><a href="#Linux之静态库编写" class="headerlink" title="Linux之静态库编写"></a>Linux之静态库编写</h2><p>在实际的软件开发时， 应该遵守一个基本原则：不要重复造轮子。如果某些代码经常要用到，不仅这个项目能使用，而且也能复用到其它项目上，那么就应该把这部分代码从项目中分离出来，将其编译为库文件，供需要的程序调用。</p>
<p>程序库分为两类，分别是<strong>静态库</strong>和<strong>动态库</strong>。本关将主要讲解如何生成<strong>静态库</strong>。</p>
<p><code>Windows</code>系统上的<strong>静态库</strong>是以<code>.lib</code>为后缀，而<code>Linux</code>系统上的<strong>静态库</strong>是以<code>.a</code>为后缀的特殊的存档。</p>
<p><code>Linux</code>系统的标准系统库可在目录<code>/usr/lib</code>与<code>/lib</code>中找到。比如，在类<code>Unix</code>系统中<code>C</code>语言的数序库一般存储为文件<code>/usr/lib/libm.a</code>。该库中函数的原型声明在头文件<code>/usr/include/math.h</code>中。</p>
<h5 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h5><p>在<code>Linux</code>下，我们可以使用<code>gcc</code>和<code>ar</code>工具制作和使用自己的静态库，具体过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将源码文件编译成.o目标文件；</span><br><span class="line">使用ar工具将多个目标文件打包成.a的静态库文件；</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><code>Linux</code>系统上默认的静态库名格式为：<code>libxxx.a</code>，其中<code>xxx</code>为生成库的名称。</p>
<p>案例演示1：</p>
<p>编写一个函数<code>printHello</code>，其功能为打印“Hello world”字符串，将其编译生成名为<code>Hello</code>的静态库，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim printHello.h</span><br><span class="line">vim printHello.c</span><br><span class="line">gcc -c printHello.c -o printHello.o</span><br><span class="line">ar rcs libHello.a printHello.o</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.h</code>(声明<code>printHello</code>函数，方便以后被其它程序调用)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __PRINTHELLO_H__</span><br><span class="line">#define __PRINTHELLO_H__</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void printHello();</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212803" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h5><p><strong>静态库</strong>的使用方法只需要在编译程序的时候指明要链接的库名称即可，<code>gcc</code>中有两个参数是关于链接库时所使用的，**分别是：<code>-L</code>和<code>-l</code>**。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-L：用于告诉gcc要链接的库所在目录；</span><br><span class="line">-l：用于指明链接的库名称(小写l)；</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>调用以上案例生成的<code>printHello</code>函数，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br><span class="line">gcc main.c -o exe -L ./ -lHello(可以换成Hello.o)</span><br><span class="line">./exe</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>main.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;printHello.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	printHello();    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212810" alt="img"> </p>
<p>[请在右侧“命令行”里直接体验]</p>
<h2 id="Linux之动态库编写"><a href="#Linux之动态库编写" class="headerlink" title="Linux之动态库编写"></a>Linux之动态库编写</h2><ul>
<li><strong>静态库</strong>与<strong>动态库</strong>的区别：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>静态库</th>
<th>动态库</th>
</tr>
</thead>
<tbody><tr>
<td>名称</td>
<td>命名方式是”libxxx.a”,库名前加”lib”，后缀用”.a”，”xxx”为静态库名</td>
<td>命名方式是”libxxx.so”, 库名前加”lib”，<strong>后缀用”.so”， “xxx”为动态库名</strong></td>
</tr>
<tr>
<td>链接时间</td>
<td>静态库的代码是在<strong>编译过程中被载入程序中</strong></td>
<td>动态库在编译的时候并没有被编译进目标代码，而是<strong>当你的程序执行到相关函数时才调用该函数库里的相应函数</strong></td>
</tr>
<tr>
<td>优点</td>
<td><strong>在编译后的执行程序不在需要外部的函数库支持</strong>，因为所使用的函数都已经被编进去了。</td>
<td><strong>动态库的改变</strong>并<strong>不影响你的程序</strong>，所以动态函数库升级比较方便</td>
</tr>
<tr>
<td>缺点</td>
<td>如果所使用的<strong>静态库发生更新改变，你的程序必须重新编译</strong></td>
<td>因为函数库并没有整合进程序，所以<strong>程序的运行环境必须提供相应的库</strong></td>
</tr>
</tbody></table>
<p><code>Windows</code>系统上的<strong>动态库</strong>是以<code>.dll</code>为后缀，而<code>Linux</code>系统上的<strong>动态库</strong>是以<code>.so</code>为后缀的特殊的存档。</p>
<h5 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h5><p>在<code>Linux</code>下，我们可以使用<code>gcc</code>制作和使用动态库，具体制作过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用gcc命令加-fPIC参数将源码文件编译成.o目标文件；使用gcc命令加-shared参数将多个目录文件生成一个动态库文件；</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><code>Linux</code>系统上默认的动态库名格式为：<code>libxxx.so</code>，其中<code>xxx</code>为生成库的名称。</p>
<p>案例演示1：</p>
<p>编写一个函数<code>printHello</code>，其功能为打印”Hello world”字符串，将其编译生成名为<code>Hello</code>的动态库，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim printHello.h</span><br><span class="line">vim printHello.c</span><br><span class="line">gcc -fPIC -c printHello.c -o printHello.o</span><br><span class="line">gcc -shared  printHello.o -o libHello.so</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.h</code>(申明<code>printHello</code>函数，方便以后被其它程序调用)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PRINTHELLO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PRINTHELLO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212811" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h5><p><strong>动态库</strong>的使用方法与<strong>静态库</strong>使用方式略有不同，除了使用<code>gcc</code>中的<code>-L</code>和<code>-l</code>参数外，想要调用动态库还需要更新<code>Linux</code>系统中<code>/etc/ld.so.cache</code>或者修改<code>LD_LIBRARY_PATH</code>环境变量，否则在运行程序的时候会报<strong>”No such file or directory”</strong>错误。</p>
<p>案例演示1：</p>
<p>调用以上案例生成的<code>printHello</code>函数，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br><span class="line">gcc main.c -o exe -L ./ -lHello</span><br><span class="line">./exe</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212806" alt="img"> [使用<code>vim</code>编写程序]</p>
<p><img src="https://data.educoder.net/api/attachments/212812" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>此时编译正常，当运行的时候会报<strong>”No such file or directory”</strong>错误。</p>
<h5 id="更新-etc-ld-so-cache来运行动态库"><a href="#更新-etc-ld-so-cache来运行动态库" class="headerlink" title="更新/etc/ld.so.cache来运行动态库"></a>更新/etc/ld.so.cache来运行动态库</h5><ul>
<li>编辑<code>/etc/ld.so.conf</code>配置文件，然后加入需要加载的动态库目录。</li>
<li>运行<code>ldconfig</code>更新<code>/etc/ld.so.cache</code></li>
</ul>
<p>案例演示1：</p>
<p>更新<code>/etc/ld.so.cache</code>，然后运行上一个案例生成的<code>exe</code>，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line">sudo ldconfig</span><br><span class="line">./exe</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212813" alt="img"> [使用<code>vim</code>向<code>/etc/ld.so.conf</code>文件添加<code>/home/fzm</code>路径]</p>
<p><img src="https://data.educoder.net/api/attachments/212814" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="修改LD-LIBRARY-PATH环境变量"><a href="#修改LD-LIBRARY-PATH环境变量" class="headerlink" title="修改LD_LIBRARY_PATH环境变量"></a>修改<code>LD_LIBRARY_PATH</code>环境变量</h5><p>在运行可执行文件前修改<code>LD_LIBRARY_PATH</code>变量为可执行程序指定需要加载的动态库路径。</p>
<p>案例演示1：</p>
<p>修改<code>LD_LIBRARY_PATH</code>，然后运行上一个案例生成的<code>exe</code>，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=.  ./exe</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212815" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p><strong>注意</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH告诉了exe程序现在当前目录下寻找链接的动态库；</span><br><span class="line">当运行环境中同时存在同名的静态库和动态库时，默认优先链接动态库；</span><br></pre></td></tr></table></figure>

<h2 id="Makefile初体验"><a href="#Makefile初体验" class="headerlink" title="Makefile初体验"></a>Makefile初体验</h2><p>什么是<code>makefile</code>？或许很多<code>Winodws</code>的程序员都不知道这个东西，因为那些<code>Windows</code>的<code>IDE</code>都为你做了这个工作，但是要作一个专业的程序员，<code>makefile</code>还是要懂的。<code>makefile</code>其实就是描述了整个工程中所有文件的<strong>编译顺序，编译规则</strong>，并且由<code>make</code>命令来读取<code>makefile</code>文件，然后根据<code>makefile</code>文件中定义的规则对其进行解析，完成对整个项目的编译操作。</p>
<p><code>makefile</code>在<code>linux</code>操作系统中是比较常见的，例如，我们在使用源码安装一个软件的时候，通常只需执行<code>make</code>命令即可完成对软件的编译，正是因为软件开发者已经编写了<code>makefile</code>文件，所以只需执行<code>make</code>命令就会完成对整个工程的自动编译。</p>
<p>本关将介绍<code>makefile</code>的语法，使用<code>makefile</code>来完成对软件的编译。</p>
<h5 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h5><p><code>makefile</code>文件中包含了一组用来编译应用程序的规则，一项规则可分成三个部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作目标(target)</span><br><span class="line">依赖条件(prerequisite)</span><br><span class="line">所要执行的命令(command)</span><br></pre></td></tr></table></figure>

<p>格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target : prereq1 prereq2</span><br><span class="line">	commands</span><br></pre></td></tr></table></figure>

<p>以上格式就是一个文件的依赖关系，也就是说，<code>target</code>这个目标文件依赖于多个<code>prerequisites</code>文件，其生成规则定义在<code>commands</code>中。说白一点就是说，<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>commands</code>所定义的命令就会被执行。这就是<code>Makefile</code>的规则。也就是<code>Makefile</code>中最核心的内容。</p>
<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands前面使用的是TAB键，而不是空格，使用空格会出现错误；</span><br><span class="line">commands可以是任意的shell命令；</span><br><span class="line">在执行make命令时，make会解析第一项规则；</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>存在一个源码文件<code>main.c</code>文件，编译一个<code>makefile</code>规则来编译该文件，并生成一个名为<code>HelloWorld</code>的可执行文件，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写如下代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld : main.c    </span><br><span class="line">	gcc -o HelloWorld main.c</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212979" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>通过以上案例可以看到，编写好<code>makefile</code>后，只需要输入<code>make</code>命令即自动只需定义好的规则。</p>
<p><strong>注意：</strong><code>gcc -o HelloWorld main.c</code>命令前是<code>TAB</code>键而不是空格。</p>
<p>案例演示2：</p>
<p>假设一个项目中包含<code>5</code>个源码文件，分别是<code>Add.c</code>、<code>Sub.c</code>、<code>Mul.c</code>、<code>Div.c</code>和<code>main.c</code>和一个头文件<code>def.h</code>，编译一个<code>makefile</code>规则来编译该项目，并生成一个名为<code>exe</code>的可执行文件，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Add.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Sub.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Mul.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Div.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a /  b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim main.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;def.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> add = Add(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">int</span> sub = Sub(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">int</span> mul = Mul(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">int</span> div = Div(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 + 5 = %d\n&quot;</span>, add);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 - 5 = %d\n&quot;</span>, sub);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 * 5 = %d\n&quot;</span>, mul);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 / 5 = %d\n&quot;</span>, div);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim def.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DEF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exe : main.o Add.o Sub.o Mul.o Div.o    </span><br><span class="line">	gcc -o exe main.o Add.o Sub.o Mul.o Div.o (若要重命名生成的文件，两个exe都要改名)</span><br><span class="line">main.o : main.c def.h    </span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line">Add.o : Add.c    </span><br><span class="line">	gcc -c Add.c -o Add.o</span><br><span class="line">Sub.o : Sub.c    </span><br><span class="line">	gcc -c Sub.c -o Sub.o</span><br><span class="line">Mul.o : Mul.c    </span><br><span class="line">	gcc -c Mul.c -o Mul.o</span><br><span class="line">Div.o : Div.c    </span><br><span class="line">	gcc -c Div.c -o Div.o</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212996" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>以上案例，当只需<code>make</code>命令时，首先解析目标为<code>exe</code>的规则，然后发现<code>exe</code>依赖于<code>main.o、Add.o和Sub.o</code>，然后分别对<code>main.o、Add.o和Sub.o</code>规则进行解析，即分别执行目标为<code>main.o、Add.o和Sub.o</code>的命令。当<code>main.o、Add.o和Sub.o</code>生成后，最后执行<code>exe</code>对应的命令。</p>
<h2 id="Makefile之变量使用"><a href="#Makefile之变量使用" class="headerlink" title="Makefile之变量使用"></a>Makefile之变量使用</h2><p><code>makefile</code> 变量的命令可以包含字符、数字、下划线（可以是数字开头），并且大小写敏感。</p>
<p><code>makefile</code>变量在声明时需要对其进行赋值，而在使用该变量时需要在变量名前加上**<code>$</code><strong>符号 例如<code>$(VARNAME)</code>，如果用户需要在<code>makefile</code>文件中使用真实的</strong><code>$</code><strong>字符，则使用</strong><code>$$</code>**表示。</p>
<p><code>makefile</code>中对变量的赋值方式有三种，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归赋值(=)：递归赋值，即赋值后并不马上生效，等到使用时才真正的赋值，此时通递归找出当前的值；直接赋值(:=)：是将&quot;:=&quot;右边中包含的变量直接展开给左边的变量赋值；条件赋值(?=)：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值，所有一般用在第一次赋值；</span><br></pre></td></tr></table></figure>

<p><code>makefile</code>除了可以自定义变量外，还存在一些系统默认的特殊变量，这些特殊变量可以方便帮助我们快速的编写<code>makefile</code>文件，例如：<code>$@、$&lt;和$^</code>等等。</p>
<p>本关将介绍<code>makefile</code>的变量的定义和使用方法，以及使用特殊变量来编写<code>makefile</code>文件。</p>
<h5 id="Makefile-自定义变量"><a href="#Makefile-自定义变量" class="headerlink" title="Makefile 自定义变量"></a>Makefile 自定义变量</h5><p>自定义变量格式：</p>
<ul>
<li>递归赋值 <code>变量名 = 变量内容</code></li>
<li>直接赋值 <code>变量名 := 变量内容</code></li>
<li>条件赋值 <code>变量名 ?= 变量内容</code></li>
</ul>
<p>变量的使用格式为： <code>$变量名</code>或者<code>$&#123;变量名&#125;</code>或者<code>$(变量名)</code></p>
<p>案例演示1：</p>
<p>在上一关中案例<code>2</code>中的项包含了<code>5</code>个源码文件和一个头文件，如果使用变量来编写<code>makefile</code>则会显示出比较简洁的格式，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim makefilemake</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o exe <span class="variable">$(object)</span></span><br><span class="line"></span><br><span class="line">main.o : main.c def.h    </span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line">	</span><br><span class="line">Add.o : Add.c    </span><br><span class="line">	gcc -c Add.c -o Add.o</span><br><span class="line">	</span><br><span class="line">Sub.o : Sub.c    </span><br><span class="line">	gcc -c Sub.c -o Sub.o</span><br><span class="line">	</span><br><span class="line">Mul.o : Mul.c    </span><br><span class="line">	gcc -c Mul.c -o Mul.o</span><br><span class="line">	</span><br><span class="line">Div.o : Div.c    </span><br><span class="line">	gcc -c Div.c -o Div.o</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213114" alt="img"> [<code>makefile</code>内容]</p>
<p><img src="https://data.educoder.net/api/attachments/213116" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>可以看到，我们使用<code>object</code>来表示<code>main.o Add.o Sub.o Mul.o Div.o</code>，这样我们就可以使用<code>$(object)</code>来表示以上目标文件，而不是每次输入这<code>5</code>个目标文件。</p>
<h5 id="Makefile-特殊变量"><a href="#Makefile-特殊变量" class="headerlink" title="Makefile 特殊变量"></a>Makefile 特殊变量</h5><p> <code>makefile</code>常用的特殊变量有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$@：表示所有目标；</span><br><span class="line">$^：表示所有依赖目标的集合，以空格分隔；</span><br><span class="line">$&lt;：表示依赖目标中第一个目标的名子；</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>接着上一个案例中的项目，如果使用特殊变量来编写<code>makefile</code>则会显示出更加简洁的格式，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span>main.o : </span><br><span class="line"></span><br><span class="line">main.c def.h    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">Add.o : Add.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">Sub.o : Sub.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">Mul.o : Mul.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">Div.o : Div.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213121" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h2 id="Makefile自动推导"><a href="#Makefile自动推导" class="headerlink" title="Makefile自动推导"></a>Makefile自动推导</h2><p><code>make</code>很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个<code>.o</code>文件后都写上类似的命令。因为，我们的<code>make</code>会自动识别，并自己推导命令。</p>
<p>只要<code>make</code>看到一个<code>.o</code>文件，它就会自动的把<code>.c</code>文件加在依赖关系中，如果<code>make</code>找到一个<code>main.o</code>，那么<code>main.c</code>就会是<code>main.o</code>的依赖文件。并且 <code>gcc -c main.c</code> 也会被推导出来，于是，我们的<code>makefile</code>再也不用写得这么复杂。</p>
<p>本关将介绍<code>makefile</code>的自动推导功能。</p>
<h5 id="Makefile-自动推导"><a href="#Makefile-自动推导" class="headerlink" title="Makefile 自动推导"></a>Makefile 自动推导</h5><p>自动推导格式： <code>目标 : 其它依赖</code></p>
<p>案例演示1：</p>
<p>如果使用自动推导模式来编写上一关卡案例中的<code>makefile</code>，则会有更简洁的格式，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span></span><br><span class="line"></span><br><span class="line">main.o : def.h</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213116" alt="img"> </p>
<p>[请在右侧“命令行”里直接体验]</p>
<p>可以看到，我们只需要为<code>main.o</code>创建一个编译规则，其<code>4</code>个目标文件则不需要为其创建编译规则，因为<code>make</code>会自动的为其构造出编译规则。</p>
<h2 id="Makefile伪目标"><a href="#Makefile伪目标" class="headerlink" title="Makefile伪目标"></a>Makefile伪目标</h2><p>每个<code>Makefile</code>中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。</p>
<p>通常，我们在使用源码安装软件的时候，都会在编译完软件后，执行<code>make install</code>这个命令来安装软件，或者执行<code>make clean</code>这个命令清空临时生成的目标文件。以上操作就是利用了<code>makefile</code>的伪目标。</p>
<p>本关将介绍<code>makefile</code>的伪目标。</p>
<h5 id="Makefile-伪目标"><a href="#Makefile-伪目标" class="headerlink" title="Makefile 伪目标"></a>Makefile 伪目标</h5><p>makefile<code>使用</code>.PHONY`关键字来定义一个伪目标，具体格式为： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : 伪目标名称</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>为上一关卡案例中的<code>makefile</code>添加清空临时目标文件标签<code>clean</code>，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>  </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span></span><br><span class="line"></span><br><span class="line">main.o : def.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean :    </span><br><span class="line">	rm <span class="variable">$(object)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213181" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>可以看到，当我们执行完<code>make</code>命令后会生成多个临时文件，然后我们执行<code>make clean</code>命令后，则会将生成的临时文件删除掉，其实执行<code>make clean</code>命令就是在执行<code>rm main.o Add.o Sub.o Mul.o Div.o</code>。</p>
<p>案例演示2：</p>
<p>使用另一个格式来清除临时产生的目录文件和不显示删除命令，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span></span><br><span class="line">	</span><br><span class="line">main.o : def.h</span><br><span class="line"></span><br><span class="line">clean :    </span><br><span class="line">	@echo <span class="string">&quot;clean object files&quot;</span>    </span><br><span class="line">	@rm <span class="variable">$(object)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213186" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>可以看到，当我们执行<code>make clean</code>命令后，将不会在终端中显示<code>rm main.o Add.o Sub.o Mul.o Div.o</code>命令。</p>
<p><strong>注意：</strong>在命令前加了**<code>@</code>**符号，则不会把命令原样输出在终端。</p>
<h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><h2 id="文件权限修改"><a href="#文件权限修改" class="headerlink" title="文件权限修改"></a>文件权限修改</h2><p>在当前目录中新建文件<code>test.txt</code></p>
<p>touch test.txt</p>
<p>增加拥有者<code>(u)</code>对该文件的执行权限。</p>
<p>chmod 777 test.txt</p>
<p>增加群组用户<code>(g)</code>对该文件的写权限。</p>
<p>chmod ug+w test.txt</p>
<p>取消其他用户<code>(o)</code>对该文件的读权限。</p>
<p>chmod o-r test.txt</p>
<h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><h3 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h3><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>文件的创建操作是 <code>I/O </code>操作的第一步。在Linux系统中<code>creat</code>系统调用可以实现对文件的创建。本关只介绍文件创建函数的使用方法。</p>
<p>在Linux系统中可以使用<code>man</code>命令来查询这些函数的使用方法。具体的查询命令为： <code>man 2 函数名</code> 其中，<code>2</code>表示查找系统调用函数，关于文件的创建、打开和关闭函数都是系统调用函数，因此使用<code>2</code>作为<code>man</code>命令的第一个参数。</p>
<p>案例演示1: 查询<code>creat</code>函数的使用方法可以使用以下命令： <code>man 2 creat</code></p>
<p><img src="https://data.educoder.net/api/attachments/279654" alt="img"> [查询结果]</p>
<p>通过<code>man</code>命令可以查询常用的系统调用函数的使用方法。</p>
<h5 id="文件的创建-1"><a href="#文件的创建-1" class="headerlink" title="文件的创建"></a>文件的创建</h5><p>创建文件的系统调用函数是<code>creat</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int creat (const char *pathname,mode_t mode);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要创建文件的绝对路径名或相对路径名；mode：用于指定所创建文件的权限；</span><br></pre></td></tr></table></figure>

<p>常见的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode</span><br></pre></td></tr></table></figure>

<p>取值及其含义见下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>mode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRUSR</td>
<td>文件所有者的读权限位</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>文件所有者的写权限位</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>文件所有者的执行权限位</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>所有者同组用户的读权限位</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>所有者同组用户的写权限位</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>所有者同组用户的执行权限位</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他用户的读权限位</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他用户的写权限位</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他用户的执行权限位</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功时，返回值为 文件的描述符(大于0的整数)；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>creat</code>函数创建一个名为<code>firstFile</code>的文件，并设置文件的权限为<code>644</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = creat(<span class="string">&quot;firstFile&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288183" alt="img"> 将以上代码保存为<code>main.c</code>文件中，编译执行。可以看到当前目录下存在<code>firstFile</code>文件，并且其权限为<code>644</code>。</p>
<h4 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在当前目录下创建一个名为<code>testFile</code>的文件，并设置其权限为<code>651</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> ret = creat(<span class="string">&quot;testFile&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IXGRP | S_IXOTH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件打开与关闭"><a href="#文件打开与关闭" class="headerlink" title="文件打开与关闭"></a>文件打开与关闭</h3><h4 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h4><p>文件的打开与关闭操作是 <code>I/O </code>操作的第二步。在Linux系统中提供了以下两个系统调用函数用于打开和关闭文件操作，分别是<code>open</code>和<code>close</code>。本关将介绍文件的打开和关闭函数的使用方法。</p>
<p>使用<code>man 2 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h5><p>打开文件的系统调用函数是<code>open</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(coust char *pathname, int flags);int open(const char *pathname, int flags, made_t mode);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要被打开或创建的文件绝对路径名或相对路径名；flags：用于描述文件的打开方式；mode：用于指定所创建文件的权限(与上一关中creat函数中mode取值一致)；</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第一个<code>open</code>函数用于打开已经存在的文件。而第二个<code>open</code>函数可以创建一个不存在的文件且打开，该函数将<code>flags</code>参数设置为<code>O_CREAT | O_WRONLY | O_TRUNC</code>时等同于上一关中的<code>creat</code>函数。</p>
<p>常见的<code>flags</code>取值及其含义见下表所示：</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY 以只读方式打开文件</td>
<td></td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写方式打开文件</td>
</tr>
<tr>
<td>O_RDWY</td>
<td>以只读写方式打开文件</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>若所打开文件不存在则创建此文件</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>若以只写或读写方式打开一个已存在文件时,将该文件截至 0</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>向文件添加内容时将指针置于文件的末尾</td>
</tr>
<tr>
<td>O_SYNC</td>
<td>只在数据被写外存或其他设备之后操作才返回</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功时，返回值为 文件的描述符(大于0的整数)；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>open</code>函数以只读方式打开一个已存在且名为<code>firstFile</code>的文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = open(<span class="string">&quot;firstFile&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279659" alt="img"> 将以上代码保存为<code>openFile.c</code>文件中，编译执行。</p>
<p>案例演示2: 在当前目录下使用<code>open</code>函数创建一个名为<code>secondFile</code>的文件，并设置文件的权限为<code>644</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = open(<span class="string">&quot;secondFile&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279660" alt="img"> 将以上代码保存为<code>secondFile.c</code>文件中，编译执行。可以看到当前目录下存在<code>secondFile</code>文件，并且其权限为<code>644</code>。</p>
<h5 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h5><p>关闭文件的系统调用函数是<code>close</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int close(int fd);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：需关闭文件的描述符；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为 0；调用失败时，返回值为-1，并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>close</code>函数关闭一个已经被打开的文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;firstFile&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = close(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279663" alt="img"> 将以上代码保存为<code>closeFile.c</code>文件中，编译执行。</p>
<h4 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>open_File</code>函数，使其以<strong>读</strong>方式打开一个文件，并返回文件描述符<code>fd</code>。</li>
<li>补全<code>close_File</code>函数，使其关闭一个已经被打开的文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fileName: 需要被打开的文件路径</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_File</span><span class="params">(<span class="keyword">char</span> *fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">0</span>;   <span class="comment">//存放文件描述符</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	fd = open(fileName, O_RDONLY);</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fd: 需要被关闭的文件描述符</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_File</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	fd = close(fd);</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><h4 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h4><p>文件的读写是 <code>I/O</code> 操作的核心内容。上一关中已经介绍了如何打开和关闭一个文件，但是要实现文件的 <code>I/O</code> 操作就必须对其进行读写，文件的读写操作所用的系统调用分别是<code>read</code>和<code>write</code>。本关将介绍文件的读写函数的使用方法。</p>
<p>使用<code>man 2 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="文件的写操作"><a href="#文件的写操作" class="headerlink" title="文件的写操作"></a>文件的写操作</h5><p>写入文件的系统调用函数是<code>write</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>ssize_t write(int fd, void *buf, size_t count);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：表示将对之进行写操作的文件打开时返回的文件描述符；buf：指向存放将写入文件的数据的缓冲区的指针；count：表示本次操作所要写入文件的数据的字节数；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为所写入的字节数；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下往<code>firstFile</code>文件中写入一个字符串。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;firstFile&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *data = <span class="string">&quot;this is firstFile\n&quot;</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入文件成功：写入%ld个字符\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279677" alt="img"> 将以上代码保存为<code>writeFile.c</code>文件中，编译执行。可以看到字符串被写入到<code>firstFile</code>文件中。</p>
<h5 id="文件的读操作"><a href="#文件的读操作" class="headerlink" title="文件的读操作"></a>文件的读操作</h5><p>读取文件的系统调用函数是<code>read</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>ssize_t read(int fd, void *buf, size_t count);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：表示将对之进行写操作的文件打开时返回的文件描述符；buf：指向存放所读数据的缓冲区的指针；count：读操作希望读取的字节数；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为本次读操作实际读取的字节数；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 读取当前目录下<code>firstFile</code>文件中的前4个字符。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;firstFile&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">5</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = read(fd, data, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取文件成功：数据：%s\n&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279678" alt="img"> 将以上代码保存为<code>readFile.c</code>文件中，编译执行。可以看到从<code>firstFile</code>文件中读取出了前4个字符。</p>
<h4 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>write_File</code>函数，完成向文件写入字符串功能。并返回实际写入字符个数。</li>
<li>补全<code>readLine</code>函数，完成从文件中读取一行的功能(不包括换行符)，并返回实际读取的字符个数(<strong>文件的换行符号为\n</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fd: 被打开文件的描述符</span></span><br><span class="line"><span class="comment"> * buf: 被写入字符串指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_File</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> writeSize = <span class="number">0</span>; <span class="comment">//返回实际写入的字符个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	writeSize = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> writeSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fd: 被打开文件的描述符</span></span><br><span class="line"><span class="comment"> * buf: 存放读取的字符串指针(假设buf足够大)</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readLine</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> readSize = <span class="number">0</span>;  <span class="comment">//返回实际读取的字符个数</span></span><br><span class="line">	<span class="keyword">char</span> tempC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提示：使用while循环每次只读取一个字符，判断该字符是否为换行符或者是否已经读取到文件末尾(读取到文件末尾返回值为0)</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">1</span>,length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = read(fd, &amp;tempC, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">0</span>|tempC==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            readSize = readSize+<span class="number">1</span>;</span><br><span class="line">            buf[length++]=tempC;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> readSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h3><h4 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h4><p>当不需要一个文件时，我们通常直接选中文件按下<code>delete</code>键对其删除，本关将介绍如何在Linux系统中使用<code>C</code>语言删除一个已经存在的文件。</p>
<p>在Linux系统中使用<code>unlink</code>和<code>remove</code>系统调用可以实现对文件的删除操作。</p>
<p>使用<code>man 2 函数名</code>或者<code>man 3 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="使用unlink函数删除文件"><a href="#使用unlink函数删除文件" class="headerlink" title="使用unlink函数删除文件"></a>使用unlink函数删除文件</h5><p>删除文件的系统调用函数是<code>unlink</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int unlink(const char *pathname);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要删除的文件绝对路径名或相对路径名；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功时，返回值为0；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 删除当前目录下的<code>firstFile</code>文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = unlink(<span class="string">&quot;firstFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279690" alt="img"> 将以上代码保存为<code>deleteFile1.c</code>文件中，编译执行。可以看到当前目录下存在<code>firstFile</code>文件被删除了。</p>
<h5 id="使用unlink函数删除文件-1"><a href="#使用unlink函数删除文件-1" class="headerlink" title="使用unlink函数删除文件"></a>使用unlink函数删除文件</h5><p><code>remove</code>是删除文件的另一个函数，该函数是<code>C</code>语言的库函数，其本质是通过调用系统调用<code>unlink</code>来完成文件的删除操作，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int remove(const char *pathname);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要删除的文件绝对路径名或相对路径名；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功时，返回值为0；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 删除当前目录下的<code>secondFile</code>文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = remove(<span class="string">&quot;secondFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279691" alt="img"> 将以上代码保存为<code>deleteFile2.c</code>文件中，编译执行。可以看到当前目录下存在<code>secondFile</code>文件被删除了。</p>
<h4 id="编程要求-3"><a href="#编程要求-3" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>删除当前目录下的<code>testFile</code>文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = unlink(<span class="string">&quot;testFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="目录文件I-O"><a href="#目录文件I-O" class="headerlink" title="目录文件I/O"></a>目录文件I/O</h2><h3 id="目录文件的创建与删除"><a href="#目录文件的创建与删除" class="headerlink" title="目录文件的创建与删除"></a>目录文件的创建与删除</h3><h4 id="相关知识-4"><a href="#相关知识-4" class="headerlink" title="相关知识"></a>相关知识</h4><p>目录文件是Linux系统中一类比较特殊的文件。它对构成 Linux 系统的整个文件系统结构非常重要。Linux系统提供了两个系统调用函数来实现目录的创建和删除功能，分别是<code>mkdir</code>和<code>rmdir</code>函数，这两个函数的名称和创建/删除目录命令的名称一样。其实创建/删除目录命令的背后实现方法就是调用这两个系统函数来实现对目录的创建和删除功能。</p>
<p>在Linux系统中可以使用<code>man</code>命令来查询这些函数的使用方法。具体的查询命令为： <code>man 2 函数名</code> 其中，<code>2</code>表示查找系统调用函数，关于目录的创建、打开、关闭和删除函数都是系统调用函数，因此使用<code>2</code>作为<code>man</code>命令的第一个参数。</p>
<p>案例演示1: 查询<code>mkdir</code>函数的使用方法可以使用以下命令： <code>man 2 mkdir</code></p>
<p><img src="https://data.educoder.net/api/attachments/287800" alt="img"> [查询结果]</p>
<p>通过<code>man</code>命令可以查询<code>rmdir</code>函数的使用方法。</p>
<h5 id="目录文件的创建"><a href="#目录文件的创建" class="headerlink" title="目录文件的创建"></a>目录文件的创建</h5><p>创建目录文件的系统调用函数是<code>mkdir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/type.h&gt;#include &lt;sys/stat.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：新创建的目录文件名；mode：用于指定所创建目录文件的权限；</span><br></pre></td></tr></table></figure>

<p>常见的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode</span><br></pre></td></tr></table></figure>

<p>取值及其含义见下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>mode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRUSR</td>
<td>目录所有者的读权限位</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>目录所有者的写权限位</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>目录所有者的执行权限位</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>所有者同组用户的读权限位</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>所有者同组用户的写权限位</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>所有者同组用户的执行权限位</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他用户的读权限位</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他用户的写权限位</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他用户的执行权限位</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>在Linux系统中，新创建目录的权限位是<code>(mode &amp; ~ umask &amp; 01777)</code>，也就是<code>umask</code>为进程创建目录的权限位限制。因此会出现用户在代码中设定的权限与实际创建出来的权限不一致情况。同理，对于文件权限的处理也一样。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值<code>0</code>；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>mkdir</code>函数创建一个名为<code>firstDir</code>的目录文，并设置目录的权限为<code>644</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;firstDir&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288179" alt="img"> 将以上代码保存为<code>createDir.c</code>文件，编译执行。可以看到当前目录下存在<code>firstDir</code>目录文件，并且其权限为<code>644</code>。</p>
<h5 id="目录文件的删除"><a href="#目录文件的删除" class="headerlink" title="目录文件的删除"></a>目录文件的删除</h5><p>删除目录文件的系统调用函数是<code>rmdir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rmdir(const char *pathname);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：要被删除的目录文件名称；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong>使用<code>rmdir</code>库函数删除的目录必须为空，如果该目录不为空，则必须删除该目录的所有文件(<code>.</code>和<code>..</code>文件除外)。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值<code>0</code>；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 使用<code>mkdir</code>函数删除当前目录下名为<code>firstDir</code>的目录文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = rmdir(<span class="string">&quot;firstDir&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288181" alt="img"> 将以上代码保存为<code>deleteDir.c</code>文件中，编译执行。可以看到当前目录下的<code>firstDir</code>目录文件被删除。</p>
<h4 id="编程要求-4"><a href="#编程要求-4" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在当前目录下创建一个名为<code>testDir</code>的目录，并设置其权限为<code>651</code>。</li>
<li>删除当前目录下名为<code>Dir</code>的空目录文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;testDir&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IXGRP | S_IXOTH);</span><br><span class="line">    <span class="keyword">int</span> ret1 = rmdir(<span class="string">&quot;Dir&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目录文件的打开与关闭"><a href="#目录文件的打开与关闭" class="headerlink" title="目录文件的打开与关闭"></a>目录文件的打开与关闭</h3><h4 id="相关知识-5"><a href="#相关知识-5" class="headerlink" title="相关知识"></a>相关知识</h4><p>在Linux系统中提供了以下两个系统调用函数用于打开和关闭目录操作，分别是<code>opendir</code>和<code>closedir</code>，这些库函数不属于系统调用，它们是<code>C</code>语言提供的库函数。本关将介绍目录的打开和关闭函数的使用方法。</p>
<p>因为这两个函数是<code>C</code>语言提供的库函数，因此可以使用<code>man 3 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="目录文件的打开"><a href="#目录文件的打开" class="headerlink" title="目录文件的打开"></a>目录文件的打开</h5><p>打开目录文件的库函数是<code>opendir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>DIR *opendir(const char *name);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name：需要打开的目录绝对路径名或相对路径名；</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>打开一个目录后返回一个<code>DIR</code>对象，该对象指向被打开目录的目录流。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值为一个不为空的目录流指针；调用失败时，返回值为<code>NULL</code>的空指针，并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 使用<code>opendir</code>函数打开当前用户的家目录(本实验环境的用户家目录为<code>/home/fzm</code>)。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;/home/fzm&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288609" alt="img"> 将以上代码保存为<code>openDir.c</code>文件中，编译执行。</p>
<h5 id="目录文件的关闭"><a href="#目录文件的关闭" class="headerlink" title="目录文件的关闭"></a>目录文件的关闭</h5><p>关闭目录文件的库函数是<code>closedir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int closedir(DIR *dirp);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirp：需要被关闭的目录流指针；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为 <code>0</code>；调用失败时，返回值为<code>-1</code>，并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 使用<code>closedir</code>函数关闭一个已经被打开的目录。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;/home/fzm/Downloads&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = closedir(dirp);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288611" alt="img"> 将以上代码保存为<code>closeDir.c</code>文件中，编译执行。</p>
<h4 id="编程要求-5"><a href="#编程要求-5" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li><p>补全<code>open_Dir</code>函数，使其打开一个目录并返回目录流指针<code>dirp</code>。</p>
</li>
<li><p>补全<code>close_Dir</code>函数，使其关闭一个被打开的目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * pathName: 需要被打开的目录路径</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function">DIR* <span class="title">open_Dir</span><span class="params">(<span class="keyword">char</span> *pathName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DIR* dirp = <span class="literal">NULL</span>;   <span class="comment">//存放目录流指针</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	dirp = opendir(pathName);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * dirp: 需要被关闭的目录流指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_Dir</span><span class="params">(DIR* dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">int</span> ret = closedir(dirp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录文件的读取操作"><a href="#目录文件的读取操作" class="headerlink" title="目录文件的读取操作"></a>目录文件的读取操作</h3><h4 id="相关知识-6"><a href="#相关知识-6" class="headerlink" title="相关知识"></a>相关知识</h4><p><code>ls</code>命令的背后实现方法就是通过打开被浏览的目录，然后从目录中读取目录项。Linux系统中使用<code>readdir</code>函数可以读取目录内容。本关将介绍目录的读函数的使用方法。</p>
<p>因为<code>readdir</code>函数是<code>C</code>语言提供的库函数，因此可以使用<code>man 3 函数名</code>来查询该函数的使用方法。</p>
<h5 id="目录文件的读操作"><a href="#目录文件的读操作" class="headerlink" title="目录文件的读操作"></a>目录文件的读操作</h5><p>读取目录的库调用函数是<code>readdir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>struct dirent *readdir(DIR *dirp);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirp：表示被打开目录的流指针；</span><br></pre></td></tr></table></figure>

<p>结构<code>dirent</code>指向目录项，其定义在Linux系统中的<code>&lt;dirent.h&gt;</code>头文件中，详细定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">               <span class="keyword">ino_t</span>   d_ino;       <span class="comment">/* 索引节点号 */</span></span><br><span class="line">               <span class="keyword">off_t</span>    d_off;       <span class="comment">/* 在目录文件中的偏移 */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span>  d_reclen;    <span class="comment">/* 文件名长 */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">char</span>   d_type;      <span class="comment">/* 文件类型 */</span></span><br><span class="line">               <span class="keyword">char</span>  d_name[<span class="number">256</span>]; <span class="comment">/* 文件名，最长255字符 */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>d_name</code>字段存放着所读取到的目录项名。<code>d_type</code>字段为该目录项的类型，常见类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DT_DIR：目录文件；DT_LNK：符号链接文件；DT_REG：常规文件；DT_SOCK：sock文件；DT_UNKNOWN：未知的文件类型；</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>d_type</code>字段并不是支持所有的文件系统，并且只是由<code>BSD</code>衍生出来的Linux系统中可用。在Linux系统中还提供了另一个系统调用函数用来判断文件类型，其名称为<a target="_blank" rel="noopener" href="http://www.man7.org/linux/man-pages/man2/stat.2.html">stat</a>，有兴趣的学生可以执行去学习其使用方法。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值为所写入的字节数；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 读取当前目录下的所有内容，并打印出其名称。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.表示当前目录</span></span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(closedir(dirp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288764" alt="img"> 将以上代码保存为<code>readdir.c</code>文件中，编译执行。可以看到执行该命令后会将当前目录下所有的内容都打印出来。</p>
<p>案例演示2: 读取当前目录下的所有普通文件，并打印出其名称。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.表示当前目录</span></span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dir-&gt;d_type == DT_REG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(closedir(dirp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288768" alt="img"> 将以上代码保存为<code>readRegDir.c</code>文件中，编译执行。可以看到执行该命令后只会将当前目录下常规文件打印出来了。</p>
<h4 id="编程要求-6"><a href="#编程要求-6" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>scanAll</code>函数，完成读取一个目录下所有的内容，并将每个内容按空格分割打印出来。</li>
<li>补全<code>scanDir</code>函数，完成读取一个目录下直接包含的目录名称(<strong>只读取当前目录层的内容，不往下读取</strong>)，并将每个目录按空格分割打印出来。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * dirp: 被打开的目录流指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanAll</span><span class="params">(DIR *dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//提示：不需要关闭dirp指针，输出的内容不能有换行，每个目录项中间用空格(英文空格)分割</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * dirp: 被打开的目录流指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanDir</span><span class="params">(DIR *dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提示：不需要关闭dirp指针，输出的内容不能有换行，每个目录项中间用空格(英文空格)分割</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dir-&gt;d_type == DT_DIR)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h1><h2 id="获取进程常见属性"><a href="#获取进程常见属性" class="headerlink" title="获取进程常见属性"></a>获取进程常见属性</h2><p>在  Linux  环境下，进程是一个十分重要的概念。每个进程都由一个唯一的标识符来表示，即进程 ID ，通常称为 pid 。</p>
<p> Linux 系统中存在一个特殊的进程，即空闲进程( idle process )，当没有其他进程在运行时，内核所运行的进程就是空闲进程，它的 pid 为 0 。在启动后，内核运行的第一个进程称为 init 进程，它的 pid 是 1 。通常， Linux 系统中 init 进程就是我们在资源管理器中看到的名为 init 的程序。系统中其它的进程都是由 init 来创建出来的。</p>
<p>创建新进程的那个进程被称为父进程，而新创建的进程被称为子进程。每个进程都是由其他进程创建的(除了 init 进程)，因此每个子进程都有一个父进程。</p>
<p> Linux 系统提供了两个系统调用函数来获取一个进程的 pid 和其父进程的 pid ，分别是 getpid 和 getppid 函数。在 Linux 系统中可以使用 man 命令来查询这些函数的使用方法。具体的查询命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 函数名 </span><br></pre></td></tr></table></figure>

<h5 id="获取进程自身-pid"><a href="#获取进程自身-pid" class="headerlink" title="获取进程自身 pid"></a>获取进程自身 pid</h5><p>获取进程本身的进程 ID 的系统调用函数是 getpid ，具体的说明如下：</p>
<ul>
<li>需要的头文件如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 返回当前进程的 pid 值。</p>
</li>
</ul>
<h5 id="获取父进程-pid"><a href="#获取父进程-pid" class="headerlink" title="获取父进程 pid"></a>获取父进程 pid</h5><p>获取父进程的进程 ID 的系统调用函数是 getppid ，具体的说明如下：</p>
<ul>
<li>需要的头文件如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getppid(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 返回当前进程的父进程的 pid 值。</p>
</li>
</ul>
<h4 id="编程要求-7"><a href="#编程要求-7" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 getProcInfo 函数，用于获取当前进程 ID 和其父进程 ID (<strong>提示：将结果存放在procIDInfo结构体中</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment"> * pid: 当前进程ID</span></span><br><span class="line"><span class="comment"> * ppid: 父进程ID</span></span><br><span class="line"><span class="comment">***********************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">procIDInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">pid_t</span> ppid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 返回值: 需要被打开的目录路径</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function">struct procIDInfo <span class="title">getProcInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">procIDInfo</span> <span class="title">ret</span>;</span>   <span class="comment">//存放进程ID信息，并返回</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line">	<span class="keyword">pid_t</span> ppid = getppid();</span><br><span class="line">    </span><br><span class="line">    ret.pid=pid;</span><br><span class="line">    ret.ppid=ppid;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程创建操作-fork"><a href="#进程创建操作-fork" class="headerlink" title="进程创建操作-fork"></a>进程创建操作-fork</h2><p>当用户调用 fork 函数时，系统将会创建一个与当前进程相同的新进程。通常将原始进程称为父进程，而把新生成的进程称为子进程。子进程是父进程的一个拷贝，子进程获得同父进程相同的数据，但是同父进程使用不同的数据段和堆栈段。</p>
<p>在早期的系统中，创建进程比较简单。当调用 fork 时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容也复制到子进程的地址空间中。但是从内核角度来说，这种复制方式是非常耗时的。</p>
<p>因此，在现代的系统中采取了更多的优化。现代的 Linux 系统采用了写时复制技术( Copy on Write )，而不是一创建子进程就将所有的数据都复制一份。</p>
<p> Copy on Write ( COW )的主要思路是：如果子进程/父进程只是读取数据，而不是对数据进行修改，那么复制所有的数据是不必要的。因此，子进程/父进程只要保存一个指向该数据的指针就可以了。当子进程/父进程要去修改数据时，那么再复制该部分数据即可。这样也不会影响到子父进程的执行。因此，在执行 fork 时，子进程首先只复制一个页表项，当子进程/父进程有写操作时，才会对所有的数据块进行复制操作。</p>
<h5 id="使用fork函数创建进程"><a href="#使用fork函数创建进程" class="headerlink" title="使用fork函数创建进程"></a>使用fork函数创建进程</h5><p> fork 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功， fork 函数两个值，分别是 0 和子进程 ID 号。当调用失败时，返回 -1 ，并设置错误编号 errno 。fork 函数调用将执行两次返回，它将从父进程和子进程中分别返回。从父进程返回时的返回值为子进程的  PID ，,而<strong>从子进程返回时的返回值为 0 ，并且返回都将执行 fork 之后的语句</strong>。</p>
</li>
</ul>
<p>案例演示1: 编写一个程序，使用 fork 函数创建一个新进程，并在子进程中打印出其进程 ID 和父进程 ID ，在父进程中返回进程 ID 。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为子进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为父进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/292824" alt="img"></p>
<p>将以上代码保存为 forkProcess.c 文件，编译执行。可以看到每次执行 forkProcess 时，子进程和父进程都不是固定的执行顺序，因此由 fork 函数创建的子进程执行顺序是由操作系统调度器来选择执行的。因此，子进程和父进行在执行的时候顺序不固定。</p>
<h4 id="编程要求-8"><a href="#编程要求-8" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 createProcess 函数，使用 fork 函数创建进程，并在子进程中输出 “Children” 字符串，在父进程中输出 “Parent” 字符串。(<strong>注意：不要在 createProcess 函数中使用 exit 函数或者 return 来退出程序</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 不要在子进程或父进程中使用exit函数或者return来退出程序</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Children&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程创建操作-vfork"><a href="#进程创建操作-vfork" class="headerlink" title="进程创建操作-vfork"></a>进程创建操作-vfork</h2><p> vfork 函数是一个历史遗留产物。 vfork 创建进程与 fork 创建的进程主要有一下几点区别：</p>
<ol>
<li><strong>vfork创建的子进程与父进程共享所有的地址空间</strong>，而fork创建的子进程是采用COW技术为子进程创建地址空间；</li>
<li>vfork会使得<strong>父进程被挂起</strong>，直到<strong>子进程正确退出后父进程才会被继续执行</strong>，而fork创建的子进程与父进程的<strong>执行顺序是由操作系统调度来决定</strong>。</li>
</ol>
<p> <strong>vfork 性能要比 fork 高</strong>，主要原因是 vfork 没有进行所有数据的复制，尽管 fork 采用了 COW 技术优化性能，但是也会为子进程的页表项进行复制，因此 vfork 要比 fork 快。</p>
<p>使用 vfork 时要注意，<strong>在子进程中对共享变量的修改也会影响到父进程</strong>，因此 vfork 在带来高性能的同时，也使得整个程序容易出错，因此，开发人员在使用 vfork 创建进程时，一定要注意对共享数据的修改。</p>
<p>由于 vfork 创建的子进程和父进程共享所有的数据(栈、堆等等)，因此，<strong>采用 vfork 创建的子进程必须使用 exit 或者 exec 函数族</strong>(下一关将介绍这些函数的功能)来正常退出，不<strong>能使用 return 来退出</strong>。</p>
<p> exit 函数是用来<strong>结束正在运行的整个程序</strong>， exit 是<strong>系统调用级别</strong>，它表示一个进程的结束；而 <strong>return  是语言级别的，它表示调用堆栈的返回</strong>。</p>
<h5 id="使用-vfork-函数创建进程"><a href="#使用-vfork-函数创建进程" class="headerlink" title="使用 vfork 函数创建进程"></a>使用 vfork 函数创建进程</h5><p> vfork 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t vfork(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功， vfork 函数两个值，分别是 0 和子进程 ID 号。当调用失败时，返回 -1 ，并设置错误编号 errno 。</p>
</li>
</ul>
<p><strong>注意：</strong> <strong>vfork 函数调用将执行两次返回，它将从父进程和子进程中分别返回</strong>。<strong>从父进程返回时的返回值为子进程的  PID ,而从子进程返回时的返回值为 0</strong> ，并且返回都将执行 vfork 之后的语句。 <strong>vfork 创建的子进程必须调用 exit 函数来退出子进程</strong>。</p>
<p>案例演示 1 : 编写一个程序，使用 vfork 函数创建一个新进程，并在子进程中打印出其进程 ID 和父进程 ID ，在父进程中返回进程 ID 。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);  <span class="comment">//睡眠2秒</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为子进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为父进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293076" alt="img"></p>
<p>将以上代码保存为 vforkProcess.c 文件，编译执行。可以看到 vforkProcess 创建的子进程尽管使用 sleep 函数睡眠了 2 秒，但是函数父进程的执行顺序在子进程后，这就是 vfork 的特性。</p>
<p>当我们将以上代码中的 exit(0) 换成 return 0 时，则会出现如下错误。</p>
<p><img src="https://data.educoder.net/api/attachments/293087" alt="img"></p>
<p>出现以上错误的原因是当子进程使用 return 退出时，操作系统也会把栈清空，那么当父进程继续使用 return 退出时，则会发现栈已经被清空了，这就相当于 free 两次同一块内存，因此会出现错误。</p>
<h4 id="编程要求-9"><a href="#编程要求-9" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 createProcess 函数，使用 vfork 函数创建进程，并在子进程中输出”Children”字符串(<strong>提示：需要换行</strong>)，在父进程中输出”Parent”字符串(<strong>提示：需要换行</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 不要在子进程中使用return来退出程序</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Children\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>常见与退出进程相关的函数有： exit 、 _exit 、 atexit 、 on_exit 、 abort 和 assert 。</p>
<ol>
<li>exit 函数是标准 C 库中提供的函数，它用来终止正在运行的程序，并且<strong>关闭所有 I/O 标准流</strong>。</li>
<li>_exit 函数也可用于结束一个进程，与 exit 函数不同的是， <strong>_exit 不会关闭所有 I/O 标准流</strong>。</li>
<li>atexit  函数用于<strong>注册一个不带参数也没有返回值的函数以供程序正常退出时被调用</strong>。</li>
<li>on_exit  函数的作用与 atxeit 函数十分类似，不同的是<strong>它注册的函数具有参数，退出状态和参数 arg 都是传递给该程序使用的</strong>。</li>
<li>abort 函数其实是用来<strong>发送一个 SIGABRT 信号</strong>，<strong>这个信号将使当前进程终止</strong>。</li>
<li>assert 是一个宏。<strong>调用 assert 时，它将先计算参数表达式  expression 的值,如果为 0 ，则调用 abort 函数结束进程</strong>。</li>
</ol>
<p><img src="https://data.educoder.net/api/attachments/293648" alt="img"></p>
<p>[ exit 和 _exit 区别]</p>
<h5 id="exit-和-exit-使用方法"><a href="#exit-和-exit-使用方法" class="headerlink" title="exit 和 _exit 使用方法"></a>exit 和 _exit 使用方法</h5><p> exit 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure>

<p>参数说明： status：设置程序退出码；</p>
<p>_exit 函数的具体的说明如下：</p>
</li>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<p>参数说明： status ：设置程序退出码；</p>
</li>
<li><p>函数返回值说明： exit 和 _exit 均无返回值。</p>
</li>
</ul>
<h5 id="atexit-和-on-exit-使用方法"><a href="#atexit-和-on-exit-使用方法" class="headerlink" title="atexit 和 on_exit 使用方法"></a>atexit 和 on_exit 使用方法</h5><p> atexit 和 on_exit 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int atexit(void (*function)(void));</span><br><span class="line">int on_exit(void (*function)(int , void *), void *arg);</span><br></pre></td></tr></table></figure>

<p>参数说明： atexit 函数的 function 参数是一个函数指针，指向无返回值和无参数的函数； on_exit 函数的 function 参数是一个函数指针，指向无返回值和有两个参数的函数，其中第一个参数是调用 exit() 或从 main 中返回时的值，参数 arg 指针会传给参数 function 函数；</p>
</li>
<li><p>函数返回值说明： atexit 和 on_exit 调用成功返回 0 ；调用失败返回一个非零值。</p>
</li>
</ul>
<p><strong>注意：</strong> <strong>atexit 和 on_exit 只有在程序使用 exit 或者 main 中正常退出时才会有效。如果程序使用 _exit 、 abort 或 assert 退出程序时，则不会执行被注册的函数</strong>。</p>
<h5 id="abort-和-assert-使用方法"><a href="#abort-和-assert-使用方法" class="headerlink" title="abort 和 assert 使用方法"></a>abort 和 assert 使用方法</h5><p> abort 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void abort(void);</span><br></pre></td></tr></table></figure>

<p>assert 宏的具体的说明如下：</p>
</li>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void assert(scalar expression);</span><br></pre></td></tr></table></figure>

<p>参数说明： expression ：需要被判断的表达式；</p>
</li>
</ul>
<p><strong>注意：</strong> assert 宏通常用于调试程序。</p>
<ul>
<li>函数返回值说明： abort 和 assert 无返回值。</li>
</ul>
<p>案例演示 1 : 使用 atexit 注册一个退出函数，使其在调用退出函数前被执行，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序正在被退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(atexit(out) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用atexit函数错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;```<span class="comment">//或者exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293727" alt="img"></p>
<p>将以上代码保存为 atexit.c 文件，编译执行。可以看到执行 atexit 程序后， out 函数被调用。</p>
<p>案例演示 2 : 使用 on_exit 注册一个退出函数，使其在调用退出函数前被执行，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d)\n&quot;</span>, (<span class="keyword">char</span> *s)arg, status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(on_exit(out, <span class="string">&quot;程序正在被退出&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用on_exit函数错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);```<span class="comment">//或者return 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293737" alt="img"></p>
<p>将以上代码保存为 on_exit.c 文件，编译执行。可以看到执行 on_exit 程序后， out 函数被调用，并且 status 变量的值就是 exit 函数退出的值。</p>
<p>案例演示1: 使用 abort 终止一个程序，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293754" alt="img"></p>
<p>将以上代码保存为 abort.c 文件，编译执行。可以看到执行 abort 程序后，程序被强行终止。</p>
<h4 id="编程要求-10"><a href="#编程要求-10" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 exitProcess 函数，使用 atexit 函数注册一个函数，在注册函数中打印出当前进程的 ID 号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 用户需要在exitProcess函数中使用atexit函数注册一个自定义函数，并在自定义函数中打印出当前进程ID号</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exitProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">if</span>(atexit(out) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用atexit函数错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h2><p>**如果，当子进程在父进程前结束，则内核会把子进程设置为一个特殊的状态。这种状态的进程叫做僵死进程(<code>zombie</code>)**。尽管子进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是仍然保留了一些信息(如进程号<code>pid</code>退出状态 运行时间等)。只有父进程获取了子进程的这些信息后，子进程才会彻底的被销毁，否则一直保持僵死状态。如果系统中产生大量的僵尸进程，将导致系统没有可用的进程号，从而导致系统不能创建新的进程。</p>
<p>Linux处理僵死进程的方法之一是使用进程等待的系统调用<code>wait</code>和<code>waitpid</code>来使得父进程获取子进程的终止信息。</p>
<h5 id="wait函数使用方法"><a href="#wait函数使用方法" class="headerlink" title="wait函数使用方法"></a>wait函数使用方法</h5><p><code>wait</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>wait</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pid_t wait(int *status);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参数说明： 参数`status`是一个整数指针，当子进程结束时，将子进程的结束状态字存放在该指针指向的缓存区。利用这个状态字，需要时可以使用一些由 Linux 系统定义的宏来了解子程序结束的原因。这些宏的定义与作用如下:</span><br><span class="line"></span><br><span class="line">| 宏定义              | 含义                                                         |</span><br><span class="line">| ------------------- | ------------------------------------------------------------ |</span><br><span class="line">| WIFEXITED(status)   | 子进程正常结束时，返回值为真(非零值)                         |</span><br><span class="line">| WEXITSTATUS(status) | 当WIFEXITED为真时，此宏才可以使用。返回进程退出的代码        |</span><br><span class="line">| WIFSIGNALED(status) | 子进程接收到信号结束时，返回值为真。但如果进程接收到信号时调用exit函数结束，则返回值为假 |</span><br><span class="line">| WTERMSIG(status)    | 当 WIFSIGNALED 为真时，将获得终止该进程的信号                |</span><br><span class="line"></span><br><span class="line">- 函数返回值说明： 调用成功时，返回值为被置于等待状态的进程的 `pid`；执行失败返回`-1`并设置错误代码`errno`。</span><br><span class="line"></span><br><span class="line">##### waitpid函数使用方法</span><br><span class="line"></span><br><span class="line">`waitpid`函数的具体的说明如下：</span><br><span class="line"></span><br><span class="line">- 需要的头文件如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  waitpid</span><br></pre></td></tr></table></figure>

<p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid</span><br></pre></td></tr></table></figure>

<p>：用于指定所等待的进程。其取值和相应的含义如下所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>pid</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>pid &gt; 0</td>
<td>等待进程<code>ID</code>为<code>pid</code>所指定值的子进程</td>
</tr>
<tr>
<td>pid = 0</td>
<td>等待进程组<code>ID</code>与该进程相同的子进程</td>
</tr>
<tr>
<td>pid = -1</td>
<td>等待所有子进程，等价于<code>wait</code>调用</td>
</tr>
<tr>
<td>pid &lt; -1</td>
<td>等待进程组<code>ID</code>为<code>pid</code>绝对值的子进程</td>
</tr>
</tbody></table>
<p>参数<code>option</code>则用于指定进程所做操作。其取值和相应的含义如下所示：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>将进程挂起等待其结束</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>不使进程挂起而立刻返回</td>
</tr>
<tr>
<td>WUNTRACED</td>
<td>如果进程已结束则返回</td>
</tr>
</tbody></table>
<p>参数<code>status</code>是一个整数指针，当子进程结束时，将子进程的结束状态字存放在该指针指向的缓存区。</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>WIFEXITED(status)</td>
<td>子进程正常结束时，返回值为真(非零值)</td>
</tr>
<tr>
<td>WEXITSTATUS(status)</td>
<td>当WIFEXITED为真时，此宏才可以使用。返回进程退出的代码</td>
</tr>
<tr>
<td>WIFSIGNALED(status)</td>
<td>子进程接收到信号结束时，返回值为真。但如果进程接收到信号时调用exit函数结束，则返回值为假</td>
</tr>
<tr>
<td>WTERMSIG(status)</td>
<td>当WIFSIGNALED为真时，将获得终止该进程的信号</td>
</tr>
<tr>
<td>WIFSTOPPED(status)</td>
<td>在调用函数waitpid时制定了WUNTRACED选项，且该子进程使waitpid返回时，这个宏的返回值为真</td>
</tr>
<tr>
<td>WSTOPSIG(status)</td>
<td>当WIFSTOPPED为真时，将获得停止该进程的信号</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功时，返回收集到的子进程的进程<code>pid</code>；当设置选项<code>WNOHANG</code>，而调用中<code>waitpid</code>发现没有已退出的子进程可收集，则返回<code>0</code>；执行失败返回<code>-1</code>并设置错误代码<code>errno</code>。</li>
</ul>
<p>案例演示1: 编写一个程序，使用<code>fork</code>函数与<code>wait</code>函数结合创建一个新进程，使得新创建的子进程在父进程前执行。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>(wait(&amp;status) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，退出代码：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294404" alt="img"></p>
<p>案例演示1: 编写一个程序，使用<code>fork</code>函数与<code>waitpid</code>函数结合创建一个新进程，使得新创建的子进程在父进程前执行。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，退出代码：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294406" alt="img"> 将以上代码保存为<code>waitpidProcess.c</code>文件，编译执行。可以看到执行<code>waitpidProcess</code>程序后，尽管子进程使用<code>sleep</code>睡眠了<code>2</code>秒，还是子进程先执行，然后父进程才执行。<code>waitpid</code>函数可以实现与<code>wait</code>函数相同的功能。</p>
<h4 id="编程要求-11"><a href="#编程要求-11" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>waitProcess</code>函数，等待子进程结束，并且返回子进程的退出的代码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功且子进程正常退出返回退出代码，否则返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="keyword">return</span> WEXITSTATUS(status); </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="进程创建操作-exec函数族"><a href="#进程创建操作-exec函数族" class="headerlink" title="进程创建操作-exec函数族"></a>进程创建操作-exec函数族</h2><p>在上一个实训中提到，**<code>vfork</code>函数创建的子进程可以通过调用<code>exec</code>函数族来正确退出<strong>。其原理是，</strong>使用<code>exec</code>函数族可以执行一个新的程序，并且以新的子进程来完全替换原有的进程地址空间**。</p>
<p><code>exec</code>函数族的作用是根据<strong>指定的文件名找到可执行文件，并用它来取代调用进程的内容</strong>，换句话说，就是在<strong>调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何<code>Linux</code>下可执行的脚本文件。</strong></p>
<p><strong>通常<code>exec</code>函数族用来与<code>vfork</code>函数结合一起使用。使用<code>vfork</code>函数创建一个子进程，然后在子进程中使用<code>exec</code>函数族来执行一个新的程序。当在由<code>vfork</code>创建的子进程中使用<code>exec</code>函数族来执行新程序时，子进程的地址空间会被新执行的程序完全覆盖，并且此时<code>vfork</code>的父进程与子进程地址空间被分离开，也就是使用<code>exec</code>函数族创建的新程序不会对<code>vfork</code>的父进程造成任何影响。</strong></p>
<p><code>exec</code>函数族是库函数，因此使用<code>man 3 exec</code>来查看其使用方法。</p>
<h5 id="使用exec函数族创建进程"><a href="#使用exec函数族创建进程" class="headerlink" title="使用exec函数族创建进程"></a>使用exec函数族创建进程</h5><p><code>exec</code>函数族的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...  <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],  <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ol>
<li><p>函数名中含有字母l的函数，其参数个数不定。其参数由所调用程序的命令行参数列表组成，最后一个NULL表示结束。函数名中含所有字母v的函数，则是使用一个字符串数组指针argv指向参数列表，这一字符串数组和含有l的函数中的参数列表完全相同，也同样以NULL结束。</p>
</li>
<li><p>函数名中含有字母p的函数可以自动在环境变量PATH指定的路径中搜索要执行的程序。因此它的第一个参数为file表示可执行函数的文件名。而其他函数则需要用户在参数列表中指定该程序路径，其第一个参数path 是路径名。路径的指定可以是绝对路径，也可一个是相对路径。但出于对系统安全的考虑，建议使用绝对路径而尽量避免使用相对路径。</p>
</li>
<li><p>函数名中含有字母e的函数，比其他函数多含有一个参数envp。该参数是字符串数组指针，用于制定环境变量。调用这两个函数时，可以由用户自行设定子进程的环境变量，存放在参数envp所指向的字符串数组中。这个字符串数组也必须由NULL结束。其他函数则是接收当前环境。</p>
<p>函数返回值说明： 只有当函数执行失败时，<code>exec</code>函数族才会返回<code>-1</code>并设置错误代码<code>errno</code>。当执行成功时，<code>exec</code>函数族是不会返回任何值。</p>
</li>
</ol>
</li>
</ul>
<p>案例演示<code>1</code>: 编写一个程序，使用<code>vfork</code>函数与<code>exec</code>函数族结合创建一个新进程，并在子进程中执行<code>touch testFile</code>命令创建一个<code>testFile</code>文件，在父进程中返回进程<code>ID</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">&quot;touch&quot;</span>, <span class="string">&quot;touch&quot;</span>, <span class="string">&quot;testFile&quot;</span>,  <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//执行execlp函数失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为父进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果执行execlp成功，则以下代码只会被父进程执行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293501" alt="img"> 将以上代码保存为<code>execlProcess.c</code>文件，编译执行。可以看到执行<code>execlProcess</code>程序后，在当前目录下创建了一个名为<code>testFile</code>的文件。</p>
<h4 id="编程要求-12"><a href="#编程要求-12" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>execlProcess</code>函数，使用<code>vfork</code>函数创建进程，并在子进程中调用创建一个名为<code>testDir</code>的目录，在父进程中输出”Parent Process”字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 在子进程中如果执行exec函数失败要使用exit函数正确退出子进程</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execlProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = vfork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">		<span class="keyword">if</span>(execlp(<span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;testDir&quot;</span>,  <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//执行execlp函数失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/********** END **********/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//父进程</span></span><br><span class="line">		<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Parent Process&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/********** END **********/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程创建操作-system"><a href="#进程创建操作-system" class="headerlink" title="进程创建操作-system"></a>进程创建操作-system</h2><p><code>system</code>函数是一个和操作系统相关紧密的函数。用户可以使用它来在用户自己的程序中调用系统提供的各种命令。</p>
<p>执行系统的命令行,其实也是调用程序创建一个进程来实现的。实际上，<code>system</code>函数的实现正是通过调用<code>fork</code>、<code>exec</code>和<code>waitpid</code>函数来完成的。详细的实现思路是：首先使用<code>fork</code>创建一个新的进程，并且在子进程中通过调用<code>exec</code>函数族来执行一个新程序，在父进程中通过<code>waitpid</code>函数等待子进程的结束，同时也获取子进程退出代码。</p>
<p><code>system</code>函数是库函数，因此使用<code>man 3 system</code>来查看其使用方法。</p>
<h5 id="使用system函数执行程序一个新程序"><a href="#使用system函数执行程序一个新程序" class="headerlink" title="使用system函数执行程序一个新程序"></a>使用system函数执行程序一个新程序</h5><p><code>system</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int system(const char *command);</span><br></pre></td></tr></table></figure>

<p>参数说明： <code>command：需要被执行的命令；</code></p>
</li>
<li><p>函数返回值说明： 执行成功，返回值是执行命令得到的返回状态，如同<code>wait</code>的返回值一样。执行失败时返回的值分为以下几种情况：执行<code>system</code>函数时，它将调用<code>fork</code>、<code>exec</code>和<code>waitpid</code>函数。其中任意一个调用失败都可以使得<code>system</code>函数的调用失败。如果调用<code>fork</code>函数出错，则返回值为<code>-1</code>，<code>errno</code>被设置为相应错误；如果调用<code>exec</code>时失败，则表示<code>shell</code>无法执行所设命令，返回值为<code>shell</code>操作的返回值；如果调用<code>waitpid</code>函数失败,则返回值也为<code>-1</code>，<code>errno</code>被置为相应值。</p>
</li>
</ul>
<p>案例演示<code>1</code>: 编写一个程序，使用<code>system</code>函数来执行<code>touch testFile</code>命令创建一个<code>testFile</code>文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = system(<span class="string">&quot;touch testFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;执行 touch testFile 命令失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294596" alt="img"> 将以上代码保存为<code>system.c</code>文件，编译执行。可以看到执行<code>system</code>程序后，在当前目录下创建了一个名为<code>testFile</code>的文件。</p>
<h4 id="编程要求-13"><a href="#编程要求-13" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>createProcess</code>函数，使用<code>system</code>函数创建一个名为<code>testDir</code>的目录(** 调用成功返回命令的状态码，失败返回-1**)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功返回命令的状态码，失败返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	ret = system(<span class="string">&quot;mkdir testDir&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现一个简单的命令解析器"><a href="#实现一个简单的命令解析器" class="headerlink" title="实现一个简单的命令解析器"></a>实现一个简单的命令解析器</h2><p>在<code>Linux</code>系统中<code>Shell</code>是非常重要的一个工具，<code>Shell</code>是一个用<code>C</code>语言编写的程序，它是用户使用 <code>Linux</code> 的桥梁。当打开一个<code>Shell</code>（终端），我们直接可以在命令行中输入要执行的命令，然后<code>Shell</code>会自动的读取我们输入的命令，最后执行这些命令。</p>
<p><code>RShell</code>的主要思路是：（1）读取用户输入的命令；（2）然后创建一个子进程；（3）使用<code>exec</code>函数族来执行输入的命令，同时挂起父进程；当子进程执行完成后，重复执行步骤<code>1-3</code>即可实现一个简单的命令解析器工具。</p>
<h5 id="使用system函数实现一个简单的命令解析器"><a href="#使用system函数实现一个简单的命令解析器" class="headerlink" title="使用system函数实现一个简单的命令解析器"></a>使用<code>system</code>函数实现一个简单的命令解析器</h5><p><code>system</code>函数可以执行一个命令，那么本案例将介绍如何使用<code>system</code>函数来实现一个简单的命令解析器<code>RShell</code>。详细的步骤可分为以下几步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取用户输入；</span><br><span class="line">调用system函数执行命令；</span><br><span class="line">重复第一步；</span><br></pre></td></tr></table></figure>

<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RShell&gt;&gt;&quot;</span>);   </span><br><span class="line">        gets(command);</span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//当用户输入exit命令后，退出RShell工具</span></span><br><span class="line">        system(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294667" alt="img"> 将以上代码保存为<code>systemRShell.c</code>文件中，编译执行。可以看到执行<code>systemRShell</code>命名后，我们就可以输入要执行的命令，然后按下回车，该命令就会被执行。当想退出<code>systemRShell</code>时，只需要输入<code>exit</code>回车即可。</p>
<h5 id="使用fork、exec函数族和wait实现一个简单的命令解析器"><a href="#使用fork、exec函数族和wait实现一个简单的命令解析器" class="headerlink" title="使用fork、exec函数族和wait实现一个简单的命令解析器"></a>使用<code>fork</code>、<code>exec</code>函数族和<code>wait</code>实现一个简单的命令解析器</h5><p><code>fork</code>和<code>exec</code>也可以完成执行一个新程序。详细的步骤可分为以下几步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">读取用户输入；</span><br><span class="line">调用fork函数创建一个子进程；</span><br><span class="line">在子进程中调用exec来执行用户输入的命令；</span><br><span class="line">在父进程中使用wait来等待子进程执行结束；</span><br><span class="line">重复第一步；</span><br></pre></td></tr></table></figure>

<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RShell&gt;&gt;&quot;</span>);   </span><br><span class="line">        gets(command);</span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//当用户输入exit命令后，退出RShell工具</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *file;</span><br><span class="line">            <span class="keyword">char</span> *point = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">char</span> *tmpArg[<span class="number">10</span>];</span><br><span class="line">            point = strtok(command, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            file = point;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(point != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(index == <span class="number">9</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                tmpArg[index++] = point;</span><br><span class="line">                point = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> **arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)*(index+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                arg[i] = tmpArg[i];</span><br><span class="line">            arg[index] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(execvp(file, arg) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//执行execvp函数失败</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> status;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294720" alt="img"> 将以上代码保存为<code>execRShell.c</code>文件中，编译执行。可以看到使用<code>fork</code>、<code>exec</code>和<code>wait</code>也可以实现一个简单的命令解析器工具。</p>
<h4 id="编程要求-14"><a href="#编程要求-14" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>RShell</code>函数，实现一个简单的命令解析器工具。(<strong>提示：可以使用system函数或者fork+exec+wait。</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 参数cmd: 存放要被执行的命令</span></span><br><span class="line"><span class="comment"> * 参数commandNum: 命令的个数</span></span><br><span class="line"><span class="comment"> * 案例: cmd = &#123;&quot;ls&quot;, &quot;touch testFile&quot;&#125;   commandNum = 2</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RShell</span><span class="params">(<span class="keyword">char</span> *cmd[], <span class="keyword">int</span> commandNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;=commandNum)&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            system(cmd[temp]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h1><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h4 id="相关知识-7"><a href="#相关知识-7" class="headerlink" title="相关知识"></a>相关知识</h4><p>在 Linux 中，每一个信号都有一个名字，这些名字以 SIG 开头。例如， SIGABRT 是夭折信号，当进程调用 abort 函数时会产生这种信号。SIGALRM 是闹钟信号，由 alarm 函数设置的定时器超时后将产生此信号。</p>
<h5 id="信号产生"><a href="#信号产生" class="headerlink" title="信号产生"></a>信号产生</h5><p>信号产生是指<strong>触发信号</strong>的事件的发生。</p>
<p>例如，通过键盘输入组合键<code>CTRL+C</code>系统会收到 SIGINT。 通过<code>killall -sigid processname</code>以给指定进程发送信号。</p>
<p>比如<code>killall -SIGKILL testsignal</code>给 testsignal 发送 SIGKILL 信号，即杀死进程的信号。</p>
<p>SIGUSR1 和 SIGUSR2 是<strong>用户自定义</strong>信号，通过上述的方式也可以将信号 SIGUSR1 和 SIGUSR2 传递给进程。</p>
<h5 id="信号的处理动作"><a href="#信号的处理动作" class="headerlink" title="信号的处理动作"></a>信号的处理动作</h5><p>信号是异步事件的经典实例，产生信号的事件对进程而言是<strong>随机</strong>出现的。进程不能简单地测试一个变量来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行以下操作”。</p>
<p>在某个信号出现时，可以告诉内核按照以<strong>下三种方式之一</strong>进行处理，我们称之为信号的处理或与信号相关的动作：</p>
<ul>
<li><strong>忽略</strong>此信号。大多数信号可以使用这种方式进行处理，但是 SIGKILL 和 SIGSTOP 除外。</li>
<li><strong>捕获</strong>信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。</li>
<li><strong>执行系统默认动作</strong>。对于大多数信号来说，系统默认动作是终止该进程。</li>
</ul>
<h5 id="信号处理过程"><a href="#信号处理过程" class="headerlink" title="信号处理过程"></a>信号处理过程</h5><h6 id="注册信号处理函数"><a href="#注册信号处理函数" class="headerlink" title="注册信号处理函数"></a>注册信号处理函数</h6><p>信号的处理是由内核来代理的，首先程序通过 signal 为每个信号<strong>注册</strong>处理函数，而内核中有一张信号向量表，对应信号处理机制。这样，信号在进程中注销完毕之后，会调用相应的<strong>处理函数</strong>进行处理。</p>
<h5 id="信号的检测与响应时机"><a href="#信号的检测与响应时机" class="headerlink" title="信号的检测与响应时机"></a>信号的检测与响应时机</h5><p>在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理。</p>
<h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><ul>
<li>程序运行在用户态时；</li>
<li>进程由于系统调用或中断进入内核；</li>
<li>转向用户态执行信号处理函数；</li>
<li>信号处理函数完毕后进入内核；</li>
<li>返回用户态继续执行程序。</li>
</ul>
<h5 id="signal处理接口"><a href="#signal处理接口" class="headerlink" title="signal处理接口"></a>signal处理接口</h5><p> signal 函数是最简单的信号处理接口，也是使用比较广泛的一个接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/189475" alt="预览大图"></p>
<p>参数的含义：</p>
<ul>
<li><code>signum</code>：信号名，一般不允许是 SIGKILL 或 SIGSTOP ；</li>
<li><code>handler</code>：常量 SIG_IGN、常量 SIG_DFL或者当收到此信号后要调用的函数的地址。如果是 SIG_IGN，则忽略此信号。如果是 SIG_DFL，则使用系统默认动作。</li>
</ul>
<p>返回值：返回 sighandler_t句柄或者 SIG_ERR。</p>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal(SIGINT,<span class="keyword">catch</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;catch signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行步骤如下： 运行程序： 在 10s 内按键<code>CTRL+Ｃ</code>。</p>
<p>运行结果如下： <code>hello!</code> <code>^Ccatch signal!</code> <code>hello!</code></p>
<h4 id="编程要求-15"><a href="#编程要求-15" class="headerlink" title="编程要求"></a>编程要求</h4><p>在主函数的最开始会初始化一个全部变量 g_i4event 为 0。</p>
<p>本关的编程任务是补全右侧代码片段中两段<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在 do _signal中分别为信号 SIGUSR1 、 SIGUSR2 注册信号处理函数 funcA 和 funcB ，而后将 g_i4event 置为 1；</li>
<li>完成两个信号处理函数，其中 funcA 中将 g_i4event 置为 2， funcB 中将 g_i4event 为 3。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_i4event;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">/********Begin********/</span></span><br><span class="line"><span class="comment">/*实现funcA和funcB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The courier has received the task of dispatching milk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The courier has gotten the milk from the store\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The courier has received the task of dispatching milk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The courier has not taken the milk from store\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g_i4event==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The courier has put the milk in your box\n&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********End*********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_signal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********Begin********/</span></span><br><span class="line">   </span><br><span class="line">	signal(SIGUSR1,funcA);</span><br><span class="line">	signal(SIGUSR2,funcB);</span><br><span class="line">     </span><br><span class="line">	g_i4event=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*********End*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="signal高级处理之sigaction"><a href="#signal高级处理之sigaction" class="headerlink" title="signal高级处理之sigaction"></a>signal高级处理之sigaction</h2><p>在 Linux 信号处理函数中，signal函数是最基本的，由于系统版本的不同，signal 由<strong>ISO C</strong>定义。因为 ISO C 不涉及到多进程、进程组以及终端 I /O等，所以它对信号的定义<strong>比较模糊</strong>。</p>
<p>从<strong>Unix system V</strong>派生的实现支持 signal 函数，但该函数提供旧的<strong>不可靠信号语义</strong>。4.4BSD 也提供了 signal 函数，并且提供了<strong>新</strong>的信号语义。</p>
<p>因此，signal 的语义与实现有关，为了保险起见，最好使用别的函数来代替 signal 函数。这个函数是 sigaction，也是本实训讲解的重点。</p>
<h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><p> sigaction 函数取代了 UNIX 早期版本使用的 signal 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act,struct sigaction *oldact)</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/189474" alt="img"></p>
<p>参数的含义：</p>
<ul>
<li>signo ：信号的值，可以为除 SIGKILL 及 SIGSTOP 外的任何一个特定有效的信号；</li>
<li>act ：指向结构 sigaction 的一个实例的指针，在结构 sigaction 的实例中，<strong>指定了对特定信号的处理</strong>，但可以为空，进程会以<strong>缺省方式</strong>对信号处理；</li>
<li>oldact ：对象指针，指向的对象用来保存返回的原来对相应信号的处理，可指定 oldact 为 NULL 。</li>
</ul>
<p><strong>注：如果把第二、第三个参数都设为<code>NULL</code>，那么该函数可用于检查信号的有效性。</strong></p>
<p>返回值： 0 表示成功，-1 表示有错误发生。</p>
<p>功能： sigaction 函数用于<strong>改变</strong>进程接收到特定信号后的行为。</p>
<h5 id="sigaction结构体详解"><a href="#sigaction结构体详解" class="headerlink" title="sigaction结构体详解"></a>sigaction结构体详解</h5><p>sigaction 函数最重要的部分就是<strong>sigaction结构体</strong>，这个被应用于参数 act 和 oldact 中，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__sighandler_t</span> _sa_handler;</span><br><span class="line"><span class="keyword">void</span> (*_sa_sigaction)(<span class="keyword">int</span>,struct siginfo *, <span class="keyword">void</span> *)；</span><br><span class="line">&#125;_u</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask；</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>联合数据结构中的两个元素<code>_sa_handler</code>以及 _sa_sigaction <strong>指定信号关联函数</strong>，即用户指定的信号处理函数。除了可以是用户自定义的处理函数外，还可以为<strong>SIG_DFL</strong>(采用缺省的处理方式)，也可以为 SIG_IGN (忽略信号)；</li>
<li>由 _sa_sigaction 指定的信号处理函数带有三个参数，是为实时信号而设的，它指定一个<strong>三参数信号处理函数</strong>。第一个参数为信号值，第三个参数没有使用，第二个参数是指向 siginfo_t 结构的指针，结构中包含信号携带的数据值，参数所指向的结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">siginfo_t</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>      si_signo;  <span class="comment">/* 信号值，对所有信号有意义*/</span></span><br><span class="line"><span class="keyword">int</span>      si_errno;  <span class="comment">/* errno值，对所有信号有意义*/</span></span><br><span class="line"><span class="keyword">int</span>      si_code;   <span class="comment">/* 信号产生的原因，对所有信号有意义*/</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span>                               </span><br><span class="line"><span class="comment">/* 联合数据结构，不同成员适应不同信号 */</span></span><br><span class="line">    <span class="comment">//确保分配足够大的存储空间</span></span><br><span class="line">    <span class="keyword">int</span> _pad[SI_PAD_SIZE];</span><br><span class="line">    <span class="comment">//对SIGKILL有意义的结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">  ...</span><br><span class="line">    &#125;...</span><br><span class="line">... ...  </span><br><span class="line"><span class="comment">//对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;...</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sa_mask : <strong>信号集</strong>，指定在信号处理程序执行过程中，哪些信号应当<strong>被阻塞</strong>。<strong>缺省情况</strong>下当前信号本身被阻塞，防止信号的嵌套发送，除非指定 SA_NODEFER 或者 SA_NOMASK 标志位。</li>
</ul>
<p>注：请注意 sa_mask 指定的信号阻塞的前提条件：在<code>sigaction()</code>安装信号的处理函数执行过程中，由 sa_mask 指定的信号才会被阻塞。在使用 sigaction 之前，<strong>请务必清空或者设置自己所需要的屏蔽字段</strong>。</p>
<ul>
<li>sa_flags 中包含了许多标志位，包括 SA_NODEFER 及 SA_NOMASK 标志位。另一个比较重要的标志位是 SA_SIGINFO ，当设定了该标志位时，表示信号附带的参数可以被传递到信号处理函数中，因此，应该为 sigaction 结构中的 sa_sigaction 指定处理函数，而不应该为 sa_handler 指定信号处理函数，否则设置该标志变得毫无意义。即使为 sa_sigaction 指定了信号处理函数，如果不设置 SA_SIGINFO ，信号处理函数同样不能得到信号传递过来的数据，在信号处理函数中对这些信息的访问都将导致错误。 一般的做法是，如果采用 _sa_handler 作为处理函数，则将 sa_flags 设定为0；如果采用 _sa_sigaction 作为处理函数，则将 sa_flags 设定为 SA_SIGINFO。</li>
</ul>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">oldact</span>;</span></span><br><span class="line"><span class="comment">/*注册信号处理函数*/</span></span><br><span class="line">act.sa_handler = <span class="keyword">catch</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);<span class="comment">//清空sa_mask，这点尤为重要</span></span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigaction(SIGINT, act ,oldact);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;catch signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行步骤如下：</p>
<ol>
<li>运行程序；</li>
<li>在 10s 内按键<code>CTRL +Ｃ</code>。</li>
</ol>
<p>运行结果如下： <code>hello!</code> <code>^Ccatch signal!</code> <code>hello!</code></p>
<h4 id="编程要求-16"><a href="#编程要求-16" class="headerlink" title="编程要求"></a>编程要求</h4><p>在主函数的最开始会初始化一个全部变量 g_i4event 为 0。</p>
<p>本关的编程任务是补全右侧代码片段中两段<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在 do _sigaction中分别为信号 SIGUSR1 、 SIGUSR2 注册信号处理函数 funcA 和 funcB ，而后将 g_i4event 置为 1；</li>
<li>完成两个信号处理函数，其中 funcA 中将 g_i4event 置为 2， funcB 中将 g_i4event 置为 3。</li>
</ul>
<p><strong>注：采用<code>_sa_sigaction</code>和<code>SA_SIGINFO</code>来实现。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_i4event;</span><br><span class="line"><span class="comment">/********Begin********/</span></span><br><span class="line"><span class="comment">/*实现funcA和funcB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The JD has notified the storehouse and installer\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The TV has delivered to your house from the storehouse\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The JD has notified the storehouse and installer\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The installer has arrived your house, but the TV is not delivered\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g_i4event==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The installer has installed your TV\n&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********End*********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sigaction</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********Begin********/</span></span><br><span class="line">	signal(SIGUSR1,funcA);</span><br><span class="line">	signal(SIGUSR2,funcB);  </span><br><span class="line">	g_i4event=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*********End*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux定时器"><a href="#Linux定时器" class="headerlink" title="Linux定时器"></a>Linux定时器</h2><h5 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h5><p>使用 alarm 函数可以设置一个定时器，在将来的某个时刻，这个定时器就会超时。当超时时，会产生 SIGALRM 信号。如果忽略或者不捕捉此信号，则其默认动作时终止调用该 alarm 函数的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </span><br></pre></td></tr></table></figure>

<p>参数： seconds ，是产生信号需要经过的时钟秒数，也就是定时器的时间。</p>
<p> alarm 安排内核调用进程——在指定的 seconds 秒后发出一个 SIGALRM 的信号。如果指定的参数 seconds 为 0 ，则不再发送 SIGALRM 信号。后一次设定将取消前一次的设定。该调用返回值为上次定时调用到发送之间剩余的时间，或者因为没有前一次定时调用而返回 0 。</p>
<p>注意，在使用时，alarm 只设定为发送一次信号，如果要多次发送，需要多次使用 alarm 调用。</p>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch alarm signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alarm(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">sighandler_t</span> res = signal(SIGALRM, <span class="keyword">catch</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wait for alarm signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">sleep (<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span> <span class="keyword">for</span> alarm signal!</span><br><span class="line">catch alarm signal!</span><br></pre></td></tr></table></figure>


<p>在主函数的最开始会初始化一个全部变量 g_i4event 为 0 。</p>
<p>本关的编程任务是补全右侧代码片段中两段<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在 do _alarm中首先启动 5s 定时器，将 g_i4event 置为 1；</li>
<li>睡眠一秒，然后为信号 SIGALRM 注册信号处理函数 funcalarm ，将 g_i4event 置为 2；</li>
<li>在信号处理函数，将 g_i4event 置为 3。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_i4event;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">/********Begin********/</span></span><br><span class="line"><span class="comment">/*实现funcA和funcB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;You set the alarm clock\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You start to work and wait for the alarm ring\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g_i4event==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now is 15:30, please leave home and go to apointment\n&quot;</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********End*********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********Begin********/</span></span><br><span class="line">alarm(<span class="number">5</span>);</span><br><span class="line">g_i4event=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> res = signal(SIGALRM, funcA);</span><br><span class="line">sleep (<span class="number">1</span>);</span><br><span class="line">g_i4event=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********End*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FIFO管道使用"><a href="#FIFO管道使用" class="headerlink" title="FIFO管道使用"></a>FIFO管道使用</h2><p>本关将介绍命名管道的使用方法。对于命名管道和普通文件的操作一样，使用open函数打开，然后使用read和close进行读写操作，最后使用close函数对其进行关闭。与普通文件操作的不同点是：使用read读取普通文件，read不会阻塞。而read读取管道文件，read会阻塞运行，直到管道中有数据或者所有的写端关闭。 </p>
<p>命名管道相对比无名管道的好处是可以在两个不同的程序进行数据的传输。并且命名管道当写端彻底关闭后，读端read才会返回0。 注意：</p>
<p>如果管道的读端提前关闭，写端继续写入数据就会发生异常。 读端读取管道中的数据，只要读过的数据就会被清空 。 命名管道使用方法 创建命名管道的库函数是mkfifo，具体的说明如下：</p>
<p>需要的头文件如下： <code>#include &lt;sys/types.h&gt;</code> <code>#include &lt;sys/stat.h&gt;</code> 函数格式如下： <code>int mkfifo(const char *pathname, mode_t mode);</code> 参数说明： <code>pathname</code>：存放命名管道的文件名； <code>mode</code>：创建命名管道的权限，与创建文件的权限参数一致； mode设置说明：</p>
<p><code>S_IRUSR</code>： 文件所有者的读权限位 <code>S_IWUSR</code>： 文件所有者的写权限位 <code>S_IXUSR</code> ： 文件所有者的执行权限位 <code>S_IRGRP</code>： 所有者同组用户的读权限位 <code>S_IWGRP</code>： 所有者同组用户的写权限位 <code>S_IXGRP</code>： 所有者同组用户的执行权限位 <code>S_IROTH</code>： 其他用户的读权限位 <code>S_IWOTH</code>： 其他用户的写权限位 <code>S_IXOTH</code>： 其他用户的执行权限位 函数返回值说明： 调用成功时，返回值0；调用失败时，返回值为-1并设置错误编号errno。 案例演示1: 使用mkfifo函数在当前目录下创建一个命名管道testFIFO，并设置权限为644，并用来传送数据。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(<span class="string">&quot;testFIFO&quot;</span>, S_IRUSR |  S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道失败(%s)！\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为createFIFO.c文件，编译执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">&quot;This is test FIFO&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;testFIFO&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开命名管道失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为writeFIFO.c文件，编译执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;testFIFO&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开命名管道失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = read(fd, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道中的数据为：%s(%d个字符)\n&quot;</span>, buf, size);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为readFIFO.c文件，编译执行。 首先执行createFIFO程序来创建一个命名管道，然后执行writeFIFO程序用来向管道中写入数据，最后在另一个终端中执行readFIFO程序从管道中读取数据。</p>
<h3 id="编程要求-17"><a href="#编程要求-17" class="headerlink" title="编程要求"></a>编程要求</h3><p>本关的编程任务是补全右侧代码片段中Begin至End中间的代码，具体要求如下：</p>
<p>创建一个名为FIFO的命名管道文件，并设置权限为650。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(<span class="string">&quot;FIFO&quot;</span>, S_IRUSR |  S_IWUSR | S_IRGRP | S_IXGRP);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道失败(%s)！\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>​                                     </p>
<h2 id="TCP套接字创建与端口绑定"><a href="#TCP套接字创建与端口绑定" class="headerlink" title="TCP套接字创建与端口绑定"></a>TCP套接字创建与端口绑定</h2><h4 id="相关知识-8"><a href="#相关知识-8" class="headerlink" title="相关知识"></a>相关知识</h4><p>在Linux系统中，每种协议都有自己的网络地址数据结构，这些数据结构都以<code>sockaddr_</code>开头，不同的是后缀表示不同的协议。最为常见的是<code>IPv4</code>协议，它的网络地址数据结构为<code>sockaddr_in</code>。</p>
<p>由于历史的缘故，在有些库函数中，特定协议的套接字地址结构都要强制转为通用的套接字地址结构，该数据结构被定义在<code>&lt;sys.socket.h&gt;</code>头文件中，详细定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sa_family;    <span class="comment">//套接字地址族</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_data[<span class="number">14</span>];   <span class="comment">//14个字节的协议地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_family</code>表示套接字的协议族类型，对应于<code>TCP/IP</code>协议该值为<code>AF_INET</code>；成员<code>sa_data</code>存储具体的协议地址。一般在编程中并不对该结构体进行操作，而是使用另一个与它等价的数据结构，例如，<code>IPv4</code>协议的网络地址数据结构为<code>sockaddr_in</code>，格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family;    <span class="comment">/*地址类型*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;    <span class="comment">/* 端口号*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/*IP地址*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 填充字节，一般赋值为0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_family</code>表示套接字的协议族类型，对应于<code>TCP/IP</code>协议该值为<code>AF_INET</code>；<code>sin_port</code>表示端口号；<code>sin_addr</code>用来存储<code>32</code>位的<code>IP</code>地址，数组<code>sin_zero</code>为填充字段，一般赋值为<code>0</code>。</p>
<p><code>struct in_addr</code>的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span>    </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体<code>sockaddr</code>的长度为<code>16</code>字节，结构体<code>sockaddr_in</code>的长度也为<code>16</code>字节，通常在编写基于<code>TCP/IP</code>协议的网络程序时，使用结构体<code>sockaddr_in</code>来设置地址，然后通过强制类型转换成<code>sockaddr</code>类型。结构<code>sockaddr_in</code>与<code>sockaddr</code>的转换关系如下图所示：</p>
<p><img src="https://data.educoder.net/api/attachments/311998" alt="img"></p>
<p><code>TCP</code>网络编程是目前比较通用的方式，例如：<code>HTTP</code>协议、<code>FTP</code>协议等很多广泛应用的协议都是基于<code>TCP</code>协议实现的。<code>TCP</code>编程有两种模式，分别是服务器模式和客户端模式。无论是服务器模式还是客户端模式首先需要创建一个<code>TCP</code>套接字，对于服务器模式，我们还需要绑定一个本地端口。</p>
<p>Linux系统中提供了<code>socket</code>与<code>bind</code>两个系统调用函数用来创建套接字与绑定端口操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="创建TCP套接字"><a href="#创建TCP套接字" class="headerlink" title="创建TCP套接字"></a>创建TCP套接字</h5><p>Linux系统提供一个<code>socket</code>系统调用来创建一个套接字。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain：创建套接字所使用的协议族；type：套接字类型；protocol：用于指定某个协议的特定类型，通常某个协议中只有一种特定类型，这样该参数的值仅能设置为0；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>domain</code>参数的常用的协议族如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_UNIX</td>
<td>创建只在本机内进行通信的套接字</td>
</tr>
<tr>
<td>AF_INET</td>
<td>使用IPv4 TCP/IP协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>使用IPv6 TCP/IP协议</td>
</tr>
</tbody></table>
<p><code>type</code>参数的常用的套接字类型如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>创建TCP流套接字</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>创建UDP流套接字</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>创建原始套接字</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 执行成功返回值为一个新创建的套接字，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</li>
</ul>
<p>案例演示1: 创建一个使用<code>IPv4</code>协议族的<code>TCP</code>类型的套接字。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312726" alt="img"> 将以上代码保存为<code>createTCP.c</code>文件，编译执行。</p>
<h5 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h5><p>在<code>TCP</code>服务器模式编程中，我们需要讲一个端口绑定到一个已经建立的套接字上，这样方便客户端程序根据绑定的端口来连接服务器程序。Linux提供了一个<code>bind</code>函数来将一个套接字和某个端口绑定在一起。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：是一个指向sockaddr参数的指针，其中包含了IP地址、端口；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果创建套接字时使用的是AF_INET协议族，则addr参数所使用的结构体为struct sockaddr_in指针(详细定义见相关知识)。当设置addr参数的sin_addr为INADDR_ANY而不是某个确定的IP地址时，就可以绑定到任何网络接口。对于只有一个IP地址的计算机，INADDR_ANY对应的就是它的IP地址；对于有多个网卡的主机，INADDR_ANY表示本服务器程序将处理来自任何网卡上相应端口的连接请求。由于计算机中的字符与网络中的字符存储顺序不同。计算机中的整型数与网络中的整型数进行交换时，需要借用相关的函数进行转换。这些函数如下所示：</span><br><span class="line">uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure>

<p>使用<code>man 2 函数名</code>可以查看其详细的介绍。</p>
<p>案例演示1: 创建一个使用<code>IPv4</code>协议族的<code>TCP</code>类型的套接字，并与<code>6666</code>这个端口进行绑定。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口%d成功\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312731" alt="img"> 将以上代码保存为<code>bindPort.c</code>文件，编译执行。</p>
<h4 id="编程要求-18"><a href="#编程要求-18" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>bindSocket</code>函数中代码，绑定一个指定的本地端口。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * sockfd: 已经创建的套接字</span></span><br><span class="line"><span class="comment"> * port: 需要绑定的端口号</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindSocket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    ret=bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP监听与接收连接"><a href="#TCP监听与接收连接" class="headerlink" title="TCP监听与接收连接"></a>TCP监听与接收连接</h2><h4 id="相关知识-9"><a href="#相关知识-9" class="headerlink" title="相关知识"></a>相关知识</h4><p>所谓<code>TCP</code>套接字的监听，指的是<code>TCP</code>套接字的端口处于等待状态，如果有客户端发出连接请求时，这个端口将会接受这个连接请求。连接指的是客户端向服务器发出一个通信请求，服务器会响应这个请求。</p>
<p>当服务器处于监听状态时，如果获得了一个客户端请求，则服务器将会将这个请求存放等待队列中。当系统处于空闲状态时，服务器将会从等待队列中取出请求，接受这个请求并处理这个请求。</p>
<p>Linux系统中提供了<code>listen</code>与<code>accept</code>两个系统调用函数用来监听和接受连接请求操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="TCP监听"><a href="#TCP监听" class="headerlink" title="TCP监听"></a>TCP监听</h5><p>Linux系统提供一个<code>listen</code>系统调用来实现监听等待功能。 <code>listen</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int listen(int sockfd, int backlog);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；backlog：能同时监听的最大连接请求；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong><code>listen</code>并未真正接受客户端的连接请求，只是设置<code>socket</code>的状态为<code>listen</code>模式。</p>
<p>案例演示1: 使用<code>listen</code>函数来监听指定端口的连接信息。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口%d成功\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置最大监听客户端数为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听端口%d失败: %s\n&quot;</span>, PORT, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听%d端口中...\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312837" alt="img"> 将以上代码保存为<code>listenPort.c</code>文件，编译执行。</p>
<h5 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h5><p>当服务器处理监听状态时，如果客户端发出一个连接请求，则服务器需要接受这个请求，并处理该请求。Linux提供了一个<code>accept</code>函数来接受客户端的连接请求。 <code>accept</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：保存发起连接请求的主机IP地址和端口信息；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功返回值为被接受请求的套接字编号，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong>当<code>accept</code>函数接受了一个连接时，会返回一个新的<code>socket</code>编号。接下来的数据传送与读取都是通过这个新的<code>socket</code>编号进行处理的。</p>
<p>案例演示1: 使用<code>accept</code>函数来接受客户端的请求，并打印出客户端主机的基本信息。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个TCP套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//与6666端口进行绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口%d成功\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听6666端口，并设置最大监听个数为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听端口%d失败: %s\n&quot;</span>, PORT, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听%d端口中...\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> clientSockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="comment">//接受连接请求</span></span><br><span class="line">    <span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求成功\n&quot;</span>);</span><br><span class="line">        <span class="comment">//inet_ntoa函数将网络地址转换成.点隔的字符串格式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址：%s \t 端口：%d\n&quot;</span>, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312910" alt="img"> 将以上代码保存为<code>acceptClient.c</code>文件，编译执行。在浏览器中，输入<code>localhost:6666</code>进行请求，由于<code>HTTP</code>请求也是采用<code>TCP</code>协议进行传送，所以在对<code>6666</code>端口进行访问时，服务器接受了该请求，并打印出了发起连接请求客户端<code>IP</code>地址和端口。</p>
<h4 id="编程要求-19"><a href="#编程要求-19" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>main</code>函数中代码，监听<code>8888</code>号端口(设置监听的个数大于<code>1</code>)，并接受来自客户端的第一个连接请求。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="comment">//与8888端口进行绑定</span></span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听8888端口，并设置最大监听个数大于1</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">     listen(sockfd, <span class="number">5</span>);</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//接受来自客户端的第一个连接请求</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> clientSockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听8888端口成功，并且成功接受来自客户端的第一个请求\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP连接的建立与终止相关知识"><a href="#TCP连接的建立与终止相关知识" class="headerlink" title="TCP连接的建立与终止相关知识"></a>TCP连接的建立与终止相关知识</h2><p>所谓请求连接，指的就是在客户机上向服务器发送信息时，首先需要发送一个连接请求。当服务器接受了客户端的连接请求后，客户端就可以与服务器进行数据的交换。</p>
<p>所谓终止连接，指的就是客户端与服务器之间交换完数据后，需要断开当前连接并释放相关的资源，这样方便下一个客户端的请求。由于服务器同时处理的连接请求数是有限的，所以当客户端交换完数据后不终止连接就会导致后续请求的连接失败。</p>
<p>建立<code>TCP</code>连接时需要经历<code>3</code>次握手操作，主要步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接开始时，客户端发送SYN包，并包含了自己的初始序号a；服务器收到SYN包以后会回复一个SYN包，其中包含了对上一个a包的回应信息ACK和自己的初始序号b；客户端收到回应的SYN包以后，回复一个ACK包做响应；</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/313070" alt="img"> [<code>TCP</code>建立连接三次握手过程]</p>
<p>终止<code>TCP</code>连接时需要经历<code>4</code>次握手操作，主要步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先进行关闭的一方(即发送第一个FIN)将执行主动关闭，而另一方(收到这个FIN)执行被动关闭；当被动关闭方收到这个FIN，它发回一个ACK；被动关闭方发送一个FIN请求；主动关闭方收到这个FIN请求后，回复一个ACK请求；</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/313073" alt="img"> [<code>TCP</code>终止连接四次握手过程]</p>
<p>Linux系统中提供了<code>connect</code>与<code>close</code>两个系统调用函数用来建立和终止连接请求操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="TCP建立连接请求"><a href="#TCP建立连接请求" class="headerlink" title="TCP建立连接请求"></a>TCP建立连接请求</h5><p>Linux系统提供一个<code>connect</code>系统调用来实现连接目标网络服务功能。 <code>connect</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：指针要连接的服务器IP地址和端口信息；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 在上一关卡的案例中，我们实现了如何监听和接受连接，本案例将使用<code>connect</code>实现与上一关卡案例中的服务器建立连接关系。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求连接服务器失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求连接%s:%d成功\n&quot;</span>, SERVER_IP, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/313107" alt="img"> 将以上代码保存为<code>connectServer.c</code>文件，编译执行。可以看到建立连接成功，服务器将客户端的<code>IP</code>地址和端口打印出来。<strong>注意：</strong>客户端的端口是随机分配的。</p>
<h5 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h5><p>当客户端与服务器进行数据交换完成后，我们需要断开已经建立的连接。Linux提供了两个函数来终止连接，分别是<code>close</code>函数和<code>shutdown</code>函数。</p>
<p><code>close</code>函数的使用方法与文件的关闭一样，只需将要关闭的套接字传给函数即可，此处就不做详细的介绍。</p>
<p><code>shutdown</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shutdown(int sockfd, int how);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经建立连接的套接字编号；how：具体的关闭行为；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>how</code>参数的常用取值及其含义如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHUT_RD</td>
<td>表示切断读，之后不能使用该套接字进行读操作</td>
</tr>
<tr>
<td>SHUT_WR</td>
<td>表示切断写，之后不能使用该套接字进行写操作</td>
</tr>
<tr>
<td>SHUT_RDWR</td>
<td>表示切断读写，与close函数功能一样</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</li>
</ul>
<h4 id="编程要求-20"><a href="#编程要求-20" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>connectSocket</code>函数中代码，向指定的服务器发出连接请求。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * ipAddr: 远程服务器的IP地址</span></span><br><span class="line"><span class="comment"> * port: 远程服务器的端口</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">char</span> *ipAddr, <span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接到指定的服务器</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(port);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(ipAddr);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP数据传送"><a href="#TCP数据传送" class="headerlink" title="TCP数据传送"></a>TCP数据传送</h2><h4 id="相关知识-10"><a href="#相关知识-10" class="headerlink" title="相关知识"></a>相关知识</h4><p>当创建好<code>TCP</code>套接字并且完成了客户端与服务器间的连接，接下来，我们就可以实现在客户端与服务器间的数据传送功能。</p>
<p>在客户端与服务器间进行数据传送时，一端(客户端/服务器)用于向建立好的套接字写入数据，另一端(服务器/客户端)用于从建立好的套接字中读取数据，这样一来一回的就实现了客户端与服务器间的数据交换功能。</p>
<p><img src="https://data.educoder.net/api/attachments/313259" alt="img"> [<code>TCP</code>服务器与客户端间的数据传送框架]</p>
<p>Linux系统中提供了<code>recv</code>、<code>send</code>、<code>read</code>和<code>write</code>四个系统调用函数用来完成客户端与服务器间的数据发送和接收操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="数据发送与接收方式一"><a href="#数据发送与接收方式一" class="headerlink" title="数据发送与接收方式一"></a>数据发送与接收方式一</h5><p>Linux系统提供<code>recv</code>和<code>send</code>系统调用来实现数据的发送与接收功能。 <code>recv</code>和<code>send</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；buf：用于存放接收和发送的数据；len：buf的长度；flags：设置接收与发送的控制选项，一般设置为0；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际接收或发送的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 使用<code>recv</code>和<code>send</code>函数实现客户端与服务器间的数据传送功能，客户端读取用户的数据并发送给服务器，服务器接收到数据后打印出来，当客户端读取到<code>exit</code>字符串时，关闭当前连接。详细代码如下所示：</p>
<p>客户端主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求连接服务器失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(gets(userInput) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strcasecmp(userInput, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            send(sockfd, userInput, <span class="built_in">strlen</span>(userInput), <span class="number">0</span>);  <span class="comment">//发送数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(sockfd);    <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>sendData.c</code>文件。</p>
<p>服务器主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听6666端口，并设置最大监听个数为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听端口%d失败: %s\n&quot;</span>, PORT, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> clientSockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="comment">//接受连接请求</span></span><br><span class="line">    <span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(userInput, <span class="number">0</span>, <span class="keyword">sizeof</span>(userInput));</span><br><span class="line">        <span class="keyword">while</span>(recv(clientSockfd, userInput, <span class="keyword">sizeof</span>(userInput), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端：%s\n&quot;</span>, userInput);</span><br><span class="line">            <span class="built_in">memset</span>(userInput, <span class="number">0</span>, <span class="keyword">sizeof</span>(userInput));  <span class="comment">//清空上次接收的缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(clientSockfd);  <span class="comment">//关闭客户端连接</span></span><br><span class="line">        close(sockfd);   <span class="comment">//关闭服务器套接字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>recvData.c</code>文件。</p>
<p><img src="https://data.educoder.net/api/attachments/313276" alt="img"> 编译执行以上两个程序，可以看到服务器接收到了客户端发过来的数据，并将其打印出来。<strong>注意：</strong>先执行<code>recvData</code>，再执行<code>sendData</code>程序。</p>
<h5 id="数据发送与接收方式二"><a href="#数据发送与接收方式二" class="headerlink" title="数据发送与接收方式二"></a>数据发送与接收方式二</h5><p>Linux系统可以使用<code>write</code>和<code>read</code>系统调用来实现数据的发送与接收功能。 <code>write</code>和<code>read</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void *buf, size_t count);ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：已经创建的套接字；buf：用于存放接收和发送的数据；count：buf的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际接收或发送的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong><code>write</code>和<code>read</code>函数的使用方法与文件的读写相同，此处就不做详细的案例介绍。</p>
<h4 id="编程要求-21"><a href="#编程要求-21" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>main</code>函数中代码，实现服务器与客户端间的数据传送功能。</li>
<li>将客户端发来的数据完全打印出来(<strong>提示：换行打印</strong>)，并且将接收到的数据原样发送给客户端。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="comment">//与PORT端口进行绑定</span></span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听PORT端口，并设置最大监听个数为5</span></span><br><span class="line">	<span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> clientSockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="comment">//接受连接请求</span></span><br><span class="line">	<span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">		<span class="comment">//接收客户端传来的数据，并打印出来(提示：换行打印)</span></span><br><span class="line">		<span class="comment">//同时将接收到的数据原样发送给客户端</span></span><br><span class="line">		<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">		<span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="keyword">while</span>(recv(clientSockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, data);</span><br><span class="line">            send(clientSockfd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>);  <span class="comment">//发送数据</span></span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));  <span class="comment">//清空上次接收的缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/********** END **********/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(clientSockfd);</span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP套接字创建与端口绑定"><a href="#UDP套接字创建与端口绑定" class="headerlink" title="UDP套接字创建与端口绑定"></a>UDP套接字创建与端口绑定</h2><h4 id="相关知识-11"><a href="#相关知识-11" class="headerlink" title="相关知识"></a>相关知识</h4><p>所谓无连接的套接字通信，指的就是使用<code>UDP</code>协议进行数据的传输。使用这种协议进行通信时，两台计算机间是不需要建立连接的。</p>
<p>在实训<code>Linux之网络编程(TCP)</code>中，我们介绍了使用<code>TCP</code>协议进行数据的传输。<code>TCP</code>协议是需要在服务器与客户端间进行建立连接的，并且能够保证传输的数据可靠的到达对方。那么<code>TCP</code>协议与<code>UDP</code>协议的区别主要包括以下几点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接的，也就是在数据传输前需要建立连接；而UDP时无连接的，即数据传输前不需要建立连接；TCP提供可靠的服务，也就是使用TCP协议传输的数据不会丢失、不会重复并且按序到达；而UDP协议尽最大努力将数据传输到对方，即不保证可靠交付；由于TCP需要对数据进行校验保证可靠交付，所以其实时性不如UDP好；TCP对系统资源需求较大；而UDP相对需求较少；</span><br></pre></td></tr></table></figure>

<p>由于<code>UDP</code>以简单、传输快的优势，在很多应用场景下取代了<code>TCP</code>。例如：在视频会议、语音通话场景下，<code>UDP</code>协议就比<code>TCP</code>协议更适合。因为，视频和语音丢部分内容不会影响到结果，而这些对实时性要求很高，所以采用<code>UDP</code>协议更适合。</p>
<p>在编程方面，<code>UDP</code>使用到的数据结构与<code>TCP</code>一致。例如在<code>IPv4</code>协议下，都使用<code>struct sockaddr_in</code>结构体来表示网络地址信息。</p>
<p>Linux系统中提供了<code>socket</code>与<code>bind</code>两个系统调用函数用来创建套接字与绑定端口操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="创建UDP套接字"><a href="#创建UDP套接字" class="headerlink" title="创建UDP套接字"></a>创建UDP套接字</h5><p>Linux系统提供一个<code>socket</code>系统调用来创建一个套接字。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain：创建套接字所使用的协议族；type：套接字类型；protocol：用于指定某个协议的特定类型，通常某个协议中只有一种特定类型，这样该参数的值仅能设置为0；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>domain</code>参数的常用的协议族如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_UNIX</td>
<td>创建只在本机内进行通信的套接字</td>
</tr>
<tr>
<td>AF_INET</td>
<td>使用IPv4 TCP/IP协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>使用IPv6 TCP/IP协议</td>
</tr>
</tbody></table>
<p><code>type</code>参数的常用的套接字类型如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>创建TCP流套接字</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>创建UDP流套接字</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>创建原始套接字</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 执行成功返回值为一个新创建的套接字，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</li>
</ul>
<p>案例演示1: 创建一个使用<code>IPv4</code>协议族的<code>UDP</code>类型的套接字。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/314427" alt="img"> 将以上代码保存为<code>createUDP.c</code>文件，编译执行。</p>
<h5 id="绑定端口-1"><a href="#绑定端口-1" class="headerlink" title="绑定端口"></a>绑定端口</h5><p>在<code>UDP</code>服务器模式编程中，我们需要将一个端口绑定到一个已经创建好的套接字上，这样方便客户端程序根据绑定的端口来向服务器传输数据。Linux提供了一个<code>bind</code>函数来将一个套接字和某个端口绑定在一起。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：是一个指向sockaddr参数的指针，其中包含了IP地址、端口；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>提示：</strong>使用<code>bind</code>函数为<code>UDP</code>协议绑定一个端口的使用方法与为<code>TCP</code>协议绑定端口一致，详细介绍请参看实训<a target="_blank" rel="noopener" href="https://www.educoder.net/shixuns/4hlmn9wo/challenges"> Linux之网络编程(TCP) </a>中的第一关卡内容。</p>
<h4 id="编程要求-22"><a href="#编程要求-22" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>UDPSocket</code>函数中代码，创建一个<code>UDP</code>套接字，并绑定一个指定的本地端口。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * port: 需要绑定的端口号</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPSocket</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_inet</span>;</span></span><br><span class="line">    adr_inet.sin_family=AF_INET;</span><br><span class="line">	adr_inet.sin_port=htons(port);</span><br><span class="line">	adr_inet.sin_addr.s_addr =htonl(INADDR_ANY);</span><br><span class="line">	bzero(&amp;(adr_inet.sin_zero),<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd,(struct sockaddr *)&amp;adr_inet,<span class="keyword">sizeof</span>(adr_inet))!=<span class="number">-1</span>)&#123;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP数据传送"><a href="#UDP数据传送" class="headerlink" title="UDP数据传送"></a>UDP数据传送</h2><h4 id="相关知识-12"><a href="#相关知识-12" class="headerlink" title="相关知识"></a>相关知识</h4><p>由于<code>UDP</code>协议不需要建立连接即可进行数据的传输，在服务器端创建好<code>UDP</code>套接字并绑定一个本地端口后，接下来，我们就可以实现在客户端与服务器间的数据传送功能。</p>
<p>在客户端与服务器间进行数据传送时，一端(客户端/服务器)用于向建立好的套接字写入数据，另一端(服务器/客户端)用于从建立好的套接字中读取数据，这样一来一回的就实现了客户端与服务器间的数据交换功能。</p>
<p>在实训<code>Linux之网络编程(TCP)</code>中介绍的<code>TCP</code>数据传输使用到的函数是<code>recv</code>、<code>send</code>、<code>read</code>和<code>write</code>四个系统调用。而<code>UDP</code>协议数据传输使用的函数是<code>sendto</code>和<code>recvfrom</code>两个系统调用函数。</p>
<p>Linux系统中提供了<code>sendto</code>和<code>recvfrom</code>两个系统调用函数用来完成<code>UDP</code>协议的客户端与服务器间的数据发送和接收操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="UDP协议的数据发送"><a href="#UDP协议的数据发送" class="headerlink" title="UDP协议的数据发送"></a><code>UDP</code>协议的数据发送</h5><p>Linux系统提供<code>sendto</code>系统调用来实现数据的发送功能。 <code>sendto</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；buf：用于存放接收和发送的数据；len：buf的长度；flags：设置接收与发送的控制选项，一般设置为0；dest_addr：要发往主机的网络地址信息；addrlen：dest_addr的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际发送的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<h5 id="UDP协议的数据接收"><a href="#UDP协议的数据接收" class="headerlink" title="UDP协议的数据接收"></a><code>UDP</code>协议的数据接收</h5><p>Linux系统可以使用<code>recvfrom</code>系统调用来实现数据的接收功能。 <code>recvfrom</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；buf：用于存放接收和发送的数据；len：buf的长度；flags：设置接收与发送的控制选项，一般设置为0；src_addr：要接收主机的网络地址信息；addrlen：src_addr的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际接收的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 利用<code>UDP</code>协议实现如下功能：使用<code>recvfrom</code>和<code>sendto</code>函数实现客户端与服务器间的数据传送功能，客户端读取用户的数据并发送给服务器，服务器接收到数据后打印出来，当客户端读取到<code>exit</code>字符串时，关闭当前客户端套接字，当服务器收到<code>exit</code>字符串时，关闭当前服务器套接字。详细代码如下所示：</p>
<p>客户端主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(gets(userInput) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sendto(sockfd, userInput, <span class="keyword">sizeof</span>(userInput), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));  <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(userInput, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);    <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>sendData.c</code>文件。</p>
<p>服务器主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(recvfrom(sockfd, userInput, <span class="keyword">sizeof</span>(userInput), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(userInput, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端：%s\n&quot;</span>, userInput);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);   <span class="comment">//关闭服务器套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>recvData.c</code>文件。</p>
<p><img src="https://data.educoder.net/api/attachments/314481" alt="img"> 编译执行以上两个程序，可以看到服务器接收到了客户端发过来的数据，并将其打印出来。 <strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先执行recvData，再执行sendData程序；由于UDP协议可以实现多个客户端对于一个服务器，所以当客户端退出后，服务器是不会退出的，因此，我们通过接收客户端传来的数据来判断是否服务器也需要退出；</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-23"><a href="#编程要求-23" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>main</code>函数中代码，使用<code>UDP</code>协议实现服务器与客户端间的数据传送功能。</li>
<li>将客户端发来的数据完全打印出来(<strong>提示：换行打印</strong>)，并且将接收到的数据原样发送给客户端。</li>
<li>当服务器收到<code>exit</code>字符串时，退出当前服务器程序(<strong>提示：不打印退出字符串exit</strong>)。</li>
<li><strong>提示：</strong>在每次接收字符串前要将存放字符串的变量清空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="comment">//与PORT端口进行绑定</span></span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">	<span class="comment">//接收客户端传来的数据，并打印出来(提示：换行打印)</span></span><br><span class="line">	<span class="comment">//同时将接收到的数据原样发送给客户端</span></span><br><span class="line">	<span class="comment">//当接收到&quot;exit&quot;字符串时，退出当前程序，不打印出&quot;exit&quot;字符串</span></span><br><span class="line">	<span class="comment">//提示：在每次接收字符串前要将存放字符串的变量清空</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">	<span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="keyword">while</span>(recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span> ,(struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strcasecmp(data, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, data);</span><br><span class="line">            sendto(sockfd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span> ,(struct sockaddr *)&amp;clientAddr, <span class="keyword">sizeof</span>(clientAddr));  <span class="comment">//发送数据</span></span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));  <span class="comment">//清空上次接收的缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP项目实战"><a href="#UDP项目实战" class="headerlink" title="UDP项目实战"></a>UDP项目实战</h2><h4 id="相关知识-13"><a href="#相关知识-13" class="headerlink" title="相关知识"></a>相关知识</h4><p>通过前2关的学习，我们学会如何使用<code>UDP</code>协议来在不同的计算机间传输数据。使用<code>UDP</code>协议通信时，客户端与服务器的交互过程如下图所示：</p>
<p><img src="https://data.educoder.net/api/attachments/315383" alt="img">                       [<code>UDP</code>协议的套接字通信]</p>
<p>利用以上2关的知识就可以简单的文件上传工具。该工具包含两部分内容，分别是接收文件的服务器和上传文件的客户端。</p>
<h5 id="实现文件上传工具-服务器端"><a href="#实现文件上传工具-服务器端" class="headerlink" title="实现文件上传工具-服务器端"></a>实现文件上传工具-服务器端</h5><p>实现文件上传服务器主要分为以下几个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先是接收要上传的文件名称；当接收到客户端发来的文件名称后，在本地创建该文件；从客户端中接收文件的内容，并保存在创建好的文件中；当客户端上传文件内容接收后，服务器关闭创建的文件；</span><br></pre></td></tr></table></figure>

<p>通过以上几步就可以实现文件上传服务器的功能。为了识别客户端发送来的数据类型，我们定义了以下协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们定义客户端与服务器间的数据块为1024KB(也就是每次传输的数据大小)；我们将每个数据块的前1个字节定义为数据块的类型，也就是用于标示该数据块中的内容是文件名称或文件内容或上传结束，我们使用f表示该数据块为文件名称，c标示该数据块为文件内容，e表示上传结束；</span><br></pre></td></tr></table></figure>

<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义数据块大小</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//定义服务器端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6667</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存放客户端主机信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> recvLen;</span><br><span class="line">    <span class="comment">//接收来自客户端发来的数据</span></span><br><span class="line">    <span class="keyword">while</span>((recvLen = recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据自定义的协议来判断客户端发送来的数据块类型</span></span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//上传文件完成，关闭当前打开的文件</span></span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据块是上传文件的名称，在本地创建该文件</span></span><br><span class="line">            fd = open(&amp;(data[<span class="number">1</span>]), O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收客户端上传的%s文件...\n&quot;</span>, &amp;(data[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据块为上传文件的内容，将内容写入到新创建的文件中</span></span><br><span class="line">            <span class="comment">//因为data的第一个字符为文件块类型，所以只需从第二个字符开始写文件</span></span><br><span class="line">            write(fd, &amp;(data[<span class="number">1</span>]), recvLen - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给客户端回复一个接收确认的标识OK</span></span><br><span class="line">        sendto(sockfd, <span class="string">&quot;OK&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;OK&quot;</span>), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, clientAddrLen);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);   <span class="comment">//关闭服务器套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>uploadFileServer.c</code>文件中，编译执行。</p>
<h5 id="实现文件上传工具-客户端"><a href="#实现文件上传工具-客户端" class="headerlink" title="实现文件上传工具-客户端"></a>实现文件上传工具-客户端</h5><p>实现文件上传客户端主要分为以下几个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先是获取要上传文件的名称，并将该名称发送给服务器；当收到服务器的回复后，打开文件并读取内容，将读取的内容发送给服务器；当文件所有内容发送完成后，给服务器发送一个上传完成的标识，并退出客户端；</span><br></pre></td></tr></table></figure>

<p>通过以上几步就可以实现文件上传客户端的功能。我们遵循在实现服务器时定义的协议，同时为了有序的将文件内容发送到服务器，因此，我们需要服务器每次接收成功一块数据后，给客户端返回一个标识，当客户端收到该标识后再继续发送下一块的内容。</p>
<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义数据块大小</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//定义服务器端口和服务器地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6667</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> servAddrLen = <span class="keyword">sizeof</span>(servAddr);</span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="keyword">char</span> filePath[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//读取要上传文件的路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入上传的文件路径+名称: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filePath);</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;f&#x27;</span>;  <span class="comment">//根据上传协议，设置数据块类型为文件名称</span></span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;(data[<span class="number">1</span>]), filePath);</span><br><span class="line">    <span class="comment">//向服务器发送要上传文件的名称</span></span><br><span class="line">    sendto(sockfd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//等待服务器接收确认，然后再继续上传文件内容</span></span><br><span class="line">    recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen);</span><br><span class="line">    <span class="keyword">int</span> fd = open(filePath, O_RDONLY);    <span class="comment">//打开要上传的文件</span></span><br><span class="line">    <span class="keyword">int</span> readSize = <span class="number">0</span>;</span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;   <span class="comment">//设置数据块类型为文件内容</span></span><br><span class="line">    <span class="comment">//循环读取文件内容(注意:一次实际读取的文件内容最大字符个数为1023)</span></span><br><span class="line">    <span class="keyword">while</span>((readSize = read(fd, &amp;(data[<span class="number">1</span>]), <span class="number">1023</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>))) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将读取到的文件内容连同数据块类型标识一起发送给服务器</span></span><br><span class="line">        sendto(sockfd, data, readSize+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">        <span class="comment">//等待服务器接收确认，然后再上传文件下一块的内容</span></span><br><span class="line">        recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当文件内容上传完成后，发送上传结束标识</span></span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    sendto(sockfd, data, <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">    close(fd);</span><br><span class="line">    close(sockfd);   <span class="comment">//关闭客户端套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>uploadFileClient.c</code>文件中，编译执行。</p>
<p><img src="https://data.educoder.net/api/attachments/316310" alt="img"> 编译执行，我们可以看到客户端将要上传的文件成功上传到了服务器。 <strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为同一目录下不能存在两个名称相同的文件，因此不要将服务器程序放置到与上传文件所在的目录下；首先要先执行服务器程序uploadFileServer，然后再执行客户端程序uploadFileClient；</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-24"><a href="#编程要求-24" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li><p>补全<code>downloadFileClient</code>函数，该函数是用来从服务器上下载一个指定的文件，实现下载文件的客户端部分。</p>
</li>
<li><p>下载文件要遵循以下步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先向服务器发送当前要下载的文件名称；从服务器接收数据块；向服务器发送一个接收确认请求(例如发送OK字符串)；重复第2步骤，直到收到的数据块类型为下载文件结束时，关闭当前打开的文件，然后退出程序；</span><br></pre></td></tr></table></figure></li>
<li><p>客户端与服务器间所遵循以下下载协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们定义客户端与服务器间的数据块为16KB(也就是每次传输的数据大小)；我们将每个数据块的前1个字节定义为数据块的类型，也就是用于标示该数据块中的内容是文件内容还是下载结束标识，我们使用c标示该数据块为文件内容，e表示下载结束；</span><br></pre></td></tr></table></figure></li>
<li><p><strong>提示：</strong>首先客户端向服务器先发送要下载文件的名称，告诉服务器要下载哪个文件；然后服务器读取文件，并发送给客户端。下载文件的客户端实现部分与以上案例中介绍的上传文件服务器端的实现大致相同，请仔细参看以上案例的实现。</p>
</li>
</ul>
<p>文件下载工具的服务器端的核心伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收要下载的文件名称</span></span><br><span class="line">recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line"><span class="comment">//数据块是下载文件的名称，在本地打开该文件</span></span><br><span class="line">fd = open(filePath, O_RDONLY);</span><br><span class="line"><span class="comment">//设置数据块类型为文件内容</span></span><br><span class="line">data[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> readSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//读取要下载文件的数据</span></span><br><span class="line"><span class="keyword">while</span>((readSize = read(fd, &amp;(data[<span class="number">1</span>]), <span class="number">15</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>))) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    sendto(sockfd, data, readSize+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, clientAddrLen);</span><br><span class="line">    <span class="comment">//等待客户端的接收确认</span></span><br><span class="line">    recvfrom(sockfd, ack, <span class="keyword">sizeof</span>(ack), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">    <span class="comment">//清空data文件数据部分</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;(data[<span class="number">1</span>]), <span class="number">0</span>, <span class="keyword">sizeof</span>(data)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当文件内容读取完成后，发送下载结束标识</span></span><br><span class="line">data[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">sendto(sockfd, data, <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, clientAddrLen); </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数据块大小</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//定义服务器端口和服务器地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8889</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> servAddrLen = <span class="keyword">sizeof</span>(servAddr);</span><br><span class="line">	bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));</span><br><span class="line">	servAddr.sin_family = AF_INET;</span><br><span class="line">	servAddr.sin_port = htons(PORT);</span><br><span class="line">	servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//由用户传入的要下载文件的名称</span></span><br><span class="line">	<span class="keyword">char</span> *downLoadFileName = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//先在本地创建要下载的文件</span></span><br><span class="line">	<span class="keyword">int</span> fd = fd = open(downLoadFileName, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">	<span class="comment">//向服务器发送要上传文件的名称</span></span><br><span class="line">	sendto(sockfd, downLoadFileName, <span class="built_in">strlen</span>(downLoadFileName), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">	</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="comment">//等待服务器接收确认，然后再继续上传文件内容</span></span><br><span class="line">    <span class="keyword">int</span> recvLen = <span class="number">0</span>;</span><br><span class="line">    recvLen =recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen);</span><br><span class="line">    write(fd, &amp;(data[<span class="number">1</span>]), recvLen - <span class="number">1</span>);</span><br><span class="line">    sendto(sockfd, <span class="string">&quot;OK&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;OK&quot;</span>), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//data[0] = &#x27;c&#x27;;   //设置数据块类型为文件内容</span></span><br><span class="line">    <span class="comment">//循环读取文件内容(注意:一次实际读取的文件内容最大字符个数为1023)</span></span><br><span class="line">    <span class="keyword">while</span>((recvLen=recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据自定义的协议来判断客户端发送来的数据块类型</span></span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下载文件完成，关闭当前打开的文件</span></span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据块为下载文件的内容，将内容写入到新创建的文件中</span></span><br><span class="line">            <span class="comment">//因为data的第一个字符为文件块类型，所以只需从第二个字符开始写文件</span></span><br><span class="line">            write(fd, &amp;(data[<span class="number">1</span>]), recvLen - <span class="number">1</span>);</span><br><span class="line">            sendto(sockfd, <span class="string">&quot;OK&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;OK&quot;</span>), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select机制"><a href="#select机制" class="headerlink" title="select机制"></a>select机制</h2><h4 id="相关知识-14"><a href="#相关知识-14" class="headerlink" title="相关知识"></a>相关知识</h4><p><code>select</code>机制是一种很常见的多路复用方法，准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。 当调用<code>select()</code>时，由内核根据 IO 状态修改 fd_set 的内容，由此来通知执行了<code>select()</code>的进程的那个 Socket 或文件可读或可写。主要用于 Socket 通信当中。</p>
<h5 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h5><p>使用<code>select()</code>可以完成非阻塞（所谓非阻塞方式 non-block ，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生，则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/187172" alt="img"></p>
<p>######函数参数 通过传递函数参数告知内核以下三个信息： - 我们所关心的描述符； - 对于每个描述符我们关心的条件（读，写，异常）； - 希望等待多长时间（永久等待，等一段时间，不等待）。</p>
<p>函数参数详解如下：</p>
<ul>
<li>第一个参数 maxfdp1 指定待测试的描述字个数，它的值是待测试的最大描述字加 1 （因此把该参数命名为 maxfdp1），描述字<code>0,1,2...,maxfdp1-1</code>均将被测试。文件描述符是从 0 开始的。</li>
<li>中间的三个参数 readset 、writeset 和 exceptset 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code>可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;<span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 检查集合中指定的文件描述符是否可以读写 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>timeout</code>告知内核等待所指定描述字中的任何一个就绪可花多少时间。其<code>timeval</code>结构用于指定这段时间的秒数和微秒数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个参数有三种可能：</p>
<ul>
<li><p>永远等待下去：仅在有一个描述字准备好 I/O 时才返回。为此，把该参数设置为空指针 NULL 。</p>
</li>
<li><p>等待一段固定时间：在有一个描述字准备好 I/O 时返回，但是不超过由该参数所指向的 timeval 结构中指定的秒数和微秒数。</p>
</li>
<li><p>根本不等待：检查描述字后立即返回，这称为轮询。为此，该参数必须指向一个 timeval 结构，而且其中的定时器值必须为 0。</p>
<h6 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h6><p>select 函数返回，内核告诉我们：</p>
</li>
<li><p>已准备好的描述符数量。</p>
</li>
<li><p>哪个描述符已准备好读、写、或异常。 使用该返回值，就可以调用相应的 I/O 函数(read，write)，并且明确知道该函数不会阻塞。</p>
</li>
</ul>
<p>返回值如下：</p>
<ul>
<li>返回 -1，表示出错，例如指定的描述符集都没准备好时捕捉到一个信号。</li>
<li>返回 0，表示没有描述符准备好，指定的时间已经超过。</li>
<li>返回<strong>正值</strong>，表示已经准备好的描述符数，三个描述符集中仍旧打开的位是对应已准备好的描述符位。</li>
</ul>
<p>整个 select 流程如下：</p>
<p><img src="https://data.educoder.net/api/attachments/187169" alt="img"></p>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">fd_set readfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">&#123; </span><br><span class="line">ret=select(fd+<span class="number">1</span>,&amp;readfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;timeout);  </span><br><span class="line"><span class="keyword">if</span>(ret)<span class="comment">//返回正值</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-25"><a href="#编程要求-25" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>将文件描述符加入到读集合中去。</li>
<li>设置 3s 超时机制。</li>
<li>检测 I/O 有变化，读取文件中的数据。</li>
<li>注意：数据读取完后，立刻退出函数体，以免造成死循环.</li>
<li>具体请参见后续测试样例。</li>
</ul>
<p>本关涉及的代码文件<code>SelectDamo.c</code>的代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="comment">/*buffer为数据缓冲区，将读取的到数据填充进来*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*********Begin*******/</span></span><br><span class="line">    <span class="comment">/**********End********/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*********Begin*******/</span></span><br><span class="line">    fd_set readfd;</span><br><span class="line">    FD_ZERO(&amp;readfd);</span><br><span class="line">    FD_SET(fd,&amp;readfd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec=<span class="number">3</span>; </span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123; </span><br><span class="line">        ret=select(fd+<span class="number">1</span>,&amp;readfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;timeout);  </span><br><span class="line">        <span class="keyword">if</span>(ret)<span class="comment">//返回正值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//int readSize = 0;</span></span><br><span class="line">            <span class="comment">//char tempC[BUFFER_SIZE];</span></span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">1</span>,length=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//while(1)&#123;</span></span><br><span class="line">                temp = read(fd, buffer, BUFFER_SIZE);</span><br><span class="line">                 <span class="comment">/*if(buffer[length-1]==0|buffer[length-1]==&#x27;\n&#x27;)&#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    readSize = readSize+1;</span></span><br><span class="line"><span class="comment">                    buffer[length++]=tempC;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**********End********/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-11-19T01:23:18.000Z" itemprop="datePublished">2021-11-19</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unix/" rel="tag">Unix</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  

  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/KafKa/" rel="tag">KafKa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/" rel="tag">Unix</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2021/11/19/SpringBoot%E5%AD%A6%E4%B9%A0%E8%B7%AF%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">SpringBoot学习路上遇到的问题</a>
          </li>
        
          <li>
            <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_KafKa/">KafKa学习路上遇到的问题</a>
          </li>
        
          <li>
            <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88_MyBatis/">MyBatis学习路上遇到的问题</a>
          </li>
        
          <li>
            <a href="/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">Unix程序设计课堂知识点整理</a>
          </li>
        
          <li>
            <a href="/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%B4%E6%AD%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">Unix程序设计头歌知识点整理</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            YZz &copy; 2021<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1637200696663.js"></script>


<script src="/dist/custom.js?1637200696663.js"></script>









</body>

</html>