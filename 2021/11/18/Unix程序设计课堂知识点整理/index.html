<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>YZz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Linux编程基础[TOC] 1.1 从Unix到Linux为了提升UNICS系统的性能与兼容性，采用高级语言对其进行重构，并确定该操作系统名称为UNIX，这就是最早的 UNIX 操作系统（相对于 Multics ，UNIX 具有单一的意思） GNU通用公共许可协议（GNU GPL）是一个广泛被使用的自由软件许可协议条款，最初由Stallman为GNU计划而撰写，GPL授予程序接受人以下权利，或称">
<meta property="og:type" content="article">
<meta property="og:title" content="YZz">
<meta property="og:url" content="http://example.com/2021/11/18/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="YZz">
<meta property="og:description" content="Linux编程基础[TOC] 1.1 从Unix到Linux为了提升UNICS系统的性能与兼容性，采用高级语言对其进行重构，并确定该操作系统名称为UNIX，这就是最早的 UNIX 操作系统（相对于 Multics ，UNIX 具有单一的意思） GNU通用公共许可协议（GNU GPL）是一个广泛被使用的自由软件许可协议条款，最初由Stallman为GNU计划而撰写，GPL授予程序接受人以下权利，或称">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611103621201.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611103506715.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611103853138.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611105310558.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611105654986.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611105702671.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611105827814.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611105949690.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611110447409.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611110459630.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111109662.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111326888.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111727753.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111834934.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111847709.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111917435.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111947211.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611111954948.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112004401-1623381605418.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112101376.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112126359.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112155046.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112342864.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112424180.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112436348.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112521483.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112526161.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112545028.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112553240.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611112603726.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611160145895.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143002794.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143011579.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143019456.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143027894.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143042533.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143052676.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143100984.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143111912.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143125572.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143147555.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143155638.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143205552.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143219860.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143233469.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143245888.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143254740.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143302040.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143310814.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143333036.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143340720.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143348878.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143404564.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143416361.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143424721.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611162747182.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611162858324.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611163120067.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611163125022.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611163410933.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170650485.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170732113.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170743253.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170755032.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170805503.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170815361.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170829150.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170853877.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170909100.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170919482.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611170928977.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611171422005.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611171522883.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213210597.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213233714.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213303221.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213316880.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213407986.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213417786.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611213732273.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210617212155113.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618151814819.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618152519176.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214812080.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214821927.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214834210.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214845524.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214854641.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214906327.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214915564.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214936008.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214944544.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610215005400.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610215953437.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220011507.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220021904.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220032690.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220042546.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220052131.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220104981.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220118232.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220131685.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214618550.png">
<meta property="og:image" content="https://qn-sc0.yuketang.cn/ue_i/20210412/ed409440-6383-449f-80b4-d692f0abd914.png">
<meta property="og:image" content="https://qn-sc0.yuketang.cn/ue_i/20210412/88aa10b5-c10f-4e78-a476-aa0b1042460f.png">
<meta property="og:image" content="https://qn-sc0.yuketang.cn/ue_i/20210412/78291e04-149d-44ad-a612-86b4c9fabaf1.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214629301.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610214639221.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143645924.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143654774.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143702180.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143710258.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143719274.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618143727064.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618161417909.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618161638801.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618204829654.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618204928040.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618211351096.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618211443043.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618211952186.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618212139554.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618212254955.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618212315332.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618215455459.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210618215509159.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619121308293.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619121321411.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619121557088.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619121713195.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619121805879.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619124043625.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619124101884.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619124145265.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619133437323.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619133908134.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619133920223.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619133947032.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619133957944.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619134026407.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619134117718.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220213435.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220229500.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220240603.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220250059.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220300339.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220310461.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220321107.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220333714.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220410424.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220418478.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220429370.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220438832.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220449449.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220502760-1623333903786.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220526628.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220536612.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220544837.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220603324.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220612511.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220619429.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220627025.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220637248.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220655591.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220705258.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220715535.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220730081.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220748981.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220804988.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220811818.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220821845.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220829105.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220836629.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220844183.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220851954.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220908753.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220915232.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220927300.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220935403.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220943592.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220952495.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610220959961.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610221006902.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610221014835.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610221021551.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210610221029470.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619170114870.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619170325054.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619170614129.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619171521320.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619171733752.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619171749586.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210619172130327.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101124982.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101135283.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101144547.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101151866.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101159284.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101205637.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101212054-1623377532896.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101220777.png">
<meta property="og:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611101228856.png">
<meta property="article:published_time" content="2021-11-18T14:44:39.422Z">
<meta property="article:modified_time" content="2021-06-27T07:52:21.151Z">
<meta property="article:author" content="ZYZ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/SyncDisk/笔记整理/Linux/image-20210611103621201.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">YZz</div>
      
        <div id="subtitle">YZz Blog</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">YZz</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="搜索">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="example.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Unix程序设计课堂知识点整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/18/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2021-11-18T14:44:39.422Z" itemprop="datePublished">2021-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux编程基础"><a href="#Linux编程基础" class="headerlink" title="Linux编程基础"></a>Linux编程基础</h1><p>[TOC]</p>
<h2 id="1-1-从Unix到Linux"><a href="#1-1-从Unix到Linux" class="headerlink" title="1.1 从Unix到Linux"></a><strong>1.1</strong> 从Unix到Linux</h2><p>为了提升UNICS系统的性能与兼容性，采用高级语言对其进行重构，并确定该操作系统名称为UNIX，这就是最早的 UNIX 操作系统（相对于 Multics ，UNIX 具有单一的意思）</p>
<p>GNU通用公共许可协议（GNU GPL）是一个广泛被使用的自由软件许可协议条款，最初由Stallman为GNU计划而撰写，GPL授予程序接受人以下权利，或称“自由”：</p>
<p>  ⚫ 以任何目的运行此程序的自由；</p>
<p>  ⚫ 再发行复制件的自由；</p>
<p>  ⚫ 改进此程序，并公开发布改进的自由</p>
<h2 id="1-2-Linux概述"><a href="#1-2-Linux概述" class="headerlink" title="1.2 Linux概述"></a>1.2 Linux概述</h2><p>Linux是一个类Unix（Unix-like）的操作系统，在1991年发行了它的第一个版本</p>
<p>1991年11月，芬兰赫尔辛基大学的学生 Linus Torvalds写了个小程序，取名为Linux，放在互联网上。</p>
<p>1993，在一批高水平黑客的参与下，诞生了Linux 1.0 版 </p>
<p>1994年，Linux 的第一个商业发行版 Slackware 问世</p>
<p>1996年，美国国家标准技术局的计算机系统实验室确认 Linux 版本 1.2.13（由 Open Linux 公司打包）符合 POSIX 标准</p>
<h2 id="1-3-GNU-amp-Linux"><a href="#1-3-GNU-amp-Linux" class="headerlink" title="1.3 GNU &amp; Linux"></a><strong>1.3 GNU &amp; Linux</strong></h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611103621201.png" alt="image-20210611103621201"></p>
<h2 id="1-4-Linux-内核"><a href="#1-4-Linux-内核" class="headerlink" title="1.4 Linux 内核"></a><strong>1.4 Linux</strong> <strong>内核</strong></h2><p>Linux内核采用的是双树系统</p>
<p>一棵是稳定树，主要用于发行</p>
<p>另一棵是非稳定树或称为开发树，用于产品开发和改进 </p>
<p>Linux内核版本号由3位数字组成 </p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611103506715.png" alt="image-20210611103506715"></p>
<h2 id="2-2-Vi编辑器使用"><a href="#2-2-Vi编辑器使用" class="headerlink" title="2.2 Vi编辑器使用"></a>2.2 Vi编辑器使用</h2><h3 id="1-vi的工作模式"><a href="#1-vi的工作模式" class="headerlink" title="1.vi的工作模式"></a>1.vi的工作模式</h3><p>输入模式：输入字符为命令，可进行删除、修改、存盘等操作 。</p>
<p>命令模式：输入字符作为文本内容。 </p>
<p>末行模式：命令模式下输入“：/？”三个中任意一个，可移到屏幕最底一行。</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611103853138.png" alt="image-20210611103853138"></p>
<p>（1）命令模式</p>
<p>输入模式下，按ESC可切换到命令模式，常用命令： </p>
<table>
<thead>
<tr>
<th>：q!</th>
<th>离开vi，并放弃刚在缓冲区内编辑的内容</th>
</tr>
</thead>
<tbody><tr>
<td>：wq</td>
<td>将缓冲区内的资料写入磁盘中，并离开vi</td>
</tr>
<tr>
<td>：ZZ</td>
<td>同wq</td>
</tr>
<tr>
<td>：x</td>
<td>同wq</td>
</tr>
<tr>
<td>：w</td>
<td>将缓冲区内的资料写入磁盘中，但并不离开vi</td>
</tr>
<tr>
<td>：q</td>
<td>离开vi，若文件被修改过，则要被要求确认是否放弃修改的内容，此指令可与：w配合使用</td>
</tr>
</tbody></table>
<p>（2）输入模式</p>
<p>输入以下命令即可进入vi输入模式 </p>
<table>
<thead>
<tr>
<th>a(append)</th>
<th>在光标之后加入资料</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>在该行之末加入资料</td>
</tr>
<tr>
<td>i(insert)</td>
<td>在光标之前加入资料</td>
</tr>
<tr>
<td>I</td>
<td>在该行之首加入资料</td>
</tr>
<tr>
<td>o(open)</td>
<td>新增一行于该行之下，供输入资料用</td>
</tr>
<tr>
<td>O</td>
<td>新增一行于该行之上，供输入资料用</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前光标所在行</td>
</tr>
<tr>
<td>x</td>
<td>删除当前光标字符</td>
</tr>
<tr>
<td>X</td>
<td>删除当前光标之前字符</td>
</tr>
<tr>
<td>U</td>
<td>撤消</td>
</tr>
<tr>
<td>F</td>
<td>查找</td>
</tr>
<tr>
<td>ESC</td>
<td>离开输入模式</td>
</tr>
</tbody></table>
<h3 id="2-Vi其他功能命令"><a href="#2-Vi其他功能命令" class="headerlink" title="2.Vi其他功能命令"></a>2.Vi其他功能命令</h3><p>（1）复制粘贴</p>
<table>
<thead>
<tr>
<th>yw</th>
<th>将光标所在之处到字尾的字符复制到缓冲区</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标所在行到缓冲区</td>
</tr>
<tr>
<td>#yy</td>
<td>如：6yy表示拷贝从光标所在行往下数6行文字</td>
</tr>
<tr>
<td>p</td>
<td>将缓冲区内的字符贴到光标所在位置</td>
</tr>
</tbody></table>
<p>（2）查找/替换</p>
<table>
<thead>
<tr>
<th>?字符串</th>
<th>从当前光标位置开始向后查找字符串</th>
</tr>
</thead>
<tbody><tr>
<td>/字符串</td>
<td>从当前光标位置开始向前查找字符串</td>
</tr>
<tr>
<td>n</td>
<td>继续上一次查找</td>
</tr>
<tr>
<td>Shift+n</td>
<td>以相反的方向继续上一次查找</td>
</tr>
</tbody></table>
<p>（3）环境设置</p>
<table>
<thead>
<tr>
<th>:set ai</th>
<th>自动缩进，每一行开头都与上一行的开头对齐</th>
</tr>
</thead>
<tbody><tr>
<td>:set nu</td>
<td>编辑时显示行号</td>
</tr>
<tr>
<td>:set dir=./</td>
<td>将交换文件.swp保存在当前目录</td>
</tr>
<tr>
<td>:set sw=4</td>
<td>设置缩进的字符数为4</td>
</tr>
<tr>
<td>:syntax on  或者  :syntax=on</td>
<td>开启语法着色</td>
</tr>
</tbody></table>
<h2 id="3-1-GCC编译器介绍"><a href="#3-1-GCC编译器介绍" class="headerlink" title="3.1 GCC编译器介绍"></a>3.1 GCC编译器介绍</h2><p>GCC是一个强大的工具集合，它包含了预处理器、编译器、汇编器、链接器等组件。它会在需要的时候调用其他组件。<br> 输入文件的类型和传递给gcc的参数决定了gcc调用具体的哪些组件。</p>
<p><strong>GCC</strong> <strong>参数选项</strong></p>
<p>Usage:</p>
<p>gcc [options] [filename]</p>
<p>Basic options:</p>
<table>
<thead>
<tr>
<th>-E:</th>
<th>只对源程序进行预处理(调用cpp预处理器)</th>
</tr>
</thead>
<tbody><tr>
<td>-S:</td>
<td>只对源程序进行预处理、编译</td>
</tr>
<tr>
<td>-c:</td>
<td>执行预处理、编译、汇编而不链接</td>
</tr>
<tr>
<td>-o:</td>
<td>output_file: 指定输出文件名</td>
</tr>
<tr>
<td>-g:</td>
<td>产生调试工具必需的符号信息</td>
</tr>
<tr>
<td>-O/On:</td>
<td>在程序编译、链接过程中进行优化处理</td>
</tr>
<tr>
<td>-Wall:</td>
<td>显示所有的警告信息</td>
</tr>
<tr>
<td>-I dir:</td>
<td>在头文件的搜索路径中添加dir目录</td>
</tr>
<tr>
<td>-L dir :</td>
<td>在库文件的搜索路径列表中添加dir目录</td>
</tr>
</tbody></table>
<h2 id="3-2-GCC编译过程"><a href="#3-2-GCC编译过程" class="headerlink" title="3.2 GCC编译过程"></a>3.2 GCC编译过程</h2><p>1、预处理</p>
<p>2、编译成汇编代码</p>
<p>3、汇编成目标代码</p>
<p>4、链接</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>预处理：使用-E参数</p>
<p> gcc –E –o gcctest.i gcctest.c</p>
<p>使用wc命令比较预处理后的文件与源文件，可以看到两个文件的差异</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105310558.png" alt="image-20210611105310558"></p>
<h3 id="2-编译成汇编代码"><a href="#2-编译成汇编代码" class="headerlink" title="2.编译成汇编代码"></a>2.编译成汇编代码</h3><p>预处理文件—-&gt;汇编代码<br> 使用-S说明生成汇编代码后停止工作</p>
<p>gcc –S –o gcctest.s gcctest.i</p>
<p>直接编译到汇编代码</p>
<p> gcc –S gcctest.c</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105654986.png" alt="image-20210611105654986"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105702671.png" alt="image-20210611105702671"></p>
<h3 id="3-编译成目标代码"><a href="#3-编译成目标代码" class="headerlink" title="3.编译成目标代码"></a>3.编译成目标代码</h3><p>汇编代码à目标代码</p>
<p> gcc –x assembler –c gcctest.s</p>
<p>直接编译成目标代码</p>
<p> <strong>gcc</strong> <strong>–c</strong> <strong>gcctest.c</strong></p>
<p>使用汇编器生成目标代码</p>
<p>as –o gcctest.o gcctest.s</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105827814.png" alt="image-20210611105827814"></p>
<h3 id="4-编译成执行代码"><a href="#4-编译成执行代码" class="headerlink" title="4.编译成执行代码"></a>4.编译成执行代码</h3><p>目标代码à执行代码</p>
<p> gcc –o gcctest gcctest.o</p>
<p>直接生成执行代码</p>
<p> gcc –o gcctest gcctest.c</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611105949690.png" alt="image-20210611105949690"></p>
<h2 id="3-3-GCC编译优化"><a href="#3-3-GCC编译优化" class="headerlink" title="3.3 GCC编译优化"></a>3.3 GCC编译优化</h2><p>优化编译选项有：</p>
<p>-O0<br> 缺省情况，不优化</p>
<p>-O1</p>
<p>-O2</p>
<p>-O3</p>
<p>等等</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611110447409.png" alt="image-20210611110447409"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611110459630.png" alt="image-20210611110459630"></p>
<h2 id="3-4-头文件和库函数目录"><a href="#3-4-头文件和库函数目录" class="headerlink" title="3.4 头文件和库函数目录"></a><strong>3.4</strong> <strong>头文件和库函数目录</strong></h2><h3 id="1-GCC-–I-dir-参数使用"><a href="#1-GCC-–I-dir-参数使用" class="headerlink" title="1. GCC –I dir 参数使用"></a><strong>1. GCC –I</strong> <strong>dir</strong> <strong>参数使用</strong></h3><p>头文件和gcc不在同一目录下，用 –I dir指明头文件所在的目录。</p>
<p>#include &lt;&gt;：在默认路径“/usr/include”中搜索头文件    </p>
<p>#include “”：在本目录中搜索</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111109662.png" alt="image-20210611111109662"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111326888.png" alt="image-20210611111326888"></p>
<p>解决办法：</p>
<ol>
<li><p>gcc opt.c –o opt –I ./</p>
</li>
<li><p>修改main</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;my.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “my.h”</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-GCC创建函数库"><a href="#2-GCC创建函数库" class="headerlink" title="2. GCC创建函数库"></a><strong>2. GCC</strong>创建函数库</h3><p>函数库：公用函数定义为函数库，供其他程序使用。函数库分为静态库和动态库。</p>
<p>静态库：<strong>程序编译时会链接到目标代码中，程序运行时不再需要静态库</strong>。程序生成的可执行程序比较大。<strong>后缀名为“.a”</strong></p>
<p>动态库：程序编译时<strong>不会链接到目标代码</strong>，在程序<strong>运行时载入</strong>，运行时需要动态库存在。动态库可方便多个程序共享一个函数库。<strong>后缀名为”.so”</strong></p>
<p><strong>函数库的生成：由编译过的.o文件生成。</strong></p>
<h3 id="创建静态库："><a href="#创建静态库：" class="headerlink" title="创建静态库："></a>创建静态库：</h3><p>  1.将需要生成函数库的函数执行gcc –c，生成.o文件</p>
<p>​    gcc –c hello.c</p>
<p>  2.由.o文件创建静态库，静态库命名格式为：lib静态库名.a</p>
<p>​    ar -rv libmyhello.a hello.o</p>
<ol start="3">
<li><p>使用静态库：在调用静态库的程序编译时指定静态库名</p>
<p>$gcc –o hello main.c –L. –lmyhello</p>
<p>$./hello</p>
</li>
</ol>
<h3 id="创建动态库："><a href="#创建动态库：" class="headerlink" title="创建动态库："></a>创建动态库：</h3><p>1.由.o文件生成动态库，动态库的命名：lib动态库名.so</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc –shared –fPIC –o libmyhello.so hello.o</span><br><span class="line"></span><br><span class="line">gcc –shared –fPIC –o libmyhello.so hello.c （centos版本）</span><br></pre></td></tr></table></figure>

<p>  2.使用动态库：用gcc命令指定动态库名进行编译，编译之前需将动态库文件复制到系统默认库函数目录/usr/lib中或者设置搜索路径。  sudo ldconfig </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc –o hello main.c –L. –lmyhello</span><br><span class="line"></span><br><span class="line">gcc –o hello main.c –L. –lmyhello -Wl,-rpath=./</span><br></pre></td></tr></table></figure>



<h2 id="gdb-commands"><a href="#gdb-commands" class="headerlink" title="gdb commands"></a><strong>gdb</strong> <strong>commands</strong></h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111727753.png" alt="image-20210611111727753"></p>
<h2 id="Gdb-using"><a href="#Gdb-using" class="headerlink" title="Gdb using"></a><strong>Gdb</strong> <strong>using</strong></h2><p>$gdb filename</p>
<p>gdb将装入名为filename的<strong>可执行文件</strong>。</p>
<p>在编译时需要使用-g选项</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111834934.png" alt="image-20210611111834934"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111847709.png" alt="image-20210611111847709"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111917435.png" alt="image-20210611111917435"></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111947211.png" alt="image-20210611111947211"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611111954948.png" alt="image-20210611111954948"></p>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a><strong>help</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112004401-1623381605418.png" alt="image-20210611112004401"></p>
<h4 id="设置断点-break"><a href="#设置断点-break" class="headerlink" title="设置断点 break"></a>设置断点 <strong>break</strong></h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112101376.png" alt="image-20210611112101376"></p>
<h3 id="显示断点信息-info-breakpoints"><a href="#显示断点信息-info-breakpoints" class="headerlink" title="显示断点信息 info breakpoints"></a>显示断点信息 <strong>info breakpoints</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112126359.png" alt="image-20210611112126359"></p>
<h3 id="清除已经定义的断点-clear"><a href="#清除已经定义的断点-clear" class="headerlink" title="清除已经定义的断点  clear"></a>清除已经定义的断点  <strong>clear</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112155046.png" alt="image-20210611112155046"></p>
<h3 id="delete-bkpoints-num-删除指定-全部断点"><a href="#delete-bkpoints-num-删除指定-全部断点" class="headerlink" title="delete [bkpoints-num]删除指定/全部断点"></a>delete [bkpoints-num]删除指定/全部断点</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112342864.png" alt="image-20210611112342864"></p>
<h3 id="print-bkpoints-num-输出断点处变量的值"><a href="#print-bkpoints-num-输出断点处变量的值" class="headerlink" title="print [bkpoints-num] 输出断点处变量的值"></a>print [bkpoints-num] 输出断点处变量的值</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112424180.png" alt="image-20210611112424180"></p>
<h3 id="quit-退出gdb"><a href="#quit-退出gdb" class="headerlink" title="quit:退出gdb"></a>quit:退出gdb</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112436348.png" alt="image-20210611112436348"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112521483.png" alt="image-20210611112521483"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112526161.png" alt="image-20210611112526161"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112545028.png" alt="image-20210611112545028"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112553240.png" alt="image-20210611112553240"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611112603726.png" alt="image-20210611112603726"></p>
<h3 id="调试子命令总结"><a href="#调试子命令总结" class="headerlink" title="调试子命令总结"></a><strong>调试子命令总结</strong></h3><p>file ：装入想要调试的可执行文件</p>
<p>kill：终止正在调试的程序</p>
<p>list：列出正在执行的程序清单</p>
<p>next：执行一行代码但不进入函数内部</p>
<p>step：执行一行代码并进入函数内部</p>
<p>run： 执行当前正在调试的程序</p>
<p>quit：终止gdb调试</p>
<p>break：设置断点 （break 行号）</p>
<p>watch：设置观察点，观察表达式的值是否发</p>
<p>​         生变化</p>
<p><strong>info: 查看断点信息</strong></p>
<p>   <strong>info breakpoints、info watchpoints</strong></p>
<p>   <strong>info break 显示当前断点清单，包括到达</strong></p>
<p>​           <strong>断点处的次数等。</strong></p>
<p>   <strong>info files 显示被调试文件的详细信息。</strong></p>
<p>   <strong>info func 显示所有的函数名称。</strong></p>
<p>   <strong>info local 显示当函数中的局部变量信息。</strong></p>
<p>   <strong>info prog 显示被调试程序的执行状态。</strong></p>
<p>   <strong>info var 显示所有的全局和静态变量名称</strong></p>
<p><strong>delete: 删除某个或所有的断点</strong></p>
<p>​    <strong>delete 断点号  或 delete</strong></p>
<p><strong>disable: 使断点失效（但仍存在）</strong></p>
<p><strong>enable: 使断点有效</strong></p>
<p><strong>clear: 清除断点信息</strong></p>
<p>​    <strong>clear 断点所在行号</strong></p>
<p>​    <strong>clear 函数入口</strong></p>
<p><strong>continue: 继续执行程序直到程序结束</strong></p>
<h2 id="5-1-Make-引入"><a href="#5-1-Make-引入" class="headerlink" title="5.1 Make 引入"></a><strong>5.1 Make</strong> <strong>引入</strong></h2><p>Make的引入:</p>
<p>Ø文件数量太大,手工gcc编译不方便</p>
<p>Ø仅需要编译已经做了修改的源代码文件;其他文件只需要重新连接</p>
<p>Ø记录哪些文件已改变且需要编译，哪些文件仅仅需要连接很难</p>
<h3 id="make-amp-makefile"><a href="#make-amp-makefile" class="headerlink" title="make &amp; makefile"></a><strong>make &amp;</strong> <strong>makefile</strong></h3><h4 id="Multi-file-project"><a href="#Multi-file-project" class="headerlink" title="Multi-file project"></a>Multi-file project</h4><p>IDE—Eclipse</p>
<p>make</p>
<h4 id="make-amp-makefile-1"><a href="#make-amp-makefile-1" class="headerlink" title="make &amp; makefile"></a>make &amp; makefile</h4><p>makefile描述模块间的依赖关系；</p>
<p>make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系</p>
<h4 id="make"><a href="#make" class="headerlink" title="make"></a><strong>make</strong></h4><p>make [-f filename] [targetname]</p>
<p>使用方法：</p>
<p>v  <strong>make</strong>  自动找当前目录下名为Makefile/makefile的文件</p>
<p>v  <strong>make</strong> –f <strong>文件名</strong> 找当前目录下指定文件名的文件</p>
<h4 id="makefile的组成"><a href="#makefile的组成" class="headerlink" title="makefile的组成"></a><strong>makefile的组成</strong></h4><ul>
<li>显式规则：明确指出目标文件的生成规则</li>
<li>隐式规则：需要make自动推导的规则</li>
<li>变量定义：声明时赋值，引用时加”$”</li>
<li>文件指示：引用外部的文件</li>
<li>注释：#  </li>
</ul>
<h4 id="Makefile的显式规则"><a href="#Makefile的显式规则" class="headerlink" title="Makefile的显式规则"></a><strong>Makefile</strong>的显式规则</h4><p>规则<br> 一条规则包含3个方面的内容，</p>
<p>1）要创建的目标（文件），</p>
<p>2）创建目标（文件）所依赖的文件列表；</p>
<p>3）通过依赖文件创建目标文件的命令组</p>
<p>规则一般形式</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*target* ... : *prerequisites* ... </span><br><span class="line"></span><br><span class="line">*&lt;tab&gt;command* </span><br><span class="line"></span><br><span class="line">&lt;tab&gt;...</span><br><span class="line"></span><br><span class="line">&lt;tab&gt;...</span><br></pre></td></tr></table></figure>

<p>每条规则由一个带冒号的“依赖行”和一条或多条以<strong>tab</strong>开头的“命令行”组成</p>
<p>目标1 [目标2…]:[依赖文件列表]</p>
<p>[\t 命令]</p>
<p>…</p>
<p><em>ex:</em></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">*make_test:make_main.o* *wrtlog.o*</span></span><br><span class="line"></span><br><span class="line">**&lt;TAB&gt;***gcc* *-o* *make_test* *make_main.o* *wrtlog.o*</span><br></pre></td></tr></table></figure>

<p>冒号左边是目标,冒号右边是依赖文件</p>
<p>目标和依赖文件均是由字母、数字、句点和斜杠组成的字符串</p>
<p>目标或依赖文件的数目多于一个时，以空格分隔</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611160145895.png" alt="image-20210611160145895"></p>
<p><strong>一个简单的</strong>makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">	gcc -o edit main.o kbd.o command.o display.o insert.o \</span><br><span class="line">	search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">	gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">	gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">	gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">	gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">	gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">	gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">	gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">	gcc -c utils.c</span><br><span class="line"></span><br><span class="line">clean : </span><br><span class="line">	rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o </span><br></pre></td></tr></table></figure>

<h3 id="Make的工作过程"><a href="#Make的工作过程" class="headerlink" title="Make的工作过程"></a><strong>Make</strong>的工作过程</h3><p>default goal<br> 在缺省的情况下，make从makefile中的第一个目标开始执行</p>
<p>Make的工作过程类似一次深度优先遍历过程</p>
<h3 id="Makefile的变量"><a href="#Makefile的变量" class="headerlink" title="Makefile的变量"></a><strong>Makefile</strong>的变量</h3><p>自定义变量<br> 例：</p>
<p>   object=main.o Add.o Sub.o Mul.o Div.o</p>
<p>   exe : $(object)</p>
<p>   gcc -o exe $(object)</p>
<p>特殊变量</p>
<p>  $@：表示目标文件；</p>
<p>   $^：表示所有依赖目标的集合，以空格分隔；</p>
<p>   $&lt;：表示第一个依赖文件；</p>
<h3 id="Makefile的隐式规则（自动推导）"><a href="#Makefile的隐式规则（自动推导）" class="headerlink" title="Makefile的隐式规则（自动推导）"></a><strong>Makefile</strong>的隐式规则（自动推导）</h3><p>make能够自动推导文件以及文件依赖关系后面的命令</p>
<p>  例：</p>
<p>  object=main.o Add.o Sub.o Mul.o Div.o</p>
<p>  exe : $(object)</p>
<p>  gcc -o $@ $(object)</p>
<p>  main.o : def.h</p>
<h3 id="Makefile的伪目标"><a href="#Makefile的伪目标" class="headerlink" title="Makefile的伪目标"></a><strong>Makefile</strong>的伪目标</h3><p>lmakefile使用.PHONY关键字来定义一个伪目标，具体格式为：</p>
<p>  .PHONY : 伪目标名称</p>
<p>  例：</p>
<p>  .PHONY : clean</p>
<p>  clean :</p>
<p>​    rm $(object)</p>
<h2 id="总结-C语言编程步骤"><a href="#总结-C语言编程步骤" class="headerlink" title="总结: C语言编程步骤"></a><strong>总结</strong>: C语言编程步骤</h2><ol>
<li>编辑：vi ,emacs,gedit,Eclipse…</li>
<li>编译： gcc</li>
<li>调试：gdb</li>
<li>运行： ./executable file</li>
<li>项目管理：make</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h3><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>解释</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>file &lt;文件名&gt;</td>
<td>加载被调试的可执行程序文件。 因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。</td>
<td>(gdb) file gdb-sample</td>
</tr>
<tr>
<td>r</td>
<td>Run的简写，运行被调试的程序。 如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。</td>
<td>(gdb) r</td>
</tr>
<tr>
<td>c</td>
<td>Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</td>
<td>(gdb) c</td>
</tr>
<tr>
<td>b &lt;行号&gt; b &lt;函数名称&gt; b *&lt;函数名称&gt; b *&lt;代码地址&gt;d [编号]</td>
<td>b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。</td>
<td>(gdb) b 8 (gdb) b main (gdb) b *main (gdb) b *0x804835c(gdb) d</td>
</tr>
<tr>
<td>s, n</td>
<td>s: 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数； n: 执行一行源程序代码，此行代码中的函数调用也一并执行。s 相当于其它调试器中的“Step Into (单步跟踪进入)”； n 相当于其它调试器中的“Step Over (单步跟踪)”。这两个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。</td>
<td>(gdb) s (gdb) n</td>
</tr>
<tr>
<td>si, ni</td>
<td>si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</td>
<td>(gdb) si (gdb) ni</td>
</tr>
<tr>
<td>p &lt;变量名称&gt;</td>
<td>Print的简写，显示指定变量（临时变量或全局变量）的值。</td>
<td>(gdb) p i (gdb) p nGlobalVar</td>
</tr>
<tr>
<td>display …undisplay &lt;编号&gt;</td>
<td>display，设置程序中断后欲显示的数据及其格式。 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 “display /i pc”其中pc”其中pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。undispaly，取消先前的display设置，编号从1开始递增。</td>
<td>(gdb) display /i $pc(gdb) undisplay 1</td>
</tr>
<tr>
<td>i</td>
<td>Info的简写，用于显示各类信息，详情请查阅“help i”。</td>
<td>(gdb) i r</td>
</tr>
<tr>
<td>q</td>
<td>Quit的简写，退出GDB调试环境。</td>
<td>(gdb) q</td>
</tr>
<tr>
<td>help [命令名称]</td>
<td>GDB帮助命令，提供对GDB名种命令的解释说明。 如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</td>
<td>(gdb) help display</td>
</tr>
</tbody></table>
<h3 id="o文件是二进制文件"><a href="#o文件是二进制文件" class="headerlink" title=".o文件是二进制文件"></a>.o文件是二进制文件</h3><h2 id="雨课堂题目整理"><a href="#雨课堂题目整理" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143002794.png" alt="image-20210618143002794"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143011579.png" alt="image-20210618143011579"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143019456.png" alt="image-20210618143019456"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143027894.png" alt="image-20210618143027894"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143042533.png" alt="image-20210618143042533"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143052676.png" alt="image-20210618143052676"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143100984.png" alt="image-20210618143100984"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143111912.png" alt="image-20210618143111912"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143125572.png" alt="image-20210618143125572"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143147555.png" alt="image-20210618143147555"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143155638.png" alt="image-20210618143155638"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143205552.png" alt="image-20210618143205552"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143219860.png" alt="image-20210618143219860"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143233469.png" alt="image-20210618143233469"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143245888.png" alt="image-20210618143245888"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143254740.png" alt="image-20210618143254740"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143302040.png" alt="image-20210618143302040"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143310814.png" alt="image-20210618143310814"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143333036.png" alt="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143340720.png" alt="image-20210618143340720"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143348878.png" alt="image-20210618143348878"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143404564.png" alt="image-20210618143404564"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143416361.png" alt="image-20210618143416361"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143424721.png" alt="image-20210618143424721"></p>
<h1 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h1><h2 id="1-1-文件属性"><a href="#1-1-文件属性" class="headerlink" title="1.1 文件属性"></a><strong>1.1</strong> <strong>文件属性</strong></h2><ol>
<li>文件属性数据结构<strong>struct stat <strong>——</strong>文件控制块</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="keyword">mode_t</span> st_mode;   <span class="comment">/*file type &amp; mode*/</span></span><br><span class="line">  <span class="keyword">ino_t</span>   st_ino;     <span class="comment">/*inode number (serial number)*/</span></span><br><span class="line">  <span class="keyword">dev_t</span>  st_rdev;    <span class="comment">/*device number (file system)*/</span> </span><br><span class="line">  <span class="keyword">nlink_t</span>  st_nlink;    <span class="comment">/*link count*/</span></span><br><span class="line">  <span class="keyword">uid_t</span>   st_uid;     <span class="comment">/*user ID of owner*/</span></span><br><span class="line">  <span class="keyword">gid_t</span>   st_gid;     <span class="comment">/*group ID of owner*/</span></span><br><span class="line">  <span class="keyword">off_t</span>   st_size;     <span class="comment">/*size of file, in bytes*/</span></span><br><span class="line">  <span class="keyword">time_t</span>  st_atime;    <span class="comment">/*time of last access*/</span></span><br><span class="line">  <span class="keyword">time_t</span>  st_mtime;   <span class="comment">/*time of last modification*/</span></span><br><span class="line">  <span class="keyword">time_t</span>  st_ctime;    <span class="comment">/*time of lat file status change*/</span></span><br><span class="line">  <span class="keyword">long</span>   st_blksize;   <span class="comment">/*Optimal block size for I/O*/</span></span><br><span class="line">  <span class="keyword">long</span>   st_blocks;   <span class="comment">/*number 512-byte blocks allocated*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>命令查看：</strong>ls -l file</p>
<ol start="2">
<li>stat/fstat/lstat<strong>函数</strong></li>
</ol>
<p>获取文件属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, struct stat *buf)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-文件类型"><a href="#1-2-文件类型" class="headerlink" title="1.2 文件类型"></a><strong>1.2</strong> <strong>文件类型</strong></h2><h3 id="1-文件类型"><a href="#1-文件类型" class="headerlink" title="**1.**文件类型"></a>**1.**文件类型</h3><p>Unix/Linux系统支持的文件类型：</p>
<ul>
<li>Directory(d):目录文件</li>
<li>Link(l):链接文件</li>
<li>Pipe(p):管道文件</li>
<li>Block Device(b):块设备文件</li>
<li>Character Device(c):字符设备文件</li>
<li>Regular(-):普通文件</li>
<li>Socket(s):套接字文件</li>
</ul>
<p><strong>查看文件类型</strong></p>
<p><strong>使用命令：</strong>ls –l /dev/sda1</p>
<h4 id="例2-1设计一个程序，要求列出当前目录下的文件信息，以及系统“-dev-sda1”和“-dev-lp0”的文件信息。"><a href="#例2-1设计一个程序，要求列出当前目录下的文件信息，以及系统“-dev-sda1”和“-dev-lp0”的文件信息。" class="headerlink" title="例2.1设计一个程序，要求列出当前目录下的文件信息，以及系统“/dev/sda1”和“/dev/lp0”的文件信息。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-1.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-1.c">2.1</a>设计一个程序，要求列出当前目录下的文件信息，以及系统“/dev/sda1”和“/dev/lp0”的文件信息。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>	                </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>                  	<span class="comment">/*文件预处理，包含system函数库*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> newret;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列出当前目录下的文件信息：\n&quot;</span>); </span><br><span class="line">	newret=system(<span class="string">&quot;ls -l&quot;</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列出\&quot;dev/sda1\&quot;的文件信息：\n&quot;</span>); </span><br><span class="line">	newret=system(<span class="string">&quot;ls /dev/sda1 -l&quot;</span>);	<span class="comment">/*列出“/dev/sda1”的文件信息*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;列出\&quot;dev/ lp0\&quot;的文件信息：\n&quot;</span>); </span><br><span class="line">	newret=system(<span class="string">&quot;ls /dev/lp0 -l&quot;</span>);      	<span class="comment">/*列出“/dev/ lp0”的文件信息*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-获取文件类型"><a href="#2-获取文件类型" class="headerlink" title="**2.**获取文件类型"></a>**2.**获取文件类型</h3><p>st_mode存储文件类型和许可权限，形式如下：<br> <strong>type3  type2  type1  type0</strong>  <strong>suid</strong>  <strong>sgid</strong>  <strong>sticky</strong>  <strong>rwx</strong>  <strong>rwx</strong>  <strong>rwx</strong></p>
<p><strong>用来确定文件类型的宏</strong>：<br> S_ISBLK – 测试块文件<br> S_ISCHR –　测试字符文件<br> S_ISDIR –　测试目录<br> S_ISFIFO –　测试FIFO<br> S_ISREG – 测试普通文件<br> S_ISLNK – 测试符号链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> i;  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span>  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;argc;i++)    </span><br><span class="line">  &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s:&quot;</span>,argv[i]);    </span><br><span class="line">    <span class="keyword">if</span>(lstat(argv[i],&amp;statbuf)==<span class="number">-1</span>)  &#123;  <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);  <span class="keyword">continue</span>;  &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(statbuf.st_mode))          <span class="built_in">printf</span>(<span class="string">&quot;%s is a directory\n&quot;</span>,argv[i]);</span><br><span class="line">    <span class="keyword">else</span>      <span class="keyword">if</span>(S_ISREG(statbuf.st_mode))        <span class="built_in">printf</span>(<span class="string">&quot;%s is a regular file\n&quot;</span>,argv[i]);</span><br><span class="line">      <span class="keyword">else</span>    <span class="keyword">if</span>(S_ISBLK(statbuf.st_mode))         <span class="built_in">printf</span>(<span class="string">&quot;%s is a block device\n&quot;</span>,argv[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>(S_ISCHR(statbuf.st_mode))        <span class="built_in">printf</span>(<span class="string">&quot;%s is a charcter device\n&quot;</span>,argv[i]); </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> S_ISLNK        </span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(statbuf.st_mode))      <span class="built_in">printf</span>(<span class="string">&quot;%s is a link file\n&quot;</span>,argv[i]);</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">ifdef</span> S_ISSOCK       </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(statbuf.st_mode))     <span class="built_in">printf</span>(<span class="string">&quot;%s is a socket \n&quot;</span>,argv[i]);</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">         <span class="keyword">else</span>          <span class="built_in">printf</span>(<span class="string">&quot;%s is an unknown type file \n&quot;</span>,argv[i]);     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611162747182.png" alt="image-20210611162747182"></p>
<h2 id="1-3-文件存取权限"><a href="#1-3-文件存取权限" class="headerlink" title="1.3 文件存取权限"></a><strong>1.3</strong> <strong>文件存取权限</strong></h2><h4 id="1-文件存取权限"><a href="#1-文件存取权限" class="headerlink" title="**1.**文件存取权限"></a>**1.**文件存取权限</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611162858324.png" alt="image-20210611162858324"></p>
<p>读的权限：显示目录文件，进入目录</p>
<p>写的权限：目录下创建文件</p>
<p>执行的权限：显示目录文件，进入目录，创建文件</p>
<h4 id="2-改变文件存取权限——命令"><a href="#2-改变文件存取权限——命令" class="headerlink" title="**2.**改变文件存取权限——命令"></a>**2.**改变文件存取权限——命令</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611163120067.png" alt="image-20210611163120067"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611163125022.png" alt="image-20210611163125022"></p>
<h4 id="例2-3-设计一个程序，要求把系统中“-home-mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。"><a href="#例2-3-设计一个程序，要求把系统中“-home-mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。" class="headerlink" title="例2.3 设计一个程序，要求把系统中“/home/mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-2.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-2.c">2.3 </a>设计一个程序，要求把系统中“/home/mylinux目录下的myfile文件权限，设置成文件所有者可读可写，其他用户只读权限。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>       </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chmod(<span class="string">&quot;/home/mylinux/myfile&quot;</span>,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chmod 函数</span><br><span class="line">Change permissions of a file</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">// 打开的文件</span></span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="3-改变文件存取权限"><a href="#3-改变文件存取权限" class="headerlink" title="3. 改变文件存取权限"></a><strong>3. 改变文件存取权限</strong></h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611163410933.png" alt="image-20210611163410933"></p>
<h4 id="4-默认文件存取权限——umask"><a href="#4-默认文件存取权限——umask" class="headerlink" title="4. 默认文件存取权限——umask"></a><strong>4. 默认文件存取权限</strong>——umask</h4><p>新创建的文件和目录的默认权限是(root)</p>
<p>File:     -rw-r–r–  644</p>
<p>Directory: drwxr-xr-x 755</p>
<p>Why?</p>
<p>umask: 包含未被设置为权限位的==八进制数字(即无x位（可执行位）)==。默认002为普通用户，022为root用户。666-644=022</p>
<h4 id="例2-4-设计一程序，要求设置系统文件和目录的权限掩码。"><a href="#例2-4-设计一程序，要求设置系统文件和目录的权限掩码。" class="headerlink" title="例2.4 设计一程序，要求设置系统文件和目录的权限掩码。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-3_umask.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/2-3_umask.c">2.4 </a>设计一程序，要求设置系统文件和目录的权限掩码。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">mode_t</span> new_umask,old_umask;</span><br><span class="line">	new_umask=<span class="number">0666</span>;</span><br><span class="line">	old_umask=umask(new_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统原来的权限掩码是：%o\n&quot;</span>,old_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统新的权限掩码是：%o\n&quot;</span>,new_umask);</span><br><span class="line">	system(<span class="string">&quot;touch liu1&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建了文件liu1\n&quot;</span>);</span><br><span class="line">	new_umask=<span class="number">0444</span>;</span><br><span class="line">	old_umask=umask(new_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统原来的权限掩码是：%o\n&quot;</span>,old_umask);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;系统新的权限掩码是：%o\n&quot;</span>,new_umask);</span><br><span class="line">	system(<span class="string">&quot;touch liu2&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建了文件liu2\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls liu1 liu2 -l&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">umask 函数</span><br><span class="line">为进程设置文件存取权限屏蔽字，并返回以前的值</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> mask)</span></span>;</span><br><span class="line">建立文件，文件的权限为<span class="number">0666</span>-mask；</span><br><span class="line">建立目录，目录权限为<span class="number">0777</span>-mask。</span><br></pre></td></tr></table></figure>

<h2 id="1-4-文件其他属性"><a href="#1-4-文件其他属性" class="headerlink" title="1.4 文件其他属性"></a><strong>1.4</strong> <strong>文件其他属性</strong></h2><h3 id="1-chown-fchown-lchown-函数"><a href="#1-chown-fchown-lchown-函数" class="headerlink" title="**1.chown/fchown/**lchown 函数"></a>**1.chown/<strong>fchown</strong>/**lchown <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">改变文件所有者</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h3 id="2-获取文件存取时间——stat"><a href="#2-获取文件存取时间——stat" class="headerlink" title="2.获取文件存取时间——stat"></a><strong>2.<strong>获取文件存取时间</strong>——stat</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">char</span> *path=<span class="string">&quot;./2-5.c&quot;</span>;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"> <span class="keyword">if</span> (stat(path,&amp;statbuf)==<span class="number">-1</span>)</span><br><span class="line">   perror(<span class="string">&quot;Failed to get file status&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%s last accessed at %s&quot;</span>,path,ctime(&amp;statbuf.st_atime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-获取文件大小——stat"><a href="#3-获取文件大小——stat" class="headerlink" title="**3.**获取文件大小——stat"></a>**3.**获取文件大小——stat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>		</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span>     	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                 	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">	stat(<span class="string">&quot;/etc/passwd&quot;</span>,&amp;buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\&quot;/etc/passwd\&quot;文件的大小是：%d\n&quot;</span>,buf.st_size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-1-两种I-O方式"><a href="#2-1-两种I-O方式" class="headerlink" title="2.1 两种I/O方式"></a><strong>2.1</strong> <strong>两种</strong>I/O<strong>方式</strong></h2><h3 id="1-无缓冲和缓冲I-O"><a href="#1-无缓冲和缓冲I-O" class="headerlink" title="1. 无缓冲和缓冲I/O"></a><strong>1.</strong> <strong>无缓冲和缓冲</strong>I/O</h3><h4 id="无缓冲I-O"><a href="#无缓冲I-O" class="headerlink" title="无缓冲I/O"></a>无缓冲I/O</h4><ul>
<li>read/write -&gt;系统函数</li>
<li>文件描述符</li>
<li>POSIX.1 and XPG3标准</li>
</ul>
<h4 id="缓冲-I-O"><a href="#缓冲-I-O" class="headerlink" title="缓冲 I/O"></a>缓冲 I/O</h4><ol>
<li>标准I/O库实现</li>
<li>处理很多细节, 如缓存分配, 以优化长度执行I/O等.</li>
<li>流 -&gt; FILE类型指针</li>
</ol>
<h3 id="2-无缓冲-I-O-系统调用"><a href="#2-无缓冲-I-O-系统调用" class="headerlink" title="**2.**无缓冲 I/O 系统调用"></a>**2.**无缓冲 <strong>I/O</strong> <strong>系统调用</strong></h3><p>基本 I/O</p>
<ul>
<li>open/creat, close, read, write, lseek</li>
<li>dup/dup2</li>
<li>fcntl</li>
</ul>
<h2 id="2-2-文件描述符"><a href="#2-2-文件描述符" class="headerlink" title="2.2 文件描述符"></a><strong>2.2</strong> <strong>文件描述符</strong></h2><h3 id="1-文件描述符概述"><a href="#1-文件描述符概述" class="headerlink" title="1.文件描述符概述"></a><strong>1.文件描述符概述</strong></h3><p>非负整数</p>
<p>​    int fd;</p>
<p>​        (in &lt;unistd.h&gt;)</p>
<p>​    STDIN_FILENO (0), STDOUT_FILENO (1), STDERR_FILENO (2)</p>
<p>文件操作一般步骤：</p>
<p>   open-read/write-[lseek]-close</p>
<h3 id="2-进程打开文件的内核数据结构"><a href="#2-进程打开文件的内核数据结构" class="headerlink" title="2. 进程打开文件的内核数据结构"></a><strong>2.</strong> <strong>进程打开文件的内核数据结构</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170650485.png" alt="image-20210611170650485"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170732113.png" alt="image-20210611170732113"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170743253.png" alt="image-20210611170743253"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170755032.png" alt="image-20210611170755032"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170805503.png" alt="image-20210611170805503"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170815361.png" alt="image-20210611170815361"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170829150.png" alt="image-20210611170829150"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170853877.png" alt="image-20210611170853877"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170909100.png" alt="image-20210611170909100"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170919482.png" alt="image-20210611170919482"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611170928977.png" alt="image-20210611170928977"></p>
<h2 id="2-3-无缓冲-I-O函数"><a href="#2-3-无缓冲-I-O函数" class="headerlink" title="2.3 无缓冲 I/O函数"></a><strong>2.3</strong> <strong>无缓冲</strong> <strong>I/O</strong>函数</h2><h3 id="0-错误处理"><a href="#0-错误处理" class="headerlink" title="**0.**错误处理"></a>**0.**错误处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UNIX方式</span><br><span class="line">Return value</span><br><span class="line">“errno”变量( defined in /usr/include/errno.h)</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br><span class="line"></span><br><span class="line">strerror &amp; perror</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-creat-函数"><a href="#1-creat-函数" class="headerlink" title="1. creat 函数"></a><strong>1.</strong> <strong>creat</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create a file <span class="keyword">or</span> device </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">(Return: a <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="例2-7-设计一程序，要求在“-home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。"><a href="#例2-7-设计一程序，要求在“-home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。" class="headerlink" title="例2.7 **设计一程序，要求在“/**home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-5.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-5.c">2.7</a> **设计一程序，要求在“/**home”目录下创建一个名称为“2-7file”的文件，并且把此文件的权限设置为所有者具有只读权限，最后显示此文件的信息。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	fd=creat(<span class="string">&quot;./2-7file&quot;</span>,S_IRUSR); </span><br><span class="line">	system(<span class="string">&quot;ls ./2-7file -l&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数-“mode”"><a href="#参数-“mode”" class="headerlink" title="参数 “mode”"></a><strong>参数</strong> <strong>“</strong>mode”</h4><p>“mode”: 指定创建的新文件的存取权限</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611171422005.png" alt="image-20210611171422005"></p>
<h4 id="参数-“mode”-amp-umask"><a href="#参数-“mode”-amp-umask" class="headerlink" title="参数 “mode” &amp; umask"></a><strong>参数</strong> “<strong>mode</strong>” <strong>&amp;</strong> <strong>umask</strong></h4><p>umask: 一种文件保护机制</p>
<p>新建文件的初始存取权限</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611171522883.png" alt="image-20210611171522883"></p>
<h3 id="2-Open-函数"><a href="#2-Open-函数" class="headerlink" title="2. Open 函数"></a><strong>2. Open</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Open <span class="keyword">and</span> possibly create a file <span class="keyword">or</span> device </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>; </span><br><span class="line">(Return: a <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="例2-8设计一个程序，要求在当前目录下以可读写方式打开一个名为“2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。"><a href="#例2-8设计一个程序，要求在当前目录下以可读写方式打开一个名为“2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。" class="headerlink" title="例2.8设计一个程序，要求在当前目录下以可读写方式打开一个名为“2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-6.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-6.c">2.8</a><strong>设计一个程序，要求在当前目录下以可读写方式打开一个名为“</strong>2-8file”的文件。如果该文件不存在，则创建此文件；如果存在，将文件清空后关闭。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span>        	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span>         	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                 	 </span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">if</span>((fd=open(<span class="string">&quot;./2-8file&quot;</span>,O_CREAT|O_TRUNC|O_WRONLY,<span class="number">0600</span>))&lt;<span class="number">0</span>)</span><br><span class="line">	  &#123; 	perror(<span class="string">&quot;打开文件出错&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;	<span class="built_in">printf</span>(<span class="string">&quot;打开(创建)文件\&quot;2-8file\&quot;，文件描述符为：%d\n&quot;</span>,fd);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span>(close(fd)&lt;<span class="number">0</span>)</span><br><span class="line">	  &#123;	perror(<span class="string">&quot;关闭文件出错&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	system(<span class="string">&quot;ls ./2-8file -l&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数-“flags”"><a href="#参数-“flags”" class="headerlink" title="参数 “flags”"></a><strong>参数</strong> <strong>“</strong>flags<strong>”</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“flags”: 指定文件存取方式</span><br><span class="line">One of O_RDONLY, O_WRONLY <span class="keyword">or</span> O_RDWR which request opening the file read-only, write-only <span class="keyword">or</span> read/write, respectively, bitwise-<span class="keyword">or</span>’d with zero <span class="keyword">or</span> more of the following: ( All defined in /usr/include/fcntl.h)</span><br><span class="line">O_APPEND: 追加方式打开</span><br><span class="line">O_TRUNC:文件存在清空</span><br><span class="line">O_CREAT: 文件不存在创建.</span><br><span class="line">O_EXCL: 和 O_CREAT一起用时, 文件存在则出错，打开失败</span><br><span class="line">…</span><br><span class="line">“creat” function: 等价于open函数中指定 O_CREAT|O_WRONLY|O_TRUNC</span><br></pre></td></tr></table></figure>

<h3 id="3-close-函数"><a href="#3-close-函数" class="headerlink" title="3. close 函数"></a><strong>3. close</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Close a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h3 id="4-read-write-函数"><a href="#4-read-write-函数" class="headerlink" title="4. read/write 函数"></a><strong>4. read/write</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Read from a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line">(返回值: 读到的字节数，若已到文件尾为<span class="number">0</span>，若出错为<span class="number">-1</span>)</span><br><span class="line">Write to a file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line">(返回值: 若成功为已写的字节数，若出错为<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="例2-9设计一个程序，完成文件的复制工作。要求通过read函数和write函数复制“-etc-passwd”文件到目标文件中，目标文件名在程序运行时从键盘输入。"><a href="#例2-9设计一个程序，完成文件的复制工作。要求通过read函数和write函数复制“-etc-passwd”文件到目标文件中，目标文件名在程序运行时从键盘输入。" class="headerlink" title="例2.9设计一个程序，完成文件的复制工作。要求通过read函数和write函数复制“/etc/passwd”文件到目标文件中，目标文件名在程序运行时从键盘输入。"></a><strong>例</strong>2.9<strong>设计一个程序，完成文件的复制工作。要求通过</strong>read<strong>函数和</strong>write<strong>函数复制“/<strong>etc/passwd”</strong>文件到目标文件中，目标文件名在程序运行时从键盘输入。</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> fdsrc,fddes,nbytes; <span class="keyword">int</span> z; <span class="keyword">char</span> buf[<span class="number">20</span>], des[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> flags=O_CREAT | O_TRUNC | O_WRONLY;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入目标文件名:&quot;</span>);	</span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,des);                 		</span><br><span class="line">	fdsrc=open(<span class="string">&quot;/etc/passwd&quot;</span>,O_RDONLY);	</span><br><span class="line">	<span class="keyword">if</span>(fdsrc&lt;<span class="number">0</span>)	&#123;	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	fddes=open(des,flags,<span class="number">0644</span>);         	</span><br><span class="line">	<span class="keyword">if</span>(fddes&lt;<span class="number">0</span>)	&#123;	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">while</span>((nbytes=read(fdsrc,buf,<span class="number">20</span>))&gt;<span class="number">0</span>)</span><br><span class="line">	   &#123;	z=write(fddes,buf,nbytes);</span><br><span class="line">	<span class="keyword">if</span>(z&lt;<span class="number">0</span>)	&#123;	perror(<span class="string">&quot;写目标文件出错&quot;</span>);	&#125;	&#125;</span><br><span class="line">	close(fddes);</span><br><span class="line">	close(fdsrc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;复制\&quot;/etc/passwd\&quot;文件为\&quot;%s\&quot;文件成功！\n&quot;</span>,des);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-lseek-函数"><a href="#5-lseek-函数" class="headerlink" title="5. lseek 函数"></a><strong>5.</strong> <strong>lseek</strong> <strong>函数</strong></h3><p>read/write 定位文件指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line">(Return: the resulting offset location <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<p>该指令的“那里”:</p>
<p>​    SEEK_SET: the offset is set to “offset” bytes指针位移量为设定值</p>
<p>​    SEEK_CUR: the offset is set to its current location plus “offset” bytes指针位移量为当前位移加设定值</p>
<p>​    SEEK_END: the offset is set to the size of the file plus “offset” bytes指针位移量为文件尾加设定值</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213210597.png" alt="image-20210611213210597"></p>
<h4 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a><strong>空洞文件</strong></h4><p>使用lseek修改文件偏移量后，当前文件偏移量有可能大于文件的长度</p>
<p>在这种情况下，对该文件的下一次写操作，将加长该文件</p>
<p>这样文件中形成了一个空洞。对空洞区域进行读，均返回0</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213233714.png" alt="image-20210611213233714"></p>
<h3 id="6-dup-dup2-函数"><a href="#6-dup-dup2-函数" class="headerlink" title="6. dup/dup2 函数"></a><strong>6. dup/dup2</strong> <strong>函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制文件描述符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">(Return: the <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213303221.png" alt="image-20210611213303221"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213316880.png" alt="image-20210611213316880"></p>
<p>假设进程已打开文件描述符0、1、2</p>
<p>调用dup2(1, 6)，dup2返回值是多少？</p>
<p>然后再调用dup(6)，dup返回值是多少？</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213407986.png" alt="image-20210611213407986"></p>
<p><strong><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213417786.png" alt="image-20210611213417786"></strong></p>
<h3 id="7-fcntl函数"><a href="#7-fcntl函数" class="headerlink" title="7. fcntl函数"></a><strong>7.</strong> <strong>fcntl</strong>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看、修改打开的文件描述符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> result=fcntl(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd);</span><br><span class="line"><span class="keyword">int</span> result=fcntl(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,<span class="keyword">long</span> arg,…);</span><br></pre></td></tr></table></figure>

<p>lcmd取值：</p>
<p>F_DUPFD 复制文件描述符</p>
<p>F_GETFD 获得文件描述符</p>
<p>F_SETFD 设置文件描述符</p>
<p>F_GETFL 获取文件描述符当前模式</p>
<p>F_SETFL设置文件描述符当前模式</p>
<p>F_GETLK 获得记录锁</p>
<p>F_SETLK 设置记录锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">分析以下程序运行情况</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf1[]=<span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> buf2[]=<span class="string">&quot;ABCDEFGHEIJ&quot;</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;<span class="keyword">int</span> fd;</span><br><span class="line"> <span class="keyword">if</span>((fd=open(<span class="string">&quot;file.hole&quot;</span>,O_WRONLY|O_CREAT<span class="comment">/*|O_APPEND*/</span>,<span class="number">0644</span>))&lt;<span class="number">0</span>) </span><br><span class="line">    perror(<span class="string">&quot;creat error&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(write(fd,buf1,<span class="number">10</span>)!=<span class="number">10</span>)</span><br><span class="line">   perror(<span class="string">&quot;buf1 write error&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(lseek(fd,<span class="number">40</span>,SEEK_SET)==<span class="number">-1</span>) </span><br><span class="line">   perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(write(fd,buf2,<span class="number">10</span>)!=<span class="number">10</span>)</span><br><span class="line">   perror(<span class="string">&quot;buf2 write error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">（<span class="number">1</span>）ls –l 查看文件大小多少字节？</span><br><span class="line">（<span class="number">2</span>）cat 查看文件内容？</span><br><span class="line">（<span class="number">3</span>）od –c 查看文件内容</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">分析以下程序运行结果</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">if</span>((fd=open(<span class="string">&quot;myout&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>))==<span class="number">-1</span>)</span><br><span class="line">   perror(<span class="string">&quot;myout open error&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(dup2(fd,STDOUT_FILENO)==<span class="number">-1</span>)</span><br><span class="line">   perror(<span class="string">&quot;redirect stand output failed&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this is a test program for redirect\n&quot;</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line">（<span class="number">1</span>）查看程序运行结果？</span><br><span class="line">（<span class="number">2</span>）cat 查看文件myout的内容</span><br></pre></td></tr></table></figure>

<h2 id="3-1-标准I-O库"><a href="#3-1-标准I-O库" class="headerlink" title="3.1 标准I/O库"></a><strong>3.1</strong> <strong>标准</strong>I/O<strong>库</strong></h2><p>为什么要设计标准I/O库？</p>
<p>​    直接使用API进行文件访问时，需要考虑许多细节问题</p>
<p>​    例如：read、write时，缓冲区的大小该如何确定，才能使效率最优</p>
<p>标准I/O库封装了诸多细节问题，包括缓冲区分配</p>
<p>I/O效率示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">  <span class="keyword">while</span>((n = read(STDIN_FILENO, buf, BUFFSIZE))&gt;<span class="number">0</span>)       </span><br><span class="line">     <span class="keyword">if</span>(write(STDOUT_FILENO, buf,n)!= n)                   </span><br><span class="line">       perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序中，影响效率的关键：BUFFSIZE的取值</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611213732273.png" alt="image-20210611213732273"></p>
<p>原因</p>
<ul>
<li>Linux文件系统采用了某种预读技术</li>
<li>当检测到正在进行顺序读取时，系统就试图读入比应用程序所要求的更多数据</li>
<li>并假设应用程序很快就会读这些数据</li>
<li>当BUFFSIZE增加到一定程度后，预读就停止了</li>
</ul>
<h3 id="标准-I-O-缓冲"><a href="#标准-I-O-缓冲" class="headerlink" title="标准 I/O 缓冲"></a><strong>标准</strong> <strong>I/O</strong> <strong>缓冲</strong></h3><p>标准I/O库提供缓冲的目的：尽可能减少使用read、write调用的次数，以提高I/O效率。</p>
<p>通过标准I/O库进行的读写操作，数据都会被放置在标准I/O库缓冲中中转。</p>
<h2 id="3-2-文件流"><a href="#3-2-文件流" class="headerlink" title="3.2 文件流"></a><strong>3.2</strong> <strong>文件流</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">..............................        </span><br><span class="line"><span class="keyword">char</span>            fd;                        <span class="comment">/* File descriptor      */</span></span><br><span class="line"><span class="keyword">short</span>           bsize;                  <span class="comment">/* Buffer size          */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>   *buffer;        <span class="comment">/* Data transfer buffer */</span></span><br><span class="line">....................................</span><br><span class="line">&#125;       FILE;     </span><br><span class="line">标准I/O库</span><br><span class="line">管理的缓冲区</span><br></pre></td></tr></table></figure>

<h2 id="3-3-标准-I-O-函数"><a href="#3-3-标准-I-O-函数" class="headerlink" title="3.3 标准 I/O 函数"></a><strong>3.3</strong> <strong>标准</strong> <strong>I/O</strong> <strong>函数</strong></h2><ul>
<li>流 open/close</li>
<li>流 read/write<ul>
<li>​    每次一个字符的I/O：fgetc,fputc</li>
<li>​    每次一行的I/O: fgets,fputs,gets,puts</li>
<li>​    直接I/O(二进制I/O): fread,fwrite</li>
<li>​    格式化I/O:scanf,printf,fscanf,fprintf</li>
</ul>
</li>
<li>流定位:fseek,ftell,frewind</li>
<li>流刷新:fflush</li>
</ul>
<h3 id="1-流打开-关闭"><a href="#1-流打开-关闭" class="headerlink" title="1. 流打开/关闭"></a><strong>1.</strong> <strong>流打开</strong>/<strong>关闭</strong></h3><h4 id="例2-10设计一个程序，要求用流文件I-O操作打开文件“2-10file”-如果该文件不存在，则创建文件。"><a href="#例2-10设计一个程序，要求用流文件I-O操作打开文件“2-10file”-如果该文件不存在，则创建文件。" class="headerlink" title="例2.10设计一个程序，要求用流文件I/O操作打开文件“2-10file”,如果该文件不存在，则创建文件。"></a><strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-9.c">例</a></strong><a href="file:///F:/我的2013/201303上课_Unix程序设计/PPT/example/ch2/4-9.c">2.10</a><strong>设计一个程序，要求用流文件</strong>I/O<strong>操作打开文件“</strong>2-10file”,如果该文件不存在，则创建文件。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE * fp;                                 		</span><br><span class="line">	<span class="keyword">if</span>((fp=fopen(<span class="string">&quot;./2-10file&quot;</span>,<span class="string">&quot;a+&quot;</span>))==<span class="literal">NULL</span>)       	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开(创建)文件出错&quot;</span>);      	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);                                 		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Open a stream</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line">Parameter “mode”</span><br><span class="line">“r”:  	Open text file <span class="keyword">for</span> reading.</span><br><span class="line">“w”: Truncate file to zero length <span class="keyword">or</span> create text file <span class="keyword">for</span> writing.</span><br><span class="line">“a”: 	Open <span class="keyword">for</span> appending.</span><br><span class="line">“r+”: Open <span class="keyword">for</span> reading <span class="keyword">and</span> writing.</span><br><span class="line">“w+”: Open <span class="keyword">for</span> reading <span class="keyword">and</span> writing. The file is created <span class="keyword">if</span> it does <span class="keyword">not</span> exist, otherwise it is truncated.</span><br><span class="line">“a+”: Open <span class="keyword">for</span> reading <span class="keyword">and</span> appending. The file is created <span class="keyword">if</span> does <span class="keyword">not</span> exist.</span><br><span class="line">    </span><br><span class="line">Close a stream</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-流读-写"><a href="#2-流读-写" class="headerlink" title="**2.流读/**写"></a>**2.<strong>流读</strong>/**写</h3><p>对流有三种读写方式</p>
<ul>
<li><p>每次读写一个字符</p>
</li>
<li><p>每次读写一行</p>
</li>
<li><p>每次读写任意长度的内容</p>
</li>
</ul>
<h4 id="（1）输入-出一个字符"><a href="#（1）输入-出一个字符" class="headerlink" title="（1）输入/出一个字符"></a><strong>（</strong>1<strong>）输入/出一个字符</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">输出</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line">(Return: the character <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure>

<h4 id="（2）-输入-出一行"><a href="#（2）-输入-出一行" class="headerlink" title="（2） 输入/出一行"></a>（2） 输入/出一行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="（3）-二进制流输入-输出"><a href="#（3）-二进制流输入-输出" class="headerlink" title="（3） 二进制流输入/输出"></a>（3） 二进制流输入/输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="function">size <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line">(Return: the number of a items successfully read <span class="keyword">or</span> written.)</span><br></pre></td></tr></table></figure>

<h4 id="例2-11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I-O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。"><a href="#例2-11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I-O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。" class="headerlink" title="例2.11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I/O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。"></a>例2.11设计两个程序，要求一个程序把三个人的姓名和账号余额信息通过一次流文件I/O操作写入文件“2-11file”，另一个格式输出账号信息，把每个人的账号和余额一一对应显示输出。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序：把帐号信息从文件读出*/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmemb 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>						 </span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> pay;</span><br><span class="line">&#125;s[nmemb];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;	FILE * fp;              		</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	fp = fopen(<span class="string">&quot;2-11file&quot;</span>, <span class="string">&quot;r&quot;</span>);	</span><br><span class="line">	fread(s,<span class="keyword">sizeof</span>(struct test),nmemb,fp); </span><br><span class="line">	fclose(fp);                  			 </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nmemb;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;帐号[%d]:%-20s余额[%d]:%d\n&quot;</span>,i,s[i].name,i,s[i].pay);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*程序：把帐号信息写入文件*/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_s(x,y,z) &#123;strcpy(s[x].name,y);s[x].pay=z;&#125;   <span class="comment">/*自定义宏，用于赋值*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmemb 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>                     	 </span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> pay;</span><br><span class="line">&#125;s[nmemb];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	FILE * fp;                   	</span><br><span class="line">	set_s(<span class="number">0</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">12345</span>);</span><br><span class="line">	set_s(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">200</span>);</span><br><span class="line">	set_s(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>,<span class="number">50000</span>);</span><br><span class="line">	fp=fopen(<span class="string">&quot;2-11file&quot;</span>,<span class="string">&quot;a+&quot;</span>);	<span class="comment">/*打开(创建)文件*/</span></span><br><span class="line">	fwrite(s,<span class="keyword">sizeof</span>(struct test),nmemb,fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;                    	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）-格式化-I-O"><a href="#（4）-格式化-I-O" class="headerlink" title="（4） 格式化 I/O"></a>（4） 格式化 I/O</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-流定位"><a href="#3-流定位" class="headerlink" title="3.流定位"></a>3.流定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="例2-12-设计一程序，要求用fopen函数打开系统文件“-etc-passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。"><a href="#例2-12-设计一程序，要求用fopen函数打开系统文件“-etc-passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。" class="headerlink" title="例2.12 设计一程序，要求用fopen函数打开系统文件“/etc/passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。"></a>例2.12 设计一程序，要求用fopen函数打开系统文件“/etc/passwd”，先把位置指针移动到第10个字符前，再把位置指针移动到文件尾，最后把位置指针移动到文件头，输出三次定位的文件偏移量的值。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *stream;</span><br><span class="line">	<span class="keyword">long</span> offset;</span><br><span class="line">	<span class="keyword">fpos_t</span> pos;</span><br><span class="line">	stream=fopen(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	fseek(stream,<span class="number">10</span>,SEEK_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件流的偏移量：%d\n&quot;</span>,ftell(stream));</span><br><span class="line">	fseek(stream,<span class="number">0</span>,SEEK_END);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件流的偏移量：%d\n&quot;</span>,ftell(stream));</span><br><span class="line">	rewind(stream);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件流的偏移量：%d\n&quot;</span>,ftell(stream));</span><br><span class="line">	fclose(stream);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210617212155113.png" alt="image-20210617212155113"></p>
<h3 id="4-流刷新"><a href="#4-流刷新" class="headerlink" title="4. 流刷新"></a>4. 流刷新</h3><p>刷新文件流。把流里的数据立刻写入文件—fork前使用fflush<br>#include &lt;stdio.h&gt;<br>int fflush(FILE *stream);</p>
<p>自动刷新：</p>
<ul>
<li>流关闭fclose；</li>
<li>exit终止；</li>
<li>行缓冲“\n”；</li>
<li>缓冲区满；</li>
<li>执行输入操作读文件:printf（“hello”）;scanf（“%d”,&amp;a）</li>
</ul>
<h3 id="5-流缓冲"><a href="#5-流缓冲" class="headerlink" title="5. 流缓冲"></a>5. 流缓冲</h3><ul>
<li>三种类型的缓冲</li>
<li>块（全）缓冲block buffered (fully buffered)：一般C库函数写入文件是全缓冲的</li>
<li>行缓冲line buffered:引用标准交互设备的流stdin,stdout<pre><code>例：    for(i=1;i&lt;=10;i++) fputc(c,stdout);
           fputc(&quot;\n&quot;,stdout);
</code></pre>
</li>
<li>无缓冲Unbuffered：标准错误流stderr</li>
</ul>
<p>全缓冲</p>
<ul>
<li>在填满标准I/O缓冲区后，才进行实际I/O操作（例如调用write函数）</li>
<li>调用fflush函数也能强制进行实际I/O操作</li>
</ul>
<p>行缓冲</p>
<ul>
<li>在输入和输出遇到换行符时，标准I/O库执行I/O操作</li>
<li>因为标准I/O库用来收集每一行的缓存的长度是固定的，所以，只要填满了缓存，即使没有遇到新行符，也进行I/O操作</li>
<li>终端（例如标准输入和标准输出），使用行缓冲</li>
</ul>
<p>不带缓冲</p>
<ul>
<li>标准I/O库不对字符进行缓冲存储</li>
<li>标准出错是不带缓冲的，为了让出错信息尽快显示出来</li>
</ul>
<h3 id="6-流和文件描述符"><a href="#6-流和文件描述符" class="headerlink" title="6. 流和文件描述符"></a>6. <strong>流和文件描述符</strong></h3><p>确定流使用的底层文件描述符<br>#include &lt;stdio.h&gt;<br>int fileno(FILE *fp);<br>根据已打开的文件描述符创建一个流<br>#include &lt;stdio.h&gt;<br>FILE *fdopen(int fildes, const char *mode);</p>
<h2 id="4-1-目录文件"><a href="#4-1-目录文件" class="headerlink" title="4.1 目录文件"></a>4.1 <strong>目录文件</strong></h2><p>mkdir/rmdir<br>chdir/fchdir, getcwd<br>读目录操作<br>opendir/closedir<br>readdir<br>telldir<br>seekdir</p>
<h3 id="例2-13设计一程序，要求读取当前目录文件中所有的目录结构。"><a href="#例2-13设计一程序，要求读取当前目录文件中所有的目录结构。" class="headerlink" title="例2.13设计一程序，要求读取当前目录文件中所有的目录结构。"></a>例2.13设计一程序，要求读取当前目录文件中所有的目录结构。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DIR * dir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">ptr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	dir=opendir(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>((ptr = readdir(dir))!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;目录: %s\n&quot;</span>,ptr-&gt;d_name);</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618151814819.png" alt="image-20210618151814819"></p>
<h3 id="1-读目录"><a href="#1-读目录" class="headerlink" title="1. 读目录"></a>1. <strong>读目录</strong></h3><p>数据结构<br>DIR, struct dirent<br>操作函数<br>opendir/closedir<br>readdir<br>telldir<br>seekdir</p>
<h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. <strong>数据结构</strong></h3><p>DIR</p>
<p>​    目录流对象的数据结构</p>
<p>​    in &lt;dirent.h&gt;<br>​    typedef struct __dirstream DIR;</p>
<p>struct dirent</p>
<p>​    目录项</p>
<p>​    Defined in &lt;dirent.h&gt;</p>
<p>​        ino_t d_ino;       /* inode number <em>/<br>​        char  d_name[NAME_MAX + 1];    /</em> file name */</p>
<h3 id="3-操作函数"><a href="#3-操作函数" class="headerlink" title="3. 操作函数"></a>3. 操作函数</h3><p>目录的打开、关闭、读、定位<br>#include &lt;sys/types.h&gt;<br>#include &lt;dirent.h&gt;</p>
<p>DIR *opendir(const char *name);<br>int closedir(DIR *dir);<br>struct dirent *readdir(DIR *dir);<br>off_t telldir(DIR *dir);<br>void seekdir(DIR *dir, off_t offset);</p>
<h4 id="目录扫描程序——ls-R命令"><a href="#目录扫描程序——ls-R命令" class="headerlink" title="目录扫描程序——ls -R命令"></a>目录扫描程序——ls -R命令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DIR *dp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (dp = opendir(dir)) == <span class="literal">NULL</span> )</span><br><span class="line">    err_sys(…);</span><br><span class="line"><span class="keyword">while</span> ( (entry = readdir(dp)) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    lstat(entry-&gt;d_name, &amp;statbuf);</span><br><span class="line">    <span class="keyword">if</span> ( S_ISDIR(statbuf.st_mode) ) </span><br><span class="line">        …</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        …</span><br><span class="line">&#125;</span><br><span class="line">closedir(dp);</span><br></pre></td></tr></table></figure>

<h4 id="mkdir-rmdir-函数"><a href="#mkdir-rmdir-函数" class="headerlink" title="mkdir/rmdir 函数"></a>mkdir/rmdir 函数</h4><p>创建一个空目录<br>#include &lt;sys/stat.h&gt;<br>#include &lt;sys/types.h&gt;<br>int mkdir(const char *pathname, mode_t mode);<br>(Return: 0 if success; -1 if failure)<br>删除一个空目录<br>#include &lt;unistd.h&gt;<br>int rmdir(const char *pathname);<br>(Return: 0 if success; -1 if failure)</p>
<h4 id="chdir-fchdir-函数"><a href="#chdir-fchdir-函数" class="headerlink" title="chdir/fchdir 函数"></a>chdir/fchdir 函数</h4><p>Change working directory<br>#include &lt;unistd.h&gt;<br>int chdir(const char *path);<br>int fchdir(int fd);<br>(Return: 0 if success; -1 if failure)<br>当前工作目录是进程的属性，所以该函数只影响调用chdir的进程本身<br>cd(1) command</p>
<h2 id="4-2-链接文件"><a href="#4-2-链接文件" class="headerlink" title="4.2 链接文件"></a><strong>4.2</strong> <strong>链接文件</strong></h2><p>ln 命令<br>link/unlink 函数<br>给一个文件创建一个链接.<br>#include &lt;unistd.h&gt;<br>int link(const char *oldpath, const char *newpath);<br>(Return: 0 if success; -1 if failure)<br>删除文件链接<br>#include &lt;unistd.h&gt;<br>int unlink(const char *pathname);<br>(Return: 0 if success; -1 if failure)</p>
<h4 id="symlink-readlink"><a href="#symlink-readlink" class="headerlink" title="symlink/readlink"></a>symlink/readlink</h4><p>ln –s命令<br>创建一个符号链接<br>#include &lt;unistd.h&gt;<br>int symlink(const char *oldpath, const char *newpath);<br>(Return: 0 if success; -1 if failure)<br>读取符号链接的值<br>#include &lt;unistd.h&gt;<br>int readlink(const char *path, char *buf, size_t bufsiz);<br>(Return: the count of characters placed in the buffer if success; -1 if failure)</p>
<h4 id="例2-14设计一程序，要求为“-etc-passwd”文件建立软链接“2-14link”，并查看此链接文件和“-etc-passwd”文件。"><a href="#例2-14设计一程序，要求为“-etc-passwd”文件建立软链接“2-14link”，并查看此链接文件和“-etc-passwd”文件。" class="headerlink" title="例2.14设计一程序，要求为“/etc/passwd”文件建立软链接“2-14link”，并查看此链接文件和“/etc/passwd”文件。"></a>例2.14设计一程序，要求为“/etc/passwd”文件建立软链接“2-14link”，并查看此链接文件和“/etc/passwd”文件。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	symlink(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;2-14link&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls 2-14link -l&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls /etc/passwd -l&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618152519176.png" alt="image-20210618152519176"></p>
<h4 id="例2-15设计一程序，要求为“-etc-passwd”文件建立硬链接“2-15link”，并查看此链接文件和“-etc-passwd”文件。"><a href="#例2-15设计一程序，要求为“-etc-passwd”文件建立硬链接“2-15link”，并查看此链接文件和“-etc-passwd”文件。" class="headerlink" title="例2.15设计一程序，要求为“/etc/passwd”文件建立硬链接“2-15link”，并查看此链接文件和“/etc/passwd”文件。"></a>例2.15设计一程序，要求为“/etc/passwd”文件建立硬链接“2-15link”，并查看此链接文件和“/etc/passwd”文件。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link(<span class="string">&quot;./myfile&quot;</span>,<span class="string">&quot;2-15link&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls 2-15link -l&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;ls /etc/passwd -l&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-设备文件"><a href="#4-3-设备文件" class="headerlink" title="4.3 设备文件"></a><strong>4.3</strong> <strong>设备文件</strong></h2><p>1.设备文件名</p>
<p>  ls –C 列出当前系统加载的设备对应的文件</p>
<p>  ls –li 列出当前终端设备的属性</p>
<p>2.设备文件读写</p>
<p>   open，read，write，close，stat</p>
<h4 id="例2-16-向终端pts1写入100个“unix”。"><a href="#例2-16-向终端pts1写入100个“unix”。" class="headerlink" title="例2-16 向终端pts1写入100个“unix”。"></a>例2-16 向终端pts1写入100个“unix”。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">int</span> i,fd;</span><br><span class="line">      fd=open(<span class="string">&quot;/dev/pts/1&quot;</span>,O_WRONLY);</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        write(fd, <span class="string">&quot;Unix&quot;</span>,<span class="number">4</span>);</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h2><h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h3><p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>下面是 fseek() 函数的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位。</li>
<li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SEEK_SET</td>
<td align="left">文件的开头</td>
</tr>
<tr>
<td align="left">SEEK_CUR</td>
<td align="left">文件指针的当前位置</td>
</tr>
<tr>
<td align="left">SEEK_END</td>
<td align="left">文件的末尾</td>
</tr>
</tbody></table>
<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><p>将文件指针重新指向文件开头</p>
<h3 id="readdir"><a href="#readdir" class="headerlink" title="readdir()"></a>readdir()</h3><p>头文件：#include &lt;sys/types.h&gt;  #include &lt;dirent.h&gt;</p>
<p>定义函数：struct dirent * readdir(DIR * dir);</p>
<p>函数说明：readdir()返回参数dir 目录流的下个目录进入点。结构dirent 定义如下：<br>struct dirent<br>{<br>  ino_t d_ino; //d_ino 此目录进入点的inode<br>  ff_t d_off; //d_off 目录文件开头至此目录进入点的位移<br>  signed short int d_reclen; //d_reclen _name 的长度, 不包含NULL 字符<br>  unsigned char d_type; //d_type d_name 所指的文件类型 d_name 文件名<br>  har d_name[256];<br>};</p>
<p>返回值：成功则返回下个目录进入点. 有错误发生或读取到目录文件尾则返回NULL.</p>
<h3 id="fdopen"><a href="#fdopen" class="headerlink" title="fdopen()"></a>fdopen()</h3><p>头文件：#include &lt;stdio.h&gt;</p>
<p>定义函数：FILE * fdopen(int fildes, const char * mode);</p>
<p>**函数说明：fdopen()会将参数fildes 的文件描述词, 转换为对应的文件指针后返回.参数mode 字符串则代表着文件指针的流形态, 此形态必须和原先文件描述词读写模式相同. 关于mode 字符串格式请参考fopen(). **</p>
<p>返回值：转换成功时返回<strong>指向该流的文件指针</strong>. 失败则返回NULL, 并把错误代码存在errno 中.</p>
<h3 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h3><p>头文件：#include &lt;sys/types.h&gt;  #include &lt;dirent.h&gt;</p>
<p>函数：DIR *opendir（const char *name）;</p>
<p>含义： opendir()用来打开参数name 指定的目录, 并返回DIR*形态的目录流, 和open()类似, 接下来对目录的读取和搜索都要使用此返回值.</p>
<h3 id="readdir-1"><a href="#readdir-1" class="headerlink" title="readdir()"></a>readdir()</h3><p>头文件：#include&lt;sys/types.h&gt; #include &lt;dirent.h&gt;</p>
<p>函数：struct dirent *readdir(DIR *dir);</p>
<p>含义:readdir()返回参数dir 目录流的下个目录进入点。</p>
<p>struct dirent<br>{<br>    ino_t d_ino; //d_ino 此目录进入点的inode<br>    ff_t d_off; //d_off 目录文件开头至此目录进入点的位移<br>    signed short int d_reclen; //d_reclen _name 的长度, 不包含NULL 字符<br>    unsigned char d_type; //d_type d_name 所指的文件类型 d_name 文件名<br>    har d_name[256];<br>};</p>
<h3 id="fileno"><a href="#fileno" class="headerlink" title="fileno()"></a>fileno()</h3><p>功  能：<strong>把文件流指针转换成文件描述符</strong><br>相关函数：open, fopen<br>表头文件：#include &lt;stdio.h&gt;<br>定义函数：int fileno(FILE *stream)<br>函数说明：fileno()用来取得参数stream指定的文件流所使用的文件描述词<br>返回值 ：返回和stream文件流对应的文件描述符。如果失败，返回-1。<br>范例：<br>#include &lt;stdio.h&gt;<br>main()<br>{<br>   FILE  *fp;<br>   int  fd;<br>   fp = fopen(“/etc/passwd”, “r”);<br>   fd = fileno(fp);<br>   printf(“fd = %d\n”, fd);<br>   fclose(fp);<br>}</p>
<p><strong>文件描述词是Linux编程中的一个术语。当一个文件打开后，系统会分配一部分资源来保存该文件的信息，以后对文件的操作就可以直接引用该部分资源了。文件描述词可以认为是该部分资源的一个索引，在打开文件时返回。</strong>在使用fcntl函数对文件的一些属性进行设置时就需要一个文件描述词参数。<br>以前知道，当程序执行时，就已经有三个文件流打开了，它们分别是标准输入stdin，标准输出stdout和标准错误输出stderr。和流式文件相对应的是，也有三个文件描述符被预先打开，它们分别是0，1，2，代表标准输入、标准输出和标准错误输出。需要指出的是，上面的流式文件输入、输出和文件描述符的输入输出方式不能混用，否则会造成混乱。</p>
<h3 id="telldir"><a href="#telldir" class="headerlink" title="telldir()"></a>telldir()</h3><p>头文件：#include &lt;dirent.h&gt;</p>
<p>定义函数：off_t telldir(DIR *dir);</p>
<p>函数说明：<strong>telldir()返回参数dir 目录流目前的读取位置. 此返回值代表距离目录文件开头的偏移量返回值返回下个读取位置, 有错误发生时返回-1.</strong></p>
<h3 id="exit-和-eixt-区别"><a href="#exit-和-eixt-区别" class="headerlink" title="exit()和_eixt()区别"></a>exit()和_eixt()区别</h3><p><strong>_exit()函数的作用最为简单：直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构；exit() 函数则在这些基础上作了一些包装，在执行退出之前加了若干道工序。<br>exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是”清理I/O缓冲”。</strong></p>
<h3 id="文件流指针"><a href="#文件流指针" class="headerlink" title="文件流指针"></a>文件流指针</h3><p>在应用编程层面，程序对流的操作体现在文件流指针FILE上，在操作一个文件前，需要打开该文件，而使用ANSI　C库函数fopen()打开一个文件后，将返回一个文件流指针与该文件关联，所有针对该文件的读写操作都通过该文件流指针完成，以下是应用层所能访问的FILE结构体，因此，结构体成员可以在用户空间中访问。<br>typedef struct _IO_FILE FILE;<br>struct _IO_FILE{<br>int _flags;<br>char* _IO_read_ptr; //如果以读打开，当前读指针<br>char* _IO_read_end; //如果以读打开，读区域结束位置<br>char* _IO_read_base; //Start of putback+get area<br>char* _IO_write_base; //如果以写打开，写区起始区<br>char* _IO_write_ptr; //如果以写打开，当前写指针<br>char* _IO_write_end; //如果以写打开，写区域结束位置<br>char* _IO_buf_base; //如果显示设置缓冲区，其起始位置<br>char* _IO_buf_end; //如果显示设置缓冲区，其结束位置。<br>…<br>int _fileno; //文件描述符<br>…<br>}<br>在此结构体中，包含了I/O库为管理该流所需要的所有信息，如用于实现I/O的文件描述符、指向流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数和出错标志等。</p>
<h3 id="Linux文件存储结构"><a href="#Linux文件存储结构" class="headerlink" title="Linux文件存储结构"></a>Linux文件存储结构</h3><p>大部分的Linux文件系统（如ext2、ext3）规定，<strong>一个文件由目录项、inode和数据块组成</strong>：</p>
<ul>
<li>目录项：包括<strong>文件名和inode节点号</strong>。</li>
<li>Inode：又称<strong>文件索引节点，包含文件的基础信息以及数据块的指针</strong>。</li>
<li>数据块：包含文件的具体内容。</li>
</ul>
<p>Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>
<p>目录文件的结构非常简单，就是一系列目录项（<em><strong>dirent</strong></em>）的列表。<strong>每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码</strong>。</p>
<h2 id="雨课堂题目整理-1"><a href="#雨课堂题目整理-1" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214812080.png" alt="image-20210610214812080"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214821927.png" alt="image-20210610214821927"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214834210.png" alt="image-20210610214834210"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214845524.png" alt="image-20210610214845524"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214854641.png" alt="image-20210610214854641"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214906327.png" alt="image-20210610214906327"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214915564.png" alt="image-20210610214915564"></p>
<p>!==[image-20210610214926804]==(D:\SyncDisk\笔记整理\Linux\image-20210610214926804.png)</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214936008.png" alt="image-20210610214936008"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214944544.png" alt="image-20210610214944544"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610215005400.png" alt="image-20210610215005400"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610215953437.png" alt="image-20210610215953437"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220011507.png" alt="image-20210610220011507"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220021904.png" alt="image-20210610220021904"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220032690.png" alt="==image-20210610220032690"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220042546.png" alt="image-20210610220042546"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220052131.png" alt="image-20210610220052131"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220104981.png" alt="image-20210610220104981"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220118232.png" alt="image-20210610220118232"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220131685.png" alt="image-20210610220131685"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214618550.png" alt="image-20210610214618550"></p>
<p><img src="https://qn-sc0.yuketang.cn/ue_i/20210412/ed409440-6383-449f-80b4-d692f0abd914.png" alt="image.png"><img src="https://qn-sc0.yuketang.cn/ue_i/20210412/88aa10b5-c10f-4e78-a476-aa0b1042460f.png" alt="image.png"><img src="https://qn-sc0.yuketang.cn/ue_i/20210412/78291e04-149d-44ad-a612-86b4c9fabaf1.png" alt="image.png"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214629301.png" alt="image-20210610214629301"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610214639221.png" alt="image-20210610214639221"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143645924.png" alt="image-20210618143645924"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143654774.png" alt="image-20210618143654774"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143702180.png" alt="image-20210618143702180"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143710258.png" alt="image-20210618143710258"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143719274.png" alt="image-20210618143719274"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618143727064.png" alt="image-20210618143727064"></p>
<h1 id="进程编程"><a href="#进程编程" class="headerlink" title="进程编程"></a>进程编程</h1><h2 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1. 进程"></a>1.1. <strong>进程</strong></h2><p>进程：一个或多个线程执行的地址空间，线程执行时需要系统资源</p>
<h2 id="1-2-进程启动"><a href="#1-2-进程启动" class="headerlink" title="1.2. 进程启动"></a>1.2. <strong>进程启动</strong></h2><p>System call “fork” 系统调用fork<br>   Process resources<br>struct task_struct<br>System space stack<br>…<br>System call “exec”系统调用exec<br>The entry of C programs  C程序入口</p>
<h2 id="1-3-进程终止"><a href="#1-3-进程终止" class="headerlink" title="1.3. 进程终止"></a>1.3. 进程终止</h2><p>进程终止的五种方式<br>Normal termination 正常终止<br>Return from “main” function 从main函数返回<br>Call “exit” function 调用exit函数<br>Call “_exit” function 调用_exit函数<br>Abnormal termination 异常终止<br>Call “abort” function 调用abort函数<br>Terminated by a signal 信号终止</p>
<h2 id="1-4-进程分类"><a href="#1-4-进程分类" class="headerlink" title="1.4. 进程分类"></a>1.4. 进程分类</h2><p>Foreground process前台进程<br>要求用户启动它们或与它们交互的进程称为前台进程。<br>前台进程不结束，终端就不会出现系统提示符，直到进程终止。<br>缺省情况下，程序和命令作为前台进程运行。</p>
<p>Background process 后台进程<br>独立于用户运行的进程称为后台进程。<br>用户在输入命令行后加上“&amp;”字符然后按<Enter>键就启动了后台进程。<br>Shell不等待命令终止，就立即出现系统提示符，让该命令进程在后台运行，用户可以继续执行新的命令。 </p>
<p>Daemon 守护进程<br>总是运行在后台的系统进程。<br>守护程序通常<strong>在系统启动时启动，并且它们一直运行到系统停止</strong>。<br>守护进程常常用于向用户提供各种类型的服务和执行系统管理任务。<br>守护程序进程由 root 用户或 root  shell 启动，并只能由 root 用户停止。</p>
<h2 id="2-1-进程标识符"><a href="#2-1-进程标识符" class="headerlink" title="2.1. 进程标识符"></a>2.1. 进程标识符</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618161417909.png" alt="image-20210618161417909"></p>
<h2 id="2-2-进程创建"><a href="#2-2-进程创建" class="headerlink" title="2.2. 进程创建"></a>2.2. 进程创建</h2><h3 id="1-fork"><a href="#1-fork" class="headerlink" title="1.fork"></a>1.fork</h3><p>fork: create a child process<br>#include &lt;sys/types.h&gt;<br>#include &lt;unistd.h&gt;<br>pid_t fork(void);<br>returned value:<br>pid of child (in the current (parent) process),<br>0 (in child process),<br>-1 (failure)</p>
<p>fork创建子进程代码结构</p>
<p>……</p>
<p> pid = fork();</p>
<p> if (pid&lt;0) {perror(“fork()”);exit(1);}</p>
<p> else if (pid==0) { child process }</p>
<p> else  { parent process }</p>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a><strong>文件共享</strong></h4><p>所有由父进程打开的描述符都被复制到子进程中。父、子进程每个相同的打开描述符共享一个文件表项</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618161638801.png" alt="image-20210618161638801"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">pid_t</span> pid;    </span><br><span class="line">  <span class="keyword">int</span> fd;    </span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> status; </span><br><span class="line">  <span class="keyword">char</span> *ch1=<span class="string">&quot;hello&quot;</span>; </span><br><span class="line">  <span class="keyword">char</span> *ch2=<span class="string">&quot;world&quot;</span>; </span><br><span class="line">  <span class="keyword">char</span> *ch3=<span class="string">&quot;IN&quot;</span>; </span><br><span class="line">  <span class="keyword">if</span>((fd=open(<span class="string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>))==<span class="number">-1</span>) </span><br><span class="line">    &#123;   perror(<span class="string">&quot;parent open&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; </span><br><span class="line">  <span class="keyword">if</span>(write(fd,ch1,<span class="built_in">strlen</span>(ch1))==<span class="number">-1</span>)  </span><br><span class="line">    &#123; perror(<span class="string">&quot;parent write&quot;</span>);    <span class="built_in">exit</span>(EXIT_FAILURE); &#125; </span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">-1</span>) </span><br><span class="line">  &#123; perror(<span class="string">&quot;fork&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)  </span><br><span class="line">    &#123; i=<span class="number">2</span>; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;in child\n&quot;</span>);   <span class="comment">//打印 i 值，以示与父亲进程区别 </span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i); </span><br><span class="line">      <span class="keyword">if</span>(write(fd,ch2,<span class="built_in">strlen</span>(ch2))==<span class="number">-1</span>)     <span class="comment">//写文件 test.txt，与父进程共享 </span></span><br><span class="line">        perror(<span class="string">&quot;child write&quot;</span>); </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;   &#125; </span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    &#123;    sleep(<span class="number">1</span>);                       <span class="comment">//等待子进程先执行 </span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;in parent\n&quot;</span>); </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i);          <span class="comment">//打印 i 值，以示与子进程区别 </span></span><br><span class="line">         <span class="keyword">if</span>(write(fd,ch3,<span class="built_in">strlen</span>(ch3))==<span class="number">-1</span>)       <span class="comment">//写操作，结果添加到文件后 </span></span><br><span class="line">            perror(<span class="string">&quot;parent,write&quot;</span>); </span><br><span class="line">         wait(&amp;status);                        <span class="comment">//等待子进程结束 </span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">&#125; </span><br><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">      &#123; <span class="keyword">if</span> (i%j==<span class="number">0</span>)</span><br><span class="line">        &#123; mark=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">单个进程</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200main()</span></span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">      &#123; <span class="keyword">if</span> (i%j==<span class="number">0</span>)</span><br><span class="line">        &#123; mark=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">多个进程</span><br><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)</span><br><span class="line">    &#123;     <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">          &#123; <span class="keyword">if</span> (i%j==<span class="number">0</span>)             &#123; mark=<span class="number">0</span>;               <span class="keyword">break</span>;              &#125; </span><br><span class="line">          &#125;</span><br><span class="line">         <span class="keyword">if</span> (mark)     <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i); <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">     &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="fork-应用场合"><a href="#fork-应用场合" class="headerlink" title="fork 应用场合"></a><strong>fork</strong> 应用场合</h4><p>进程复制自己，使父子进程同一时刻执行不同的代码——网络服务<br>进程要执行另一个不同的程序：fork-exec——shell<br>Question：效率问题？父子进程各自占一段逻辑地址空间，fork之后立即exec，地址空间浪费。<br>    “写—复制”</p>
<h3 id="2-vfork"><a href="#2-vfork" class="headerlink" title="2. vfork"></a>2. vfork</h3><p>vfork</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t vfork(void);</p>
<p>功能：类似fork，创建一个新进程，效率髙。</p>
<p>与fork区别：</p>
<p>  <strong>(1) vfork创建的进程与父进程共用地址空间</strong></p>
<p>  <strong>(2) vfork创建子进程后，阻塞父进程，直到子进程调用exec或exit，内核才唤醒父进程。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global=<span class="number">5</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;<span class="keyword">int</span> pid; <span class="keyword">char</span> *<span class="built_in">string</span>=<span class="string">&quot;I am father:&quot;</span>; <span class="keyword">int</span> local=<span class="number">10</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;before vfork\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>) &#123;perror(<span class="string">&quot;vfork failed&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">   &#123;<span class="built_in">string</span>=<span class="string">&quot;I am child.&quot;</span>;</span><br><span class="line">    global++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s global=%d, local=%d\n&quot;</span>,<span class="built_in">string</span>,global,local);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;local++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s my pid is %d \n&quot;</span>    <span class="string">&quot;global=%d\n local=%d\n&quot;</span>, <span class="built_in">string</span>,getpid(),global,local);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;&#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">int</span> global=<span class="number">5</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;<span class="keyword">int</span> pid; <span class="keyword">char</span> *<span class="built_in">string</span>=<span class="string">&quot;I am father:&quot;</span>; <span class="keyword">int</span> local=<span class="number">10</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;before vfork\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>((pid=vfork())&lt;<span class="number">0</span>) &#123;perror(“vfork failed”);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;  </span><br><span class="line">                           <span class="comment">//共用进程空间，子进程先执行</span></span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">   &#123;<span class="built_in">string</span>=<span class="string">&quot;I am child.&quot;</span>;</span><br><span class="line">    global++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s global=%d, local=%d\n&quot;</span>,<span class="built_in">string</span>,global,local);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;local++;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s my pid is %d \n&quot;</span>    <span class="string">&quot;global=%d\n local=%d\n&quot;</span>, <span class="built_in">string</span>,getpid(),global,local);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sleep函数"><a href="#sleep函数" class="headerlink" title="sleep函数"></a>sleep函数</h3><p>函数原型：</p>
<p> #include &lt;unistd.h&gt;</p>
<p>  unsigned int sleep(unsigned int seconds);</p>
<p>  seconds:暂停时间（秒）</p>
<h3 id="3-exec-系列函数"><a href="#3-exec-系列函数" class="headerlink" title="3.exec 系列函数"></a><strong>3.exec</strong> <strong>系列函数</strong></h3><p>用一个新的进程映像替换当前的进程映像,执行新程序的进程保持原进程的一系列特征：</p>
<p>pid, ppid, uid, gid, working directory, root directory …</p>
<p>#include &lt;unistd.h&gt;</p>
<p>extern char **environ;</p>
<p>int execl(const char *path, const char *arg, …);</p>
<p>int execlp(const char *file, const char *arg, …);</p>
<p>int execle(const char *path, const char *arg, …, char * const envp[]);</p>
<p>int execv(const char *path, char * const argv[]);</p>
<p>int execvp(const char *file, char * const argv[]);</p>
<p>int execve(const char *filename, char * const argv[], char * const envp[]);</p>
<p>1.两大类：</p>
<p>  execl开头：参数以列表形式arg0,arg1…NULL结束。</p>
<p>  execv开头：参数以指向字符串数组argv[]指针形式，arg[0]必须为程序名。</p>
<p>2.含有字母p的函数可以使用相对路径，根据环境变量PATH查找文件；其他函数必须使用绝对路径；</p>
<p>3.含有字母e的函数，需要通过指向envp[]数组的指针指明新的环境变量，其他函数使用当前环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用exec函数使新进程执行“/bin/ps” 程序。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ps_argv[]=&#123;“ps”,”-af”, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ps_envp[] = &#123;“PATH=/bin:/usr/bin”, “TERM=console”, <span class="literal">NULL</span>&#125;;</span><br><span class="line">六种情况：</span><br><span class="line">execl(“/bin/ps”,”ps”,”-af”,<span class="literal">NULL</span>);</span><br><span class="line">execlp(“ps”,”ps”,”-af”,<span class="literal">NULL</span>);</span><br><span class="line">execle(“/bin/ps”,”ps”,”-af”,<span class="literal">NULL</span>,ps_envp);</span><br><span class="line">execv(“/bin/ps”,ps_argv);</span><br><span class="line">execvp(“ps”,ps_argv);</span><br><span class="line">execve(“/bin/ps”,ps_argv,ps_envp);</span><br></pre></td></tr></table></figure>

<h4 id="fork和exec一起使用"><a href="#fork和exec一起使用" class="headerlink" title="fork和exec一起使用"></a>fork和exec一起使用</h4><p>父子进程各自执行不同的代码,进程要执行另一个程序.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);	<span class="comment">/* print prompt  */</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;     <span class="comment">/* replace newline with null */</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) </span><br><span class="line">        err_sys(“fork error”);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;		<span class="comment">/* child */</span></span><br><span class="line">        execlp(buf, buf, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;couldn&#x27;t execute: %s&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span> ) <span class="comment">/* parent */</span></span><br><span class="line">        err_sys(“waitpid error”);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%% &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-进程终止"><a href="#2-3-进程终止" class="headerlink" title="2.3 进程终止"></a><strong>2.3</strong> <strong>进程终止</strong></h2><h3 id="1-exit函数"><a href="#1-exit函数" class="headerlink" title="1.exit函数"></a>1.exit函数</h3><p>函数原型：</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>void exit(int status);</p>
<p>status:进程状态</p>
<p>功能：正常终止目前进程的执行，把参数status返回给父进程，进程所有的缓冲区数据会自动写回并关闭未关闭的文件。</p>
<h3 id="2-exit函数"><a href="#2-exit函数" class="headerlink" title="2._exit函数"></a>2._exit函数</h3><p>函数原型：</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>void ——exit(int status);</p>
<p>status:进程状态</p>
<p>功能：立刻终止目前进程的执行，把参数status返回给父进程，并关闭未关闭的文件。不处理标准I/O缓冲区。</p>
<h2 id="2-4-父子进程关系"><a href="#2-4-父子进程关系" class="headerlink" title="2.4 父子进程关系"></a><strong>2.4</strong> <strong>父子进程关系</strong></h2><h3 id="1-两种进程概念"><a href="#1-两种进程概念" class="headerlink" title="1. 两种进程概念"></a><strong>1.</strong> <strong>两种进程概念</strong></h3><p>父进程在子进程前终止——<strong>孤儿进程</strong></p>
<p>​    Orphan process——init</p>
<p>子进程在父进程前终止——可能成为<strong>僵尸进程</strong></p>
<p>​    SIGCHLD signal 忽略SIGCHLD信号</p>
<p>​    Handled by wait/waitpid in parent 父进程中用wait/waitpid处理</p>
<p>​    Not handled by wait/waitpid in parent -&gt; zombie父进程没有用wait/waitpid处理-&gt;僵尸进程</p>
<h3 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2. 僵尸进程"></a><strong>2.</strong> <strong>僵尸进程</strong></h3><p>僵尸进程：已终止运行，但尚未被清除的进程。</p>
<p>子进程运行结束后（正常或异常），它并没有马上从系统的进程分配表中被删掉，而是进入僵死状态（Zombie），一直等到父进程来回收它的结束状态信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> pid;          <span class="keyword">char</span> *message;              <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fork program starting\n&quot;</span>);</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;  <span class="keyword">case</span> <span class="number">-1</span>:      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:      message=<span class="string">&quot;this is child&quot;</span>;    n=<span class="number">2</span>;      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:      n=<span class="number">5</span>;      message=<span class="string">&quot;this is parent&quot;</span>;      sleep(<span class="number">60</span>);       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;n&gt;<span class="number">0</span>;n--)</span><br><span class="line">      &#123;  <span class="built_in">puts</span>(message);</span><br><span class="line">         sleep(n<span class="number">-1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-僵尸进程解决方法"><a href="#3-僵尸进程解决方法" class="headerlink" title="**3.**僵尸进程解决方法"></a>**3.**僵尸进程解决方法</h3><p>僵尸进程的proc结构一直存在直到父进程正常结束或系统重启</p>
<p>如何消除僵尸进程？</p>
<p>方法一：wait/waitpid阻塞父进程，子进程先终止</p>
<p>方法二：父进程不阻塞，两次fork</p>
<p>方法三：使用signal信号处理</p>
<h4 id="方法一：wait-example"><a href="#方法一：wait-example" class="headerlink" title="方法一：wait example"></a>方法一：wait example</h4><h4 id="例3-5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。"><a href="#例3-5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。" class="headerlink" title="例3.5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。"></a>例3.5设计一个程序，要求复制进程，子进程显示自己的进程号后暂停一段时间，父进程等待子进程正常结束，打印显示等待的进程号和等待的进程退出状态。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123; <span class="keyword">int</span> i,j,mark;  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">  &#123; mark=<span class="number">1</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">      <span class="keyword">if</span> (i%j==<span class="number">0</span>)        &#123; mark=<span class="number">0</span>;          <span class="keyword">break</span>;        &#125; </span><br><span class="line">      <span class="keyword">if</span> (mark)        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer!\n&quot;</span>,i);</span><br><span class="line">      sleep(<span class="number">100</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i=LEFT;i&lt;=RIGHT;i++)</span><br><span class="line">     wait(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="wait-amp-waitpid-functions"><a href="#wait-amp-waitpid-functions" class="headerlink" title="wait &amp; waitpid functions"></a><strong>wait &amp;</strong> <strong>waitpid</strong> <strong>functions</strong></h5><p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/wait.h&gt;</p>
<p>pid_t wait(int *status);</p>
<p>pid_t waitpid(pid_t pid, int *status, int options);</p>
<p>waitpid的第一个参数pid的意义：</p>
<p>  pid &gt; 0: 等待进程id为pid的子进程。</p>
<p>  pid == 0: 等待与自己同组的任意子进程。</p>
<p>  pid == -1: 等待任意一个子进程</p>
<p>  pid &lt; -1: 等待进程组号为-pid的任意子进程。因此，wait(&amp;stat)等价于waitpid(-1, &amp;stat, 0)</p>
<p>waitpid例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>           	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>       	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span>        	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                  	 </span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">pid_t</span> pid,wpid;	<span class="keyword">int</span> status,i;</span><br><span class="line">	pid=fork();          		</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">	&#123;	<span class="built_in">printf</span>(<span class="string">&quot;这是子进程,进程号(pid)是:%d\n&quot;</span>,getpid());</span><br><span class="line">		sleep(<span class="number">5</span>);        	<span class="built_in">exit</span>(<span class="number">6</span>);	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="built_in">printf</span>(<span class="string">&quot;这是父进程,正在等待子进程……\n&quot;</span>);</span><br><span class="line">		wpid=waitpid(pid,&amp;status,<span class="number">0</span>);    	</span><br><span class="line">		i=WEXITSTATUS(status);			</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;等待的进程的进程号(pid)是:%d ,结束状态:%d\n&quot;</span>,wpid,i);</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：两次fork-Example"><a href="#方法二：两次fork-Example" class="headerlink" title="方法二：两次fork Example"></a><strong>方法二：两次</strong>fork Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">pid_t</span> pid;</span><br><span class="line"> <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)  perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)    <span class="comment">/*first child*/</span></span><br><span class="line">   &#123; <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>) perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/*parent of second child=first child*/</span></span><br><span class="line">         sleep(<span class="number">10</span>);          <span class="comment">/*second child*/</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;second child,parent pid=%d\n&quot;</span>,getppid());</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>)!=pid)  <span class="comment">/*wait for first child,parent(the original process)*/</span></span><br><span class="line">    perror(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;parent exit&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法三：singnal函数处理"><a href="#方法三：singnal函数处理" class="headerlink" title="方法三：singnal函数处理"></a><strong>方法三：</strong>singnal<strong>函数处理</strong></h4><p>Singnal函数处理：</p>
<p>  （1）设置信号处理函数</p>
<p>​       signal(SIGCHLD,fun)</p>
<p>  （2）忽略子进程终止信号</p>
<p>​       signal(SIGCHLD,SIG_IGN)</p>
<p>​       内核回收</p>
<h2 id="4-1-登录方式"><a href="#4-1-登录方式" class="headerlink" title="4.1 登录方式"></a><strong>4.1</strong> <strong>登录方式</strong></h2><h3 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618204829654.png" alt="image-20210618204829654"></p>
<h3 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618204928040.png" alt="image-20210618204928040"></p>
<h2 id="4-2-进程组和会话期"><a href="#4-2-进程组和会话期" class="headerlink" title="4.2 进程组和会话期"></a><strong>4.2</strong> <strong>进程组和会话期</strong></h2><p>进程组</p>
<p>一个或多个过程的集合</p>
<p>getpgrp/setpgid functions</p>
<p>会话期Session</p>
<p>一个或多个进程组的集合。</p>
<p>getsid/setsid function</p>
<p>setsid函数</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618211351096.png" alt="image-20210618211351096"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618211443043.png" alt="image-20210618211443043"></p>
<h2 id="4-3-守护进程Daemon"><a href="#4-3-守护进程Daemon" class="headerlink" title="4.3 守护进程Daemon"></a><strong>4.3</strong> <strong>守护进程</strong>Daemon</h2><p>精灵进程或守护进程</p>
<p>后台执行, 没有控制终端或登录 Shell 的进程</p>
<h3 id="ps-–aux-命令查看"><a href="#ps-–aux-命令查看" class="headerlink" title="ps –aux 命令查看"></a><strong>ps</strong> <strong>–aux</strong> <strong>命令查看</strong></h3><p>Init:进程1，启动系统服务</p>
<p>Keventd：为内核中运行的函数提供进程上下文</p>
<p>Kswapd：页面调出守护进程</p>
<p>bdflush，kupdated：调整缓存中的数据写到磁盘</p>
<p>portmap：将RPC程序号映射为端口号</p>
<p>inetd(xinetd)：侦听网络接口，获取网络服务进程请求</p>
<p>注意：大多数守护进程都以超级用户（用户ID为0）特权运行。没有一个守护进程具有控制终端，其终端名设置为问号（？）。</p>
<h3 id="ps-axj命令查看"><a href="#ps-axj命令查看" class="headerlink" title="ps axj命令查看"></a><strong>ps</strong> <strong>axj命令查看</strong></h3><p>daemon特征：</p>
<p>sid，pid，pgid相同，均为pid</p>
<p>ppid为1</p>
<p>tty为？</p>
<h3 id="daemon进程实现规则"><a href="#daemon进程实现规则" class="headerlink" title="daemon进程实现规则"></a><strong>daemon</strong>进程实现规则</h3><p>编程规则<br>首先调用fork，然后使父进程exit<br>调用setsid创建一个新的会话期 setsid()<br>将当前工作目录更改为特定目录chdir(./)<br>进程的umask设为0 umask(0)<br>关闭不需要的文件描述符 close()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);	<span class="comment">/* parent goes bye-bye */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* child continues */</span></span><br><span class="line">	setsid();		<span class="comment">/* become session leader */</span></span><br><span class="line">	chdir(<span class="string">&quot;/tmp&quot;</span>);		<span class="comment">/* change working directory */</span></span><br><span class="line">	umask(<span class="number">0</span>);		<span class="comment">/* clear our file mode creation mask */</span>   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXFILE;i++)  	  </span><br><span class="line">		close(i);       <span class="comment">/* close file */</span> </span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写守护进程的要点"><a href="#编写守护进程的要点" class="headerlink" title="编写守护进程的要点"></a><strong>编写守护进程的要点</strong></h3><p>（1）创建子进程，终止父进程</p>
<p>pid=fork();</p>
<p>if(pid&gt;0)</p>
<p>{exit(0);}  /<em>终止父进程</em>/</p>
<p>（2）在子进程中创建新会话</p>
<p>setsid函数用于创建一个新的会话，并担任该会话组的组长，其作用：</p>
<p>①让进程摆脱原会话的控制；</p>
<p>②让进程摆脱原进程组的控制；</p>
<p>③让进程摆脱原控制终端的控制。</p>
<p>而setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。</p>
<p>（3）改变工作目录</p>
<p>改变工作目录的常见函数是chdir。</p>
<p>（4）重设文件创建掩码</p>
<p>文件创建掩码是指屏蔽掉文件创建时的对应位。</p>
<p>把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。</p>
<p>设置文件创建掩码的函数是umask。</p>
<p>（5）关闭文件描述符</p>
<p>通常按如下方式关闭文件描述符：</p>
<p>for(i=0;i&lt;NOFILE;i++)</p>
<p>close(i);</p>
<p>或者也可以用如下方式：</p>
<p>for(i=0;i&lt;MAXFILE;i++)</p>
<p>close(i);</p>
<h3 id="守护进程编写"><a href="#守护进程编写" class="headerlink" title="守护进程编写"></a><strong>守护进程编写</strong></h3><h4 id="例3-7-设计两个程序，主程序和初始化程序。要求主程序每隔10秒向-tmp目录中的日志报告运行状态。初始化程序中的init-daemon函数负责生成守护进程。"><a href="#例3-7-设计两个程序，主程序和初始化程序。要求主程序每隔10秒向-tmp目录中的日志报告运行状态。初始化程序中的init-daemon函数负责生成守护进程。" class="headerlink" title="例3.7 设计两个程序，主程序和初始化程序。要求主程序每隔10秒向/tmp目录中的日志报告运行状态。初始化程序中的init_daemon函数负责生成守护进程。"></a>例3.7 设计两个程序，主程序和初始化程序。要求主程序每隔10秒向/tmp目录中的日志报告运行状态。初始化程序中的init_daemon函数负责生成守护进程。</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618211952186.png" alt="image-20210618211952186"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*主程序每隔一分钟向/tmp目录中的日志3-7.log报告运行状态*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> 	          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span>                </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_daemon</span><span class="params">(<span class="keyword">void</span>)</span></span>;        	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	FILE *fp; </span><br><span class="line">	<span class="keyword">time_t</span> t; </span><br><span class="line">	init_daemon();  				</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)                       		</span><br><span class="line">	&#123;  sleep(<span class="number">10</span>);                     	</span><br><span class="line">	  <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;./3-7.log&quot;</span>,<span class="string">&quot;a+&quot;</span>)) &gt;=<span class="number">0</span></span><br><span class="line">	    &#123; t=time(<span class="number">0</span>); </span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;守护进程还在运行，时间是： %s&quot;</span>,asctime(localtime(&amp;t)) ); </span><br><span class="line">		  fclose(fp); </span><br><span class="line">	&#125; &#125; &#125;</span><br><span class="line"><span class="keyword">void</span> init_daemon(<span class="keyword">void</span>) </span><br><span class="line">&#123;	<span class="keyword">pid_t</span> child1,child2; 	<span class="keyword">int</span> i; </span><br><span class="line">	child1=fork();</span><br><span class="line">	<span class="keyword">if</span>(child1&gt;<span class="number">0</span>)          <span class="built_in">exit</span>(<span class="number">0</span>);                       	</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(child1&lt; <span class="number">0</span>) </span><br><span class="line">	&#123; perror(<span class="string">&quot;创建子进程失败&quot;</span>);				<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	setsid();               			</span><br><span class="line">   chdir(<span class="string">&quot;/tmp&quot;</span>);          				</span><br><span class="line">  umask(<span class="number">0</span>);               				</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; NOFILE;++i)  					close(i); </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：fopen函数必须具有root权限。如果没有root权限，可以看到守护进程的运行，但不会在文件里写入任何字符。</p>
<h4 id="例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。"><a href="#例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。" class="headerlink" title="例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。"></a>例3-8：设计一个程序，要求运行后成为守护进程，守护进程又复制出一个子进程，守护进程和它的子进程都调用syslog函数，把结束前的状态写入系统日志文件。</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618212139554.png" alt="image-20210618212139554"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> child1,child2; </span><br><span class="line">	<span class="keyword">int</span> i; </span><br><span class="line">	child1=fork();</span><br><span class="line">	<span class="keyword">if</span>(child1&gt;<span class="number">0</span>)        		<span class="comment">/*(1)创建子进程，终止父进程*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);        		<span class="comment">/*这是第一子进程，后台继续执行*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(child1&lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;创建子进程失败&quot;</span>);	<span class="comment">/*fork失败，退出*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setsid();               		<span class="comment">/*(2)在子进程中创建新会话*/</span></span><br><span class="line">	chdir(<span class="string">&quot;/&quot;</span>);             		<span class="comment">/*(3)改变工作目录到“/”*/</span> </span><br><span class="line">	umask(<span class="number">0</span>);               		<span class="comment">/*(4)重设文件创建掩码*/</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; NOFILE;++i)  	<span class="comment">/*(5)关闭文件描述符*/</span> </span><br><span class="line">		close(i); </span><br><span class="line">	openlog(<span class="string">&quot;例3-8程序信息&quot;</span>,LOG_PID,LOG_DAEMON);<span class="comment">/* 调用openlog,打开日志文件*/</span></span><br><span class="line">	child2=fork();</span><br><span class="line"><span class="keyword">if</span>(child2==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;创建子进程失败&quot;</span>);	</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(child2==<span class="number">0</span>)</span><br><span class="line">	&#123;	syslog(LOG_INFO,<span class="string">&quot;第二子进程暂停5秒！&quot;</span>); </span><br><span class="line">		sleep(<span class="number">5</span>);              <span class="comment">/*睡眠5秒钟*/</span></span><br><span class="line">		syslog(LOG_INFO,<span class="string">&quot;第二子进程结束运行。&quot;</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	&#123;</span><br><span class="line">		waitpid(child2,<span class="literal">NULL</span>,<span class="number">0</span>); </span><br><span class="line">		syslog(LOG_INFO, <span class="string">&quot;第一子进程在等待第二子进程结束后，也结束运行。&quot;</span>);</span><br><span class="line">		closelog();         	   <span class="comment">/*调用closelog，关闭日志服务*/</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) 	&#123;	sleep(<span class="number">10</span>);      	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：调用openlog、syslog函数，操作的系统日志文件“/var/log/syslog”或“/var/log/messages ”，必须具有root权限。</p>
<p>openlog函数说明 </p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618212254955.png" alt="image-20210618212254955"></p>
<p>syslog函数说明</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618212315332.png" alt="image-20210618212315332"></p>
<h2 id="5-1-信号概念"><a href="#5-1-信号概念" class="headerlink" title="5.1 信号概念"></a><strong>5.1</strong> <strong>信号概念</strong></h2><p>信号<br>Software interrupt软件中断<br>Mechanism for handling asynchronous events异步事件<br>Having a name (beginning with SIG)<br>Defined as a positive integer (in &lt;signal.h&gt;)<br>信号产生<br>按终端键，硬件异常，kill(2)函数，kill(1)命令，软件条件，…</p>
<p>SIG信号（1-31）是从UNIX系统中继承下来的称为不可靠信号(也称为非实时信号)。<br>SIGRTMIN~SIGRTMAX是为了解决前面“不可靠信号”问题而进行更改和扩充的信号，称为可靠信号(也称为实时信号)。</p>
<p>可靠信号(实时信号)：支持排队，发送用户进程一次就注册一次，发现相同信号已经在进程中注册，也要再注册。<br>不可靠信号(非实时信号)：不支持排队，发送用户进程判断后注册，发现相同信号已经在进程中注册，就不再注册，忽略该信号。</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th>**说明 **</th>
<th><strong>默认操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SIGABRT</td>
<td>进程异常终止（调用abort函数产生此信号）</td>
<td></td>
</tr>
<tr>
<td><strong>SIGALRM</strong></td>
<td><strong>超时（<strong><strong>alarm</strong></strong>）</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td>SIGFPE</td>
<td>算术运算异常（除以0，浮点溢出等）</td>
<td></td>
</tr>
<tr>
<td><strong>SIGHUP</strong></td>
<td><strong>连接断开</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td>SIGILL</td>
<td>非法硬件指令</td>
<td></td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td><strong>终端终端符</strong>(Clt**-C)**</td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td><strong>立即结束程序运行（不能被捕捉、阻塞或忽略）</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>向没有读进程的管道写数据</td>
<td></td>
</tr>
<tr>
<td><strong>SIGQUIT</strong></td>
<td><strong>终端退出符</strong>(Clt-\)</td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td><strong>SIGTERM</strong></td>
<td><strong>终止（由</strong>kill<strong>命令发出的系统默认终止信号）</strong></td>
<td><strong>退出</strong></td>
</tr>
<tr>
<td><strong>SIGUSR1</strong></td>
<td><strong>用户定义信号</strong></td>
<td><strong>退出</strong></td>
</tr>
<tr>
<td><strong>SIGUSR2</strong></td>
<td><strong>用户定义信号</strong></td>
<td><strong>退出</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>SIGSEGV</th>
<th>无效存储访问（段违例）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SIGCHLD</strong></td>
<td><strong>子进程停止或退出</strong></td>
<td><strong>忽略</strong></td>
</tr>
<tr>
<td><strong>SIGCONT</strong></td>
<td><strong>使暂停进程继续</strong></td>
<td><strong>继续</strong>/<strong>忽略</strong></td>
</tr>
<tr>
<td><strong>SIGSTOP</strong></td>
<td><strong>暂停一个进程（不能被捕捉、阻塞或忽略）</strong></td>
<td><strong>终止</strong></td>
</tr>
<tr>
<td><strong>SIGTSTP</strong></td>
<td><strong>终端挂起符</strong>(<strong>Clt</strong>-Z)</td>
<td><strong>停止进程</strong></td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>后台进程请求从控制终端读</td>
<td></td>
</tr>
<tr>
<td>SIGTTOUT</td>
<td>后台进程请求向控制终端写</td>
<td></td>
</tr>
</tbody></table>
<h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a><strong>信号处理</strong></h4><p>忽略信号<br>不能忽略的信号：<br>    SIGKILL, SIGSTOP<br>    一些硬件异常信号<br>执行系统默认动作<br>捕捉信号</p>
<h2 id="5-2-信号相关命令"><a href="#5-2-信号相关命令" class="headerlink" title="5.2 信号相关命令"></a><strong>5.2</strong> <strong>信号相关命令</strong></h2><p>Kill</p>
<p>•   暂停 kill –STOP <pid></p>
<p>• 恢复 kill –CONT <pid></p>
<p>• 终止 kill –KILL  <pid></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>kill</td>
<td>发送信号给进程或进程组</td>
</tr>
<tr>
<td>raise</td>
<td>发送信号给进程自身</td>
</tr>
<tr>
<td>alarm</td>
<td>定时器时间到，向进程发送SIGALRM信号</td>
</tr>
<tr>
<td>pause</td>
<td>没有捕捉信号前一直将进程挂起</td>
</tr>
<tr>
<td>signal</td>
<td>捕捉信号SIGINT,  SIGQUIT时执行信号处理函数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>sigemptyset</th>
<th>初始化信号集合为空</th>
</tr>
</thead>
<tbody><tr>
<td>sigfillset</td>
<td>初始化信号集合为所有信号集合</td>
</tr>
<tr>
<td>sigaddset</td>
<td>将指定信号加入到指定集合</td>
</tr>
<tr>
<td>sigdelset</td>
<td>将指定信号从信号集中删除</td>
</tr>
<tr>
<td>sigprocmask</td>
<td>判断检测或更改信号屏蔽字</td>
</tr>
</tbody></table>
<h3 id="1-信号发送——kill-amp-raise"><a href="#1-信号发送——kill-amp-raise" class="headerlink" title="1 信号发送——kill &amp; raise"></a><strong>1</strong> <strong>信号发送</strong>——kill &amp; raise</h3><p>kill: send signal to a process</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;signal.h&gt;</p>
<p>int kill(pid_t pid, int sig);</p>
<p> (Returned Value: 0 if success, -1 if failure)</p>
<p>The “pid” parameter</p>
<p>  pid &gt; 0: 发送信号给进程id为pid的进程。</p>
<p>  pid =0:发送信号给与自己同组的所有进程。</p>
<p>  pid = -1: 发送系统内所有进程</p>
<p>  pid &lt; -1: 发送给进程组号为-pid的所有进程。</p>
<p>raise: send a signal to the current process</p>
<p>#include &lt;signal.h&gt;</p>
<p>int raise(int sig);</p>
<p> (Returned Value: 0 if success, -1 if failure)</p>
<h4 id="例3-9-设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。"><a href="#例3-9-设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。" class="headerlink" title="例3-9 设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。"></a>例3-9 设计一程序，要求用户进程复制出一个子进程，父进程向子进程发出SIGKILL信号，子进程收到此信号，结束子进程的运行。</h4><p>分析：用户进程fork子进程后，子进程使用raise函数发送SIGSTOP信号，使自己暂停；父进程使用kill函数向子进程发送SIGKILL信号，子进程收到信号结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>             	</span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="keyword">pid_t</span> result;	<span class="keyword">int</span> ret;	<span class="keyword">int</span> newret;</span><br><span class="line">       result=fork();        		</span><br><span class="line">       <span class="keyword">if</span>(result&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;    perror(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line">	     <span class="built_in">exit</span>(<span class="number">1</span>);       &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (result==<span class="number">0</span>)  	</span><br><span class="line">	&#123;    raise(SIGSTOP);    <span class="comment">/*调用raise函数，发送SIGSTOP 使子进程暂停*/</span></span><br><span class="line">	     <span class="built_in">exit</span>(<span class="number">0</span>);      &#125;</span><br><span class="line">	<span class="keyword">else</span>                    	</span><br><span class="line">	&#123;     <span class="built_in">printf</span>(<span class="string">&quot;子进程的进程号(PID)是：%d\n&quot;</span>,result);</span><br><span class="line">	      <span class="keyword">if</span>((waitpid(result,<span class="literal">NULL</span>,WNOHANG))==<span class="number">0</span>)</span><br><span class="line">	  &#123;  <span class="keyword">if</span>((ret=kill(result,SIGKILL))==<span class="number">0</span>)</span><br><span class="line">	      <span class="built_in">printf</span>(<span class="string">&quot;用kill函数返回值是：%d，发出的SIGKILL信号结束的进程进程号：%d\n&quot;</span>,ret,result);</span><br><span class="line">	    <span class="keyword">else</span>  &#123;   perror(<span class="string">&quot;kill函数结束子进程失败&quot;</span>); waitpid(result,<span class="literal">NULL</span>,<span class="number">0</span>); &#125;</span><br><span class="line">	  &#125;	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Waitpid（pid，<span class="literal">NULL</span>，WNOHANG）没有子进程终止立即返回，返回值为<span class="number">0</span></span><br><span class="line">由此例可知，系统调用kill函数和raise函数，都是简单地向某一进程发送信号。kill函数用于给特定的进程或进程组发送信号，raise函数用于向一个进程自身发送信号。</span><br></pre></td></tr></table></figure>

<h3 id="2-信号处理——-“signal”-函数"><a href="#2-信号处理——-“signal”-函数" class="headerlink" title="2 信号处理—— “signal” 函数"></a><strong>2</strong> <strong>信号处理</strong>—— “signal” <strong>函数</strong></h3><p>为编号为sgn的信号安装一个新的信号处理程序。</p>
<p>#include &lt;signal.h&gt;</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p> (Returned Value: the previous handler if success, SIG_ERR if error)</p>
<p>The “handler” parameter</p>
<p>​    a user specified function, or</p>
<p>​    SIG_DFL, or</p>
<p>​    SIG_IGN</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR1, sig_usr) == SIG_ERR) </span><br><span class="line">        err_sys(<span class="string">&quot;can&#x27;t catch SIGUSR1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">&quot;can&#x27;t catch SIGUSR2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">        pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-alarm-amp-pause-函数"><a href="#3-alarm-amp-pause-函数" class="headerlink" title="3 alarm &amp; pause 函数"></a><strong>3 alarm &amp; pause</strong> <strong>函数</strong></h3><p>alarm: 为信号的传送设置闹钟</p>
<p>#include &lt;unistd.h&gt;</p>
<p>unsigned int alarm(unsigned int seconds);</p>
<p> (Returned value: 0, or the number of seconds remaining of previous alarm)</p>
<p>pause: wait for a signal</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int pause(void);</p>
<p> (Returned value: -1, errno is set to be EINTR)</p>
<h3 id="4-信号阻塞"><a href="#4-信号阻塞" class="headerlink" title="**4.**信号阻塞"></a>**4.**信号阻塞</h3><p>有时既不希望进程在接收到信号时立刻中断进程的执行，也不希望此信号完全被忽略掉，而是延迟一段时间再去调用信号处理函数，这个时候就需要信号阻塞来完成。</p>
<h4 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a><strong>信号集处理函数</strong></h4><p>#include &lt;signal.h&gt;</p>
<p>int sigemptyset(sigset_t *set);</p>
<p>int sigfillset(sigset_t *set);</p>
<p>int sigaddset(sigset_t *set,int signum);</p>
<p>int sigdelset(sigset_t *set,int signum);</p>
<p>int sigismember(const sigset_t *set,int signum);</p>
<p>  参数：set 信号集 ；signum 信号</p>
<p>  返回值：若成功返回0，若出错返回-1。</p>
<p>  sigismember若真返回1，若假返回0，若出错返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;     <span class="keyword">sigset_t</span> *<span class="built_in">set</span>;</span><br><span class="line">      <span class="built_in">set</span>=(<span class="keyword">sigset_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>));</span><br><span class="line">      sigemptyset(<span class="built_in">set</span>);</span><br><span class="line">      sigaddset(<span class="built_in">set</span>,SIGUSR1);</span><br><span class="line">      sigaddset(<span class="built_in">set</span>,SIGINT);</span><br><span class="line">      <span class="keyword">if</span>((sigismember(<span class="built_in">set</span>,SIGUSR1))==<span class="number">1</span>)           <span class="built_in">printf</span>(<span class="string">&quot;SIGUSR1\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((sigismember(<span class="built_in">set</span>,SIGUSR2))==<span class="number">1</span>)           <span class="built_in">printf</span>(<span class="string">&quot;SIGUSR2\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>((sigismember(<span class="built_in">set</span>,SIGINT))==<span class="number">1</span>)                  <span class="built_in">printf</span>(<span class="string">&quot;SIGINT\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号集处理函数sigprocmask"><a href="#信号集处理函数sigprocmask" class="headerlink" title="信号集处理函数sigprocmask"></a><strong>信号集处理函数</strong>sigprocmask</h4><p>#include &lt;signal.h&gt;</p>
<p>功能：检测或更改信号屏蔽字</p>
<p>函数：int sigprocmask(int how,const sigsett_t *set,sigset_t *oldset);</p>
<p>参数：how 操作方式set  </p>
<p>  how决定函数的操作方式。</p>
<p>  SIG_BLOCK：增加一个信号集合到当前进程的阻塞集合之中。</p>
<p>  SIG_UNBLOCK：从当前的阻塞集合之中删除一个信号集合。</p>
<p>  SIG_SETMASK：将当前的信号集合设置为信号阻塞集合。 </p>
<p>返回值：若成功返回0，若出错返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">sigset_t</span> *<span class="built_in">set</span>;</span><br><span class="line">  <span class="built_in">set</span>=(<span class="keyword">sigset_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>));</span><br><span class="line">  sigemptyset(<span class="built_in">set</span>);</span><br><span class="line">  sigaddset(<span class="built_in">set</span>,SIGINT);</span><br><span class="line">  sigprocmask(SIG_SETMASK,<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//也可以使用：sigprocmask(SIG_BLOCK,set,NULL);</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序先定义信号集set，然后把信号SIGINT添加到set信号集中，最后把set设置为信号阻塞集合。运行程序时，进程进入死循环。按“ctrl+c”系统并没有中断程序，SIGINT信号屏蔽掉了。按”ctrl+z”来结束程序。 </p>
<h4 id="信号实例"><a href="#信号实例" class="headerlink" title="信号实例"></a><strong>信号实例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;        alarm(<span class="number">1</span>);          &#125;</span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">     signal(SIGALRM,handler);</span><br><span class="line">     alarm(<span class="number">1</span>);</span><br><span class="line">     sfd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"> 	<span class="comment">/*do</span></span><br><span class="line"><span class="comment">      &#123; sfd = open(argv[1],O_RDONLY);</span></span><br><span class="line"><span class="comment">         if (sfd&lt;0)</span></span><br><span class="line"><span class="comment">           &#123;  if (errno!= EINTR)</span></span><br><span class="line"><span class="comment">              &#123;  perror(&quot;open()&quot;);</span></span><br><span class="line"><span class="comment">                 exit(1);          &#125;      &#125;</span></span><br><span class="line"><span class="comment">    &#125;while(sfd&lt;0);*/</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;  pause();</span><br><span class="line">       len = read(sfd,buf,<span class="number">10</span>);</span><br><span class="line">      <span class="comment">/* while((len = read(sfd,buf,BUFSIZE))&lt;0)</span></span><br><span class="line"><span class="comment">     &#123;  if (errno == EINTR)</span></span><br><span class="line"><span class="comment">         continue;</span></span><br><span class="line"><span class="comment">        perror(&quot;read()&quot;);</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">      if (len==0) break;*/</span></span><br><span class="line"></span><br><span class="line">       ret = write(<span class="number">1</span>,buf,len);  </span><br><span class="line">     <span class="comment">/*while(len&gt;0)</span></span><br><span class="line"><span class="comment">     &#123;  ret = write(1,buf,len);</span></span><br><span class="line"><span class="comment">        if (ret &lt;0)</span></span><br><span class="line"><span class="comment">        &#123;  if (errno == EINTR)</span></span><br><span class="line"><span class="comment">             continue;</span></span><br><span class="line"><span class="comment">            perror(&quot;write&quot;);</span></span><br><span class="line"><span class="comment">            exit(1);</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">         len -= ret;</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-1-进程间通信"><a href="#6-1-进程间通信" class="headerlink" title="6.1 进程间通信"></a><strong>6.1</strong> <strong>进程间通信</strong></h2><p>IPC: Inter-Process Communication 进程间通信</p>
<p>IPC机制</p>
<p>​    shared file</p>
<p>​    signal</p>
<p>​    pipe, FIFO (named pipe), message queue, semaphore, shared memory</p>
<p>​    socket</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618215455459.png" alt="image-20210618215455459"></p>
<p><strong>Simple Client-Server or IPC model</strong></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210618215509159.png" alt="image-20210618215509159"></p>
<h2 id="6-2-pipe-概念"><a href="#6-2-pipe-概念" class="headerlink" title="6.2 pipe 概念"></a><strong>6.2 pipe</strong> <strong>概念</strong></h2><p>Pipe</p>
<p>Pipe mechanism in a shellShell中的管道机构</p>
<p>​    e.g. cmd1 | cmd2</p>
<p>Pipe is half-duplex 半双工</p>
<p>管道只能在共同祖先的进程间使用</p>
<p>管道也是文件</p>
<p>命名管道(FIFO)</p>
<h3 id="pipe-函数"><a href="#pipe-函数" class="headerlink" title="pipe 函数"></a><strong>pipe</strong> <strong>函数</strong></h3><p>The pipe function: create a pipe</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int pipe(int filedes[2]);</p>
<p> (Returned value: 0 if success, -1 if failure)</p>
<p>A pipe: First In, First Out</p>
<p>filedes[0]:read, filedes[1]: write</p>
<h3 id="单个进程使用管道"><a href="#单个进程使用管道" class="headerlink" title="单个进程使用管道"></a><strong>单个进程使用管道</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121308293.png" alt="image-20210619121308293"></p>
<h3 id="父子进程使用管道"><a href="#父子进程使用管道" class="headerlink" title="父子进程使用管道"></a><strong>父子进程使用管道</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121321411.png" alt="image-20210619121321411"></p>
<h3 id="管道使用-1-：单个进程"><a href="#管道使用-1-：单个进程" class="headerlink" title="管道使用(1)：单个进程"></a>管道使用(1)：单个进程</h3><p>类似共享文件</p>
<p>pipe—write——read</p>
<h3 id="管道使用（2）多进程"><a href="#管道使用（2）多进程" class="headerlink" title="管道使用（2）多进程"></a>管道使用（2）多进程</h3><p>父-子进程/子-子进程</p>
<p>使用模式：</p>
<p>  pipe——fork——write（写进程）</p>
<p>​            ——read（读进程）</p>
<p>注意：pipe-fork顺序</p>
<h3 id="管道使用（3）用于标准输入输出"><a href="#管道使用（3）用于标准输入输出" class="headerlink" title="管道使用（3）用于标准输入输出"></a>管道使用（3）用于标准输入输出</h3><p>管道：shell中的形式</p>
<p>​    cmd1 | cmd2</p>
<p>​    重定向 cmd &gt; file</p>
<p>实现代码</p>
<p>​    执行cmd1前</p>
<p>​    if (fd[1] != STDOUT_FILENO) {</p>
<p>​     if (dup2(fd[1], STDOUT_FILENO) != STDOUT_FILENO)</p>
<p>​        err_sys(“dup2 error to stdout); </p>
<p>​    }</p>
<p>执行cmd2前</p>
<p>​    if (fd[0] != STDIN_FILENO) {</p>
<p>​     if (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)</p>
<p>​        err_sys(“dup2 error to stdin); </p>
<p>​    }</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121557088.png" alt="image-20210619121557088"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span> data_processed;    <span class="keyword">int</span> file_pipes[<span class="number">2</span>];    </span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> some_data[] = <span class="string">&quot;123&quot;</span>;    <span class="keyword">pid_t</span> fork_result;    </span><br><span class="line">   <span class="keyword">if</span> (pipe(file_pipes) == <span class="number">0</span>) </span><br><span class="line">      &#123;     fork_result = fork();       </span><br><span class="line">            <span class="keyword">if</span> (fork_result == (<span class="keyword">pid_t</span>)<span class="number">-1</span>)</span><br><span class="line">                &#123;    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork failure&quot;</span>);   </span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);        &#125;             </span><br><span class="line">            <span class="keyword">if</span> (fork_result == (<span class="keyword">pid_t</span>)<span class="number">0</span>) </span><br><span class="line">                &#123;   close(<span class="number">0</span>);          </span><br><span class="line">                    dup(file_pipes[<span class="number">0</span>]);           </span><br><span class="line">                    close(file_pipes[<span class="number">0</span>]);            </span><br><span class="line">                    close(file_pipes[<span class="number">1</span>]);            </span><br><span class="line">                    execlp(<span class="string">&quot;od&quot;</span>, <span class="string">&quot;od&quot;</span>, <span class="string">&quot;-c&quot;</span>, (<span class="keyword">char</span> *)<span class="number">0</span>);            </span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);        </span><br><span class="line">                   &#125;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">    &#123;  close(file_pipes[<span class="number">0</span>]);           </span><br><span class="line">        data_processed = write(file_pipes[<span class="number">1</span>], some_data,<span class="built_in">strlen</span>(some_data)); </span><br><span class="line">        close(file_pipes[<span class="number">1</span>]);           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - wrote %d bytes\n&quot;</span>, (<span class="keyword">int</span>)getpid(),data_processed);       </span><br><span class="line">      &#125;    </span><br><span class="line">   &#125;    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>od –c file</strong> <strong>以字符方式显示文件内容，如果没指定文件则以标准输入作为默认输入</strong></p>
<h2 id="6-3-popen-amp-pclose-函数"><a href="#6-3-popen-amp-pclose-函数" class="headerlink" title="6.3 popen &amp; pclose 函数"></a><strong>6.3</strong> <strong>popen</strong> <strong>&amp;</strong> <strong>pclose</strong> <strong>函数</strong></h2><p>#include &lt;stdio.h&gt;<br>FILE *popen(const char *command, const char *type);<br>int pclose(FILE *stream);</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121713195.png" alt="image-20210619121713195"></p>
<p>fp=popen(cmd,”r”)的pipe实现：<br>    FILE * popen(char * cmd,char * type)<br>    {  int fd; int p;<br>       pipe(fd);<br>       p=fork();<br>       if(p==0)  {  close(1);dup(fd[1]);<br>                     execl(cmd,cmd,NULL);  }<br>       else       {   wait();<br>                         fp=fdopen(fd[0],”r”); return fp;  }<br>      }</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619121805879.png" alt="image-20210619121805879"></p>
<h4 id="例3-13-设计一程序，要求用popen创建管道，实现“ls-–l-grep-fifo”的功能。"><a href="#例3-13-设计一程序，要求用popen创建管道，实现“ls-–l-grep-fifo”的功能。" class="headerlink" title="例3-13 设计一程序，要求用popen创建管道，实现“ls –l|grep fifo”的功能。"></a>例3-13 设计一程序，要求用popen创建管道，实现“ls –l|grep fifo”的功能。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>	</span></span><br><span class="line"><span class="function"></span>&#123; 	FILE *fp;	<span class="keyword">int</span> num;   	<span class="keyword">char</span> buf[<span class="number">500</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf)); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;建立管道……\n&quot;</span>);</span><br><span class="line">	fp=popen(<span class="string">&quot;ls -l&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line">	<span class="keyword">if</span>(fp!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;  num=fread(buf,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">500</span>,fp);</span><br><span class="line">	   <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">	    &#123; <span class="built_in">printf</span>(<span class="string">&quot;第一个命令是“ls–l”，运行结果如下：\n&quot;</span>);</span><br><span class="line">	      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);	    &#125;</span><br><span class="line">	   pclose(fp);	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123; <span class="built_in">printf</span>(<span class="string">&quot;用popen创建管道错误\n&quot;</span>);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;	&#125;</span><br><span class="line">	fp=popen(“grep fifo<span class="string">&quot;,&quot;</span>w<span class="string">&quot;);   </span></span><br><span class="line"><span class="string">	printf(&quot;</span>第二个命令是“grep fifo”，运行结果如下：\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	fwrite(buf,sizeof(char),500,fp);</span></span><br><span class="line"><span class="string">	pclose(fp);</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用popen函数读写管道，实际上也是调用pipe函数建立一个管道，再调用fork函数建立子进程，接着会建立一个shell环境，并在这个shell环境中执行参数指定的进程。</p>
<h4 id="例3-14-在程序中获得另一个程序的输出"><a href="#例3-14-在程序中获得另一个程序的输出" class="headerlink" title="例3-14 在程序中获得另一个程序的输出"></a>例3-14 在程序中获得另一个程序的输出</h4><p>popen_two.c</p>
<p>gcc myuclc.c -o myuclc</p>
<p>gcc popen_two.c -o two</p>
<p>输入大写字母</p>
<p>按Ctrl+D结束程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">程序头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> line[MAXLINE];      FILE *fpin;  </span><br><span class="line">    fpin = popen(<span class="string">&quot;./myuclc&quot;</span>, <span class="string">&quot;r&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == fpin )          error_quit(<span class="string">&quot;popen error&quot;</span>);  </span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;prompt&gt; &quot;</span>, <span class="built_in">stdout</span>);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        <span class="keyword">if</span>( fgets(line, MAXLINE, fpin) == <span class="literal">NULL</span> )              <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF ) perror(<span class="string">&quot;fputs error to pipe&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>( pclose(fpin) == <span class="number">-1</span> )          perror (<span class="string">&quot;pclose error&quot;</span>);  </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Myuclc.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> c;  </span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        c = getchar();  </span><br><span class="line">        <span class="keyword">if</span>( EOF == c )  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isupper</span>(c) )  </span><br><span class="line">            c = <span class="built_in">tolower</span>(c);  </span><br><span class="line">        <span class="built_in">putchar</span>(c);  </span><br><span class="line">        <span class="keyword">if</span>( <span class="string">&#x27;\n&#x27;</span> == c )  </span><br><span class="line">            fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="6-4-FIFO-named-pipe命名管道"><a href="#6-4-FIFO-named-pipe命名管道" class="headerlink" title="6.4 FIFO: named pipe命名管道"></a>6.4 FIFO: named pipe命名管道</h2><p>管道和命名管道<br>相同点<br>不同点<br>    文件系统中<br>    内存传输数据<br>    同步：一个重要的考虑<br>mkfifo(1), mkfifo(3), mknod(1), mknod(2)</p>
<h3 id="创建FIFO"><a href="#创建FIFO" class="headerlink" title="创建FIFO"></a><strong>创建</strong>FIFO</h3><p>命令行方式：mknod filename p</p>
<p>​             mkfifo filename</p>
<p>程序方式：mkfifo: make a FIFO special file (a named pipe)</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/stat.h&gt;</p>
<p>int mkfifo(const char *pathname, mode_t mode);</p>
<p> (Returned value: 0 if success, -1 if failure)</p>
<p> 例： mkfifo(“/tmp/myfifo”,0666)</p>
<h3 id="访问FIFO"><a href="#访问FIFO" class="headerlink" title="访问FIFO"></a><strong>访问</strong>FIFO</h3><p>命令行方式</p>
<p>  (1)cat &lt; /tmp/myfifo       读FIFO文件</p>
<p>  (2)echo hello &gt;/tmp/myfifo 向FIFO写数据</p>
<p>  (3)cat &lt; /tmp/myfifo &amp;</p>
<p>​    echo “hello” &gt;/tmp/myfifo</p>
<h3 id="程序方式：用open打开一个FIFO"><a href="#程序方式：用open打开一个FIFO" class="headerlink" title="程序方式：用open打开一个FIFO"></a>程序方式：用open打开一个FIFO</h3><p>Review: “open” system call</p>
<p>int open(const char *pathname, int flags);</p>
<p>“flags” parameter</p>
<p>​    必须指定的互斥模式:</p>
<p>​        O_RDONLY, O_WRONLY, O_NONBLOCK</p>
<p>​    O_RDONLY：若无进程写方式打开FIFO，open阻塞</p>
<p>​    O_RDONLY |O_NONBLOCK：若无进程写方式打开FIFO，open立即返回文件描述符</p>
<p>​    O_WRONLY：若无进程读方式打开FIFO，open阻塞</p>
<p>​    O_WRONLY| O_NONBLOCK：若无进程读方式打开FIFO，open返回ENXIO错误,-1</p>
<h4 id="例3-15-两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo-p-c）一个消费者程序，从FIFO中读取数据（3-15fifo-c-c）。"><a href="#例3-15-两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo-p-c）一个消费者程序，从FIFO中读取数据（3-15fifo-c-c）。" class="headerlink" title="例3-15 两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo_p.c）一个消费者程序，从FIFO中读取数据（3-15fifo_c.c）。"></a>例3-15 两个程序通过FIFO传递数据，一个生产者程序创建并打开一个FIFO，向管道中写入数据。（3-15fifo_p.c）一个消费者程序，从FIFO中读取数据（3-15fifo_c.c）。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO_NAME <span class="meta-string">&quot;/tmp/my_fifo“</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define BUFFER_SIZE PIPE_BUF</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define TEN_MEG (1024 * 1024 * 10)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">int main()</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;    int pipe_fd;    int res;    int open_mode = O_WRONLY;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     int bytes_sent = 0;    char buffer[BUFFER_SIZE + 1];    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     if (access(FIFO_NAME, F_OK) == -1) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     /*int access(const char *filenpath, int mode) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 F_OK 只判断是否存在</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 有效，则函数返回0，否则函数返回-1 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	 */</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">     &#123;    res = mkfifo(FIFO_NAME, 0777);        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">          if (res != 0) &#123;   fprintf(stderr, &quot;</span>Could not create fifo %s\n<span class="meta-string">&quot;, FIFO_NAME);            exit(EXIT_FAILURE);        &#125;    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">      &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        printf(&quot;</span>Process %d opening FIFO O_WRONLY\n<span class="meta-string">&quot;, getpid());    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">       pipe_fd = open(FIFO_NAME, open_mode);    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">       printf(&quot;</span>Process %d result %d\n<span class="meta-string">&quot;, getpid(), pipe_fd);    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">      if (pipe_fd != -1)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">          &#123;  while(bytes_sent &lt; TEN_MEG) </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">               &#123; res = write(pipe_fd, buffer, BUFFER_SIZE);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                 if (res == -1) &#123;  fprintf(stderr, &quot;</span>Write <span class="meta-keyword">error</span> on pipe\n<span class="meta-string">&quot;); exit(EXIT_FAILURE);     &#125;  </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                 bytes_sent += res;        &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">             (void)close(pipe_fd);     &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">         else &#123;        exit(EXIT_FAILURE);            &#125;   </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  printf(&quot;</span>Process %d finished\n<span class="meta-string">&quot;, getpid());    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">  exit(EXIT_SUCCESS);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define FIFO_NAME &quot;</span>/tmp/my_fifo<span class="meta-string">&quot;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#define BUFFER_SIZE PIPE_BUF</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">int main()</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;   int pipe_fd;    int res;    int open_mode = O_RDONLY;    char buffer[BUFFER_SIZE + 1];</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    int bytes_read = 0;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    memset(buffer, &#x27;\0&#x27;, sizeof(buffer));    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    printf(&quot;</span>Process %d opening FIFO O_RDONLY\n<span class="meta-string">&quot;, getpid());</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    pipe_fd = open(FIFO_NAME, open_mode);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    printf(&quot;</span>Process %d result %d\n<span class="meta-string">&quot;, getpid(), pipe_fd);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    if (pipe_fd != -1) &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        do &#123;       res = read(pipe_fd, buffer, BUFFER_SIZE);      </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">                     bytes_read += res;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              &#125; while (res &gt; 0);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        (void)close(pipe_fd);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">      &#125; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    else &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        exit(EXIT_FAILURE);    &#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    printf(&quot;</span>Process %d finished, %d bytes read\n<span class="meta-string">&quot;, getpid(), bytes_read);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    exit(EXIT_SUCCESS);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>

<h3 id="FIFO的应用-1"><a href="#FIFO的应用-1" class="headerlink" title="FIFO的应用(1)"></a>FIFO的应用(1)</h3><p>用FIFO复制输出流</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619124043625.png" alt="image-20210619124043625"></p>
<p>mkfifo fifo1</p>
<p>prog3 &lt; fifo1 &amp;</p>
<p>prog1 &lt; infile | tee fifo1 | prog2</p>
<p><strong>tee命令读取标准输入，把这些内容同时输出到标准输出和（多个）文件中</strong> </p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619124101884.png" alt="image-20210619124101884"></p>
<h3 id="FIFO的应用-2"><a href="#FIFO的应用-2" class="headerlink" title="FIFO的应用(2)"></a>FIFO的应用(2)</h3><p>C/S应用程序</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619124145265.png" alt="image-20210619124145265"></p>
<h4 id="例3-16-client-c-server-c"><a href="#例3-16-client-c-server-c" class="headerlink" title="例3-16 client.c, server.c"></a>例3-16 client.c, server.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_FIFO_NAME <span class="meta-string">&quot;/tmp/serv_fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_FIFO_NAME <span class="meta-string">&quot;/tmp/cli_%d_fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_to_pass_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span>  client_pid;</span><br><span class="line">    <span class="keyword">char</span>   some_data[BUFFER_SIZE - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>     <span class="comment">// 客户端程序</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">int</span> server_fifo_fd, client_fifo_fd;    <span class="class"><span class="keyword">struct</span> <span class="title">data_to_pass_st</span> <span class="title">my_data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> times_to_send;    <span class="keyword">char</span> client_fifo[<span class="number">256</span>];</span><br><span class="line">    server_fifo_fd = open(SERVER_FIFO_NAME, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (server_fifo_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, no server\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);    &#125;</span><br><span class="line">    my_data.client_pid = getpid();</span><br><span class="line">    <span class="built_in">sprintf</span>(client_fifo, CLIENT_FIFO_NAME, my_data.client_pid);</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(client_fifo, <span class="number">0777</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, can&#x27;t make %s\n&quot;</span>, client_fifo);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);    &#125; </span><br><span class="line">    <span class="keyword">for</span> (times_to_send = <span class="number">0</span>; times_to_send &lt; <span class="number">5</span>; times_to_send++) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(my_data.some_data, <span class="string">&quot;Hello from %d&quot;</span>, my_data.client_pid); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d sent %s, &quot;</span>, my_data.client_pid, my_data.some_data);</span><br><span class="line">        write(server_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data));</span><br><span class="line">        client_fifo_fd = open(client_fifo, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (client_fifo_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(client_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received: %s\n&quot;</span>, my_data.some_data);            &#125;</span><br><span class="line">            close(client_fifo_fd);        &#125;    &#125;</span><br><span class="line">    close(server_fifo_fd);</span><br><span class="line">    unlink(client_fifo);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//服务端程序</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span> server_fifo_fd, client_fifo_fd;    <span class="class"><span class="keyword">struct</span> <span class="title">data_to_pass_st</span> <span class="title">my_data</span>;</span>    <span class="keyword">int</span> read_res;    <span class="keyword">char</span> client_fifo[<span class="number">256</span>];    <span class="keyword">char</span> *tmp_char_ptr;</span><br><span class="line">     mkfifo(SERVER_FIFO_NAME, <span class="number">0777</span>);</span><br><span class="line">    server_fifo_fd = open(SERVER_FIFO_NAME, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (server_fifo_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Server fifo failure\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>); <span class="comment">/* lets clients queue for demo purposes */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;   read_res = read(server_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data));</span><br><span class="line">             <span class="keyword">if</span> (read_res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             tmp_char_ptr = my_data.some_data;</span><br><span class="line">            <span class="keyword">while</span> (*tmp_char_ptr) &#123; </span><br><span class="line">              *tmp_char_ptr = <span class="built_in">toupper</span>(*tmp_char_ptr);   </span><br><span class="line">               tmp_char_ptr++;       &#125;</span><br><span class="line">            <span class="built_in">sprintf</span>(client_fifo, CLIENT_FIFO_NAME, my_data.client_pid);</span><br><span class="line">            client_fifo_fd = open(client_fifo, O_WRONLY);</span><br><span class="line">            <span class="keyword">if</span> (client_fifo_fd != <span class="number">-1</span>) &#123;</span><br><span class="line">                write(client_fifo_fd, &amp;my_data, <span class="keyword">sizeof</span>(my_data));</span><br><span class="line">                close(client_fifo_fd);    &#125;</span><br><span class="line">        &#125;    &#125; <span class="keyword">while</span> (read_res &gt; <span class="number">0</span>);</span><br><span class="line">    close(server_fifo_fd);</span><br><span class="line">    unlink(SERVER_FIFO_NAME);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例3-17-l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。"><a href="#例3-17-l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。" class="headerlink" title="例3-17 l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。"></a>例3-17 l设计两个程序，要求用命名管道FIFO实现简单的聊天功能。</h4><p>Zhang.c</p>
<p>Li.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span> i, rfd,wfd,len=<span class="number">0</span>,fd_in;    <span class="keyword">char</span> str[<span class="number">32</span>];    <span class="keyword">int</span> flag,stdinflag;    fd_set write_fd,read_fd;    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">net_timer</span>;</span></span><br><span class="line">    mkfifo(<span class="string">&quot;fifo1&quot;</span>,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span><br><span class="line">    mkfifo(<span class="string">&quot;fifo2&quot;</span>,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span><br><span class="line">    wfd =open(<span class="string">&quot;fifo1&quot;</span>,O_WRONLY);     rfd =open(<span class="string">&quot;fifo2&quot;</span>,O_RDONLY);     <span class="keyword">if</span>(rfd&lt;=<span class="number">0</span>||wfd&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;      <span class="built_in">printf</span>(“这是张三端!\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    while(1)</span></span><br><span class="line"><span class="string">    &#123;   FD_ZERO(&amp;read_fd);   	</span></span><br><span class="line"><span class="string">        FD_SET(rfd,&amp;read_fd); 	</span></span><br><span class="line"><span class="string">        FD_SET(fileno(stdin),&amp;read_fd); /**/</span></span><br><span class="line"><span class="string">        net_timer.tv_sec=5;</span></span><br><span class="line"><span class="string">        net_timer.tv_usec=0;</span></span><br><span class="line"><span class="string">        memset(str,0,sizeof(str)); </span></span><br><span class="line"><span class="string">        if(i=select(rfd+1, &amp;read_fd,NULL, NULL, &amp;net_timer) &lt;= 0)            continue;</span></span><br><span class="line"><span class="string">        if(FD_ISSET(rfd,&amp;read_fd))</span></span><br><span class="line"><span class="string">    	&#123;      read(rfd,str,sizeof(str));             printf(&quot;</span>----------------------------\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">            printf(&quot;</span>李四:%s\n<span class="string">&quot;,str);     	&#125;</span></span><br><span class="line"><span class="string">        if(FD_ISSET(fileno(stdin),&amp;read_fd)) </span></span><br><span class="line"><span class="string">    	&#123;     printf(&quot;</span>----------------------------\n<span class="string">&quot;);            fgets(str,sizeof(str),stdin);</span></span><br><span class="line"><span class="string">            len=write(wfd,str,strlen(str)); </span></span><br><span class="line"><span class="string">    	&#125;    &#125;</span></span><br><span class="line"><span class="string">    close(rfd);</span></span><br><span class="line"><span class="string">    close(wfd);&#125;</span></span><br><span class="line"><span class="string">                                                                                                              </span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;	int i, rfd,wfd,len=0,fd_in;	char str[32];	int flag,stdinflag;</span></span><br><span class="line"><span class="string">	fd_set write_fd,read_fd;	struct timeval net_timer;</span></span><br><span class="line"><span class="string">	mkfifo(&quot;</span>fifo1<span class="string">&quot;,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span></span><br><span class="line"><span class="string">	mkfifo(&quot;</span>fifo2<span class="string">&quot;,S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH); </span></span><br><span class="line"><span class="string">	rfd =open(&quot;</span>fifo1<span class="string">&quot;,O_RDONLY); 	wfd =open(&quot;</span>fifo2<span class="string">&quot;,O_WRONLY); </span></span><br><span class="line"><span class="string">	if(rfd&lt;=0||wfd&lt;=0)return 0;		printf(&quot;</span>这是李四端!\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	while(1)</span></span><br><span class="line"><span class="string">	&#123; FD_ZERO(&amp;read_fd); 	FD_SET(rfd,&amp;read_fd);	</span></span><br><span class="line"><span class="string">	  FD_SET(fileno(stdin),&amp;read_fd);		net_timer.tv_sec=5;</span></span><br><span class="line"><span class="string">	  net_timer.tv_usec=0;		memset(str,0,sizeof(str)); </span></span><br><span class="line"><span class="string">	  if(i=select(rfd+1,&amp;read_fd,NULL, NULL, &amp;net_timer) &lt;= 0)	continue;</span></span><br><span class="line"><span class="string">		if(FD_ISSET(rfd,&amp;read_fd))</span></span><br><span class="line"><span class="string">		&#123;	read(rfd,str,sizeof(str)); </span></span><br><span class="line"><span class="string">			printf(&quot;</span>----------------------------\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			printf(&quot;</span>张三:%s\n<span class="string">&quot;,str); 		&#125;</span></span><br><span class="line"><span class="string">		if(FD_ISSET(fileno(stdin),&amp;read_fd))</span></span><br><span class="line"><span class="string">		&#123;	printf(&quot;</span>----------------------------\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			fgets(str,sizeof(str),stdin);</span></span><br><span class="line"><span class="string">			len=write(wfd,str,strlen(str)); /*写入管道*/		&#125;</span></span><br><span class="line"><span class="string">	&#125;	close(rfd);</span></span><br><span class="line"><span class="string">	close(wfd);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-1-System-V-IPC的共同特征"><a href="#7-1-System-V-IPC的共同特征" class="headerlink" title="7.1 System V IPC的共同特征"></a><strong>7.1 System V IPC</strong>的共同特征</h2><p>进程间通信（interprocess communication）</p>
<p>IPC objects</p>
<ul>
<li><p>信号量(semaphore set)</p>
</li>
<li><p>消息队列(message queue)</p>
</li>
<li><p>共享内存(shared memory)</p>
</li>
</ul>
<p>shell命令</p>
<ul>
<li><p>ipcs  -q/-m/-s</p>
</li>
<li><p>ipcrm –q/-m/-s <id></p>
</li>
<li><p>ipcrm -Q/-M/-S <key></p>
</li>
</ul>
<p>标识符与关键字<br>    创建IPC对象时指定关键字(key_t key;)<br>        key的选择；预定义常数IPC_PRIVATE；ftok函数<br>    引用IPC对象：标识符<br>    内核将关键字转换成标识符<br>许可权结构<br>    和文件类比<br>    struct ipc_perm</p>
<h3 id="SV-IPC-System-Calls-Overview"><a href="#SV-IPC-System-Calls-Overview" class="headerlink" title="SV IPC System Calls Overview"></a><strong>SV IPC System Calls Overview</strong></h3><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>消息队列</strong></th>
<th><strong>信号量</strong></th>
<th><strong>共享内存</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分配一个IPC对象，获得对IPC的访问</td>
<td>msgget</td>
<td>semget</td>
<td>shmget</td>
</tr>
<tr>
<td>IPC操作:  发送/接收消息，信号量操作，连接/释放共享内存</td>
<td>msgsnd/  msgrcv</td>
<td>semop</td>
<td>shmat/  shmdt</td>
</tr>
<tr>
<td>IPC控制：获得/修改状态信息，取消IPC</td>
<td>msgctl</td>
<td>semctl</td>
<td>shmctl</td>
</tr>
</tbody></table>
<h3 id="ftok函数"><a href="#ftok函数" class="headerlink" title="ftok函数"></a><strong>ftok</strong>函数</h3><p>创建函数</p>
<p>key_t ftok( char * filename, int id)；</p>
<p>功能说明</p>
<p>将一个已存在的文件名(该文件必须是存在而且可以访问的)和一个整数标识符id转换成一个key_t值</p>
<p>在Linux系统实现中，调用该函数时，系统将文件的索引节点号取出，并在前面加上子序号，从而得到key_t的返回值</p>
<h3 id="创建IPC对象"><a href="#创建IPC对象" class="headerlink" title="创建IPC对象"></a>创建IPC对象</h3><p>key：可由ftok()函数产生或定义为IPC_PRIVATE常量</p>
<p>flag：包括读写权限，还可包含IPC_CREATE和IPC_EXCL标志位，组合效果如下</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133437323.png" alt="image-20210619133437323"></p>
<h2 id="7-2-Message-queue"><a href="#7-2-Message-queue" class="headerlink" title="7.2 Message queue"></a><strong>7.2 Message queue</strong></h2><p>消息队列<br><strong>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</strong><br>First in, first out<br>message type: 优先级=<br>块数据</p>
<h3 id="消息队列——程序结构"><a href="#消息队列——程序结构" class="headerlink" title="消息队列——程序结构"></a>消息队列——程序结构</h3><p>proto.h:约定的消息队列通信格式<br>send.c<br>receive.c</p>
<p>proto.h:约定的消息队列通信格式:</p>
<p>  #define KEYPATH “/etc/services”</p>
<p>  #define KEYPROJ ‘a’</p>
<p>  struct msg_st {</p>
<p>​     char * msg;</p>
<p>​     long  type;</p>
<p>​     …</p>
<p>   }</p>
<h3 id="消息队列——系统函数"><a href="#消息队列——系统函数" class="headerlink" title="消息队列——系统函数"></a>消息队列——系统函数</h3><p>#include &lt;sys/types.h&gt;<br>#include &lt;sys/ipc.h&gt;<br>#include &lt;sys/msg.h&gt;</p>
<p>int msgget(key_t key, int flag);<br>int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);<br>int msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);<br>int msgctl(int msqid, int cmd, struct shmid_ds *buf);</p>
<h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a><strong>msgget</strong></h3><p>Ø函数原型  int msgget(key_t key, int flag);</p>
<p>Ø参数说明</p>
<p>ü  key：待创建/打开队列的键值</p>
<p>ü  flag：创建/打开方式</p>
<p>​    常取IPC_CREAT|IPC_EXCL|0666</p>
<p>​    若不存在key值的队列，则创建；否则，若存在，则打开队列</p>
<p>​    0666表示与一般文件权限一样</p>
<p>Ø返回值</p>
<p>​    成功返回消息队列描述字，否则返回-1</p>
<p>Ø说明</p>
<p>   IPC_CREAT一般由服务器程序创建消息队列时使用</p>
<p>   若是客户程序，须打开现有消息队列，而不用IPC_CREAT </p>
<h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a><strong>msgsnd</strong></h3><p>Ø函数原型</p>
<p>int msgsnd(int msqid, struct msgbuf *msgp, size_t size, int flag);</p>
<p>Ø说明</p>
<p>flag有意义的标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待</p>
<p>Ø内核须对msgsnd( )函数完成的工作</p>
<p>ü检查消息队列描述符、许可权及消息长度</p>
<p>​    若合法，继续执行;否则，返回</p>
<p>ü内核为消息分配数据区，将消息正文拷贝到消息数据区</p>
<p>ü分配消息首部，并将它链入消息队列的末尾</p>
<p>ü修改消息队列头数据，如队列中的消息数、字节总数等</p>
<p>ü唤醒等待消息的进程</p>
<h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a><strong>msgrcv</strong></h3><p>Øint msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);</p>
<p>Ø参数说明</p>
<p>l   msgid：消息队列描述字</p>
<p>l   msgp：消息存储位置</p>
<p>l   size：消息内容的长度</p>
<p>l   type：请求读取的消息类型</p>
<p>l   flag：规定队列无消息时内核应做的操作 </p>
<p>​     IPC_NOWAIT：无满足条件消息时返回，此时errno=ENOMSG</p>
<p>​     IPC_EXCEPT：type&gt;0时使用，返回第一个类型不为type的消息 </p>
<p>​     IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的size字节，则把该消息截断，截断部分将丢失</p>
<h3 id="msgctl-message-control-operations"><a href="#msgctl-message-control-operations" class="headerlink" title="msgctl: message control operations"></a>msgctl: message control operations</h3><p>函数原型<br>int msgctl(int msqid, int cmd, struct msqid_ds *buf);<br>“cmd” 参数<br>IPC_STAT: 把msqid_ds结构中的数据置为消息队列的当前关联值<br>IPC_SET: 在进程有足够权限的前提下，把消息队列的当前关联值置为msqid_ds结构给出的值<br>IPC_RMID: 删除消息队列</p>
<h3 id="消息队列——Example"><a href="#消息队列——Example" class="headerlink" title="消息队列——Example"></a>消息队列——Example</h3><p>A C/S application<br>一台服务器，多个客户机：只需要一个队列。与FIFO实现相比</p>
<h3 id="消息队列属性"><a href="#消息队列属性" class="headerlink" title="消息队列属性"></a><strong>消息队列属性</strong></h3><p>消息队列创建后，操作系统在内核中分配了一个名称为msqid_ds的数据结构用于管理该消息队列。<br>在程序中可以通过函数msgctl对该结构进行读写，从而实现对消息队列的控制功能。 </p>
<p>成员说明：<br>1）msg_perm：IPC许可权限结构。<br>2）msg_stime：最后一次向该消息队列发送消息（msgsnd）的时间。<br>3）msg_rtime：最后一次从该消息队列接收消息（msgrcv）的时间。<br>4）msg_ctime：最后一次调用msgctl的时间。<br>5）msg_cbytes：当前该消息队列中的消息长度，以字节为单位。<br>6）msg_qnum：当前该消息队列中的消息条数。<br>7）msg_qbytes：该消息队列允许存储的最大长度，以字节为单位。<br>8）msg_lspid：最后一次向该消息队列发送消息（msgsnd）的进程ID。<br>9）msg_lrpid：最后一次从该消息队列接收消息（msgrcv）的进程ID。</p>
<p>使用：<br>    msg_sinfo.msg_qbytes = 1666;<br>    msgctl(msgqid,IPC_SET,&amp;msg_sinfo)</p>
<h4 id="例3-18-msg-stat-c"><a href="#例3-18-msg-stat-c" class="headerlink" title="例3-18 msg_stat.c"></a>例3-18 msg_stat.c</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133908134.png" alt="image-20210619133908134"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133920223.png" alt="image-20210619133920223"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133947032.png" alt="image-20210619133947032"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619133957944.png" alt="image-20210619133957944"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619134026407.png" alt="image-20210619134026407"></p>
<h2 id="7-3-Shared-memory"><a href="#7-3-Shared-memory" class="headerlink" title="7.3 Shared memory"></a><strong>7.3 Shared memory</strong></h2><p>共享内存是内核为进程创建的一个特殊内存段，它可连接(attach)到自己的地址空间，也可以连接到其它进程的地址空间</p>
<p>​    最快的进程间通信方式</p>
<p>​    不提供任何同步功能</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619134117718.png" alt="image-20210619134117718"></p>
<h3 id="共享内存实现途径"><a href="#共享内存实现途径" class="headerlink" title="共享内存实现途径"></a><strong>共享内存实现途径</strong></h3><p>mmap()系统调用</p>
<p>  将普通文件在不同的进程中打开并映射到内存</p>
<p>  不同进程通过访问映射来达到共享内存目的</p>
<p>POSIX共享内存机制（Linux 2.6未实现）</p>
<p>System V共享内存</p>
<p>  在内存文件系统tmpfs中建立文件</p>
<p>  文件映射到不同进程空间</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h3><p>lmmap()系统调用使得==进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write()等操作。==</p>
<p>#include &lt; unistd.h &gt;</p>
<p>#include &lt;sys/mman.h &gt;</p>
<p>void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset )</p>
<p>int munmap( void * addr, size_t len ) </p>
<p>int msync ( void * addr , size_t len, int flags) </p>
<p>void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset ) </p>
<p>addr:指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。</p>
<p>len:映射到调用进程地址空间的字节数，从被映射文件开头offset个字节开始算起。 </p>
<p>prot :指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。</p>
<p>flags;指定映射对象的类型，映射选项和映射页是否可以共享。由以下几个常值指定：MAP_SHARED , MAP_PRIVATE 必选其一。</p>
<p>fd:为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANONYMOUS，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，只能用于具有亲缘关系的进程间通信）。</p>
<p>offset参数一般设为0，表示从文件头开始映射。</p>
<p>函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。</p>
<p>mmap()用于共享内存的两种方式 ：</p>
<p> （1）使用普通文件提供的内存映射：适用于任何进程之间；需要打开或创建一个文件，然后再调用mmap()；调用代码如下：</p>
<p>   fd=open(name, flag, mode);</p>
<p>   if(fd&gt;0)</p>
<p>   ptr=mmap(NULL, len , PROT_READ|PROT_WRITE,  </p>
<p>​            MAP_SHARED , fd , 0); </p>
<p>（2） 使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；</p>
<p>l调用代码如下：</p>
<p>  ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS ,-1 , 0); </p>
<p>由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。在调用fork()之后，子进程继承父进程匿名映射后的地址空间，也继承mmap()返回的地址 </p>
<p>  不必指定具体的文件，只要设置相应的标志即可 </p>
<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap()"></a><strong>munmap()</strong></h3><p>int munmap( void * addr, size_t len )<br> 该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<h3 id="msync"><a href="#msync" class="headerlink" title="msync()"></a><strong>msync</strong>()</h3><p>  int msync ( void * addr , size_t len, int flags)<br> 一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。 </p>
<h4 id="例3-19mmap-c-l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。"><a href="#例3-19mmap-c-l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。" class="headerlink" title="例3-19mmap.c l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。"></a>例3-19mmap.c l设计一个程序，要求复制进程，父子进程通过匿名映射实现共享内存。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>     	</span></span><br><span class="line"><span class="class">&#123;</span>	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) 	</span><br><span class="line"> &#123; 	<span class="keyword">pid_t</span> result;   	<span class="keyword">int</span> i;	people *p_map;	<span class="keyword">char</span> temp;</span><br><span class="line">	p_map=(people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);   </span><br><span class="line">  result=fork();      	</span><br><span class="line">	<span class="keyword">if</span>(result&lt;<span class="number">0</span>) </span><br><span class="line">	&#123;	perror(<span class="string">&quot;创建子进程失败&quot;</span>);	<span class="built_in">exit</span>(<span class="number">0</span>);	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (result==<span class="number">0</span>)	</span><br><span class="line">	&#123;	sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子进程读取: 第 %d 个人的年龄是： %d\n&quot;</span>,i+<span class="number">1</span>,(*(p_map+i)).age);</span><br><span class="line">		(*p_map).age = <span class="number">110</span>;</span><br><span class="line">		munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>); <span class="comment">/*解除内存映射关系*/</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">		temp = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		&#123;	temp += <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memcpy</span>((*(p_map+i)).name, &amp;temp,<span class="number">1</span>);</span><br><span class="line">			(*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;父进程读取: 五个人的年龄和是： %d\n&quot;</span>,(*p_map).age );</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;解除内存映射……\n&quot;</span>);</span><br><span class="line">		munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;解除内存映射成功！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用特殊文件提供匿名内存映射，适用于具有亲缘关系的进程之间。==一般而言，子进程单独维护从父进程继承下来的一些变量。而mmap函数的返回地址，由父子进程共同维护。==</p>
<h3 id="System-V-IPC共享内存的实现"><a href="#System-V-IPC共享内存的实现" class="headerlink" title="System V IPC共享内存的实现"></a><strong>System V IPC</strong>共享内存的实现</h3><p>通过映射到tmpfs中的shm文件对象实现共享主存</p>
<ul>
<li>  每个共享主存区对应tmpfs中的一个文件（通过shmid_kernel关联）</li>
</ul>
<p>创建过程</p>
<ol>
<li>从主存申请共享主存管理结构，初始化相应shmid_kernel结构</li>
<li>在tmpfs中创建并打开一个同名文件</li>
<li>在主存中建立与该文件对应的dentry及inode结构</li>
<li>返回相应标识符</li>
</ol>
<h3 id="System-V-shared-memory"><a href="#System-V-shared-memory" class="headerlink" title="System V shared memory"></a><strong>System V shared memory</strong></h3><p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/ipc.h&gt;</p>
<p>#include &lt;sys/shm.h&gt;</p>
<p>int shmget(key_t key, int size, int flag);</p>
<p>void *shmat(int shmid, void *addr, int flag);</p>
<p>int shmdt(void *addr);</p>
<p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</p>
<h3 id="mmap和System-V"><a href="#mmap和System-V" class="headerlink" title="mmap和System V"></a>mmap和System V</h3><p>1.System V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。</p>
<p>2.System V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。</p>
<h2 id="7-4-信号量"><a href="#7-4-信号量" class="headerlink" title="7.4 信号量"></a><strong>7.4</strong> <strong>信号量</strong></h2><p>用来协调进程对共享资源的访问 </p>
<p>相关函数semget，semop，semctl</p>
<p>所需头文件</p>
<p>  #include &lt;sys/types.h&gt;</p>
<p>  #include &lt;sys/ipc.h&gt;</p>
<p>  #include &lt;sys/sem.h&gt;</p>
<h3 id="相关函数——semget"><a href="#相关函数——semget" class="headerlink" title="相关函数——semget"></a>相关函数——semget</h3><p>创建一个新信号量或取得一个已有信号量，原型为：int semget(key_t key, int num_sems, int sem_flags); </p>
<p><strong>参数key****：</strong>整数值 </p>
<p><strong>参数num_sems</strong>：指定需要的信号量数目，几乎总是1。 </p>
<p><strong>参数sem_flags</strong>：一组标志，信号量不存在时创建一个新的信号量，指定IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。</p>
<p>   指定IPC_CREAT | IPC_EXCL，创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。 </p>
<p><strong>返回值</strong>：成功返回一个相应信号标识符（非零），失败返回-1. </p>
<h3 id="相关函数——semop"><a href="#相关函数——semop" class="headerlink" title="相关函数——semop"></a>相关函数——semop</h3><p>操作一个或一组信号 ，原型为：</p>
<p>int semop(int sem_id, struct sembuf *sem_opa, size_t nsops); </p>
<p>​    semid：信号集的识别码，可通过<a target="_blank" rel="noopener" href="http://baike.baidu.com/subview/5298141/5328468.htm">semget</a>获取。</p>
<p>​    sem_opa：指向存储信号操作结构的<a target="_blank" rel="noopener" href="http://baike.baidu.com/subview/3026322/3026322.htm">数组指针</a>，信号操作结构的原型如下</p>
<p>  <strong>struct</strong> sembuf{ </p>
<p>​    <strong>short</strong> sem_num;  //信号量集中的信号量编号0，1…… </p>
<p>​    <strong>short</strong> sem_op;   //信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，一个是+1。 </p>
<p>​    <strong>short</strong> sem_flg;//通常为SEM_UNDO,使操作系统跟踪信号并在进程没有释放该信号量而终止时，操作系统释放信号量 </p>
<p>   }; </p>
<p>lnsops：信号量操作结构的数量，大于或等于1</p>
<h3 id="相关函数——semctl"><a href="#相关函数——semctl" class="headerlink" title="相关函数——semctl"></a>相关函数——semctl</h3><p>该函数用来直接控制信号量信息，它的原型为</p>
<p>int semctl(int sem_id, int sem_num, int command, …); </p>
<p>第四个参数，它通常是一个union semum结构，定义如下： </p>
<p><strong>union</strong> semun{ </p>
<p>  <strong>int</strong> val; </p>
<p>  <strong>struct</strong> semid_ds *buf; </p>
<p>  unsigned <strong>short</strong> *arry; </p>
<p>}; </p>
<h4 id="例3-20sem1-c"><a href="#例3-20sem1-c" class="headerlink" title="例3-20sem1.c"></a>例3-20sem1.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">char</span> message = <span class="string">&#x27;X&#x27;</span>;      <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)          </span><br><span class="line">        message = argv[<span class="number">1</span>][<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  </span><br><span class="line">    &#123;   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        sleep(rand() % <span class="number">3</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message);  </span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        sleep(rand() % <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    sleep(<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d - finished\n&quot;</span>, getpid());  </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="例3-21sem2-c"><a href="#例3-21sem2-c" class="headerlink" title="例3-21sem2.c"></a>例3-21sem2.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span>  </span><br><span class="line">    sem_union.val = <span class="number">1</span>; <span class="comment">//用于初始化信号量 </span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span>  </span><br><span class="line">      <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to delete semaphore\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;      <span class="comment">//对信号量做减1操作，即等待P（sv）  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span>  </span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;  </span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;<span class="comment">//P()  </span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;  </span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_p failed\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//这是一个释放操作，它使信号量变为可用，即发送信号V（sv）  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span>  </span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;  </span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;<span class="comment">//V()  </span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;  </span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;semaphore_v failed\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span>  </span></span><br><span class="line"><span class="class">&#123;</span>   <span class="keyword">int</span> val;      <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>      <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;  &#125;;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sem_id = <span class="number">0</span>;    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="keyword">char</span> message = <span class="string">&#x27;X&#x27;</span>;      <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">     sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT); <span class="comment">//创建信号量  </span></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)  </span><br><span class="line">    &#123;  <span class="keyword">if</span>(!set_semvalue())         <span class="comment">//程序第一次被调用，初始化信号量     </span></span><br><span class="line">             &#123;  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “Failed to initialize semaphore\n”);          </span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE); &#125;  </span><br><span class="line">       message = argv[<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//设置要输出到屏幕中的信息，即其参数的第一个字符 </span></span><br><span class="line">        sleep(<span class="number">2</span>);     </span><br><span class="line">      &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  </span><br><span class="line">    &#123;   <span class="keyword">if</span>(!semaphore_p())   <span class="comment">//进入临界区 前执行P操作</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message);          fflush(<span class="built_in">stdout</span>);          sleep(rand() % <span class="number">3</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, message); <span class="comment">//离开临界区前再一次向屏幕输出数据 </span></span><br><span class="line">        fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">        <span class="keyword">if</span>(!semaphore_v())  </span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">//离开临界区，休眠随机时间后继续循环 </span></span><br><span class="line">        sleep(rand() % <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    sleep(<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d - finished\n&quot;</span>, getpid());  </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)      &#123;   sleep(<span class="number">3</span>);          del_semvalue();      &#125; </span><br><span class="line">         <span class="comment">//如果程序是第一次被调用，则在退出前删除信号量 </span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h2 id="雨课堂题目整理-2"><a href="#雨课堂题目整理-2" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220213435.png" alt="image-20210610220213435"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220229500.png" alt="image-20210610220229500"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220240603.png" alt="image-20210610220240603"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220250059.png" alt="image-20210610220250059"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220300339.png" alt="image-20210610220300339"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220310461.png" alt="image-20210610220310461"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220321107.png" alt="image-20210610220321107"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220333714.png" alt="image-20210610220333714"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220410424.png" alt="image-20210610220410424"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220418478.png" alt="image-20210610220418478"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220429370.png" alt="image-20210610220429370"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220438832.png" alt="image-20210610220438832"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220449449.png" alt="image-20210610220449449"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220502760-1623333903786.png" alt="image-20210610220502760"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220526628.png" alt="image-20210610220526628"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220536612.png" alt="image-20210610220536612"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220544837.png" alt="image-20210610220544837"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220603324.png" alt="image-20210610220603324"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220612511.png" alt="image-20210610220612511"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220619429.png" alt="image-20210610220619429"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220627025.png" alt="image-20210610220627025"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220637248.png" alt="image-20210610220637248"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220655591.png" alt="image-20210610220655591"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220705258.png" alt="image-20210610220705258"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220715535.png" alt="image-20210610220715535"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220730081.png" alt="image-20210610220730081"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220748981.png" alt="image-20210610220748981"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220804988.png" alt="image-20210610220804988"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220811818.png" alt="image-20210610220811818"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220821845.png" alt="image-20210610220821845"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220829105.png" alt="image-20210610220829105"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220836629.png" alt="image-20210610220836629"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220844183.png" alt="image-20210610220844183"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220851954.png" alt="image-20210610220851954"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220908753.png" alt="image-20210610220908753"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220915232.png" alt="image-20210610220915232"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220927300.png" alt="image-20210610220927300"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220935403.png" alt="image-20210610220935403"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220943592.png" alt="image-20210610220943592"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220952495.png" alt="image-20210610220952495"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610220959961.png" alt="image-20210610220959961"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221006902.png" alt="image-20210610221006902"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221014835.png" alt="image-20210610221014835"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221021551.png" alt="image-20210610221021551"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210610221029470.png" alt="image-20210610221029470"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  num;</span><br><span class="line"></span><br><span class="line">&#125; number;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    number *p_map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p_map=(number*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(number)*<span class="number">10000</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS ,fp,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    result=fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程开始读取&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tempC;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>,length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            temp = read(fp, &amp;tempC, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,tempC);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tempC==<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                readSize = readSize+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程读取: 第 %d 个a\n&quot;</span>,++i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程读取wan: 第 %d 个a\n&quot;</span>,++i);</span><br><span class="line"></span><br><span class="line">        (*p_map).num = readSize;</span><br><span class="line"></span><br><span class="line">        munmap(p_map,<span class="keyword">sizeof</span>(number)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;父进程读取: a的个数是： %d\n&quot;</span>,(*p_map).num );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;解除内存映射……\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        munmap(p_map,<span class="keyword">sizeof</span>(number)*<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;解除内存映射成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="0-服务器和客户机的信息函数"><a href="#0-服务器和客户机的信息函数" class="headerlink" title="0 服务器和客户机的信息函数"></a><strong>0</strong> <strong>服务器和客户机的信息函数</strong></h2><h3 id="1-字节序列转换"><a href="#1-字节序列转换" class="headerlink" title="**1.**字节序列转换"></a>**1.**字节序列转换</h3><p>每一台机器内部对变量的字节存储顺序不同，而网络传输的数据是一定要统一顺序的。所以对内部字节表示顺序与网络字节顺序（大端）不同的机器，一定要对数据进行转换</p>
<p>真正转换还是不转换是由系统函数自己来决定的。 </p>
<p>头文件：include &lt;arpa/inet.h&gt; </p>
<p> unsigned short int htons（unsigned short int hostshort）：<br> 主机字节顺序转换成网络字节顺序，对无符号短型进行操作4bytes<br> unsigned long int htonl（unsigned long int hostlong）：<br> 主机字节顺序转换成网络字节顺序，对无符号长型进行操作8bytes<br> unsigned short int ntohs（unsigned short int netshort）：<br> 网络字节顺序转换成主机字节顺序，对无符号短型进行操作4bytes<br> unsigned long int ntohl（unsigned long int netlong）：<br> 网络字节顺序转换成主机字节顺序，对无符号长型进行操作8bytes</p>
<h3 id="2-地址格式转换"><a href="#2-地址格式转换" class="headerlink" title="**2.**地址格式转换"></a>**2.**地址格式转换</h3><p><strong>头文件</strong>：#include &lt;sys/types.h&gt; 　　</p>
<p>​       #include &lt;sys/socket.h&gt; 　　</p>
<p>​       #include &lt;arpa/inet.h&gt; </p>
<p><strong>int</strong> inet_pton(<strong>int</strong> family, <strong>const</strong> <strong>char</strong> *strptr, <strong>void</strong> *addrptr); </p>
<p>转换字符串到网络地址 。 返回：1成功；-1出错 </p>
<p><strong>const</strong> <strong>char</strong>* inet_ntop(<strong>int</strong> family, <strong>const</strong> <strong>void</strong> *addrptr, <strong>char</strong> *strptr, <strong>size_t</strong> len); </p>
<p>转换网络二进制结构到ASCII类型的地址</p>
<p> 返回：成功，指向结果的指针；出错，NULL  </p>
<h2 id="1-Socket-基础"><a href="#1-Socket-基础" class="headerlink" title="1 Socket 基础"></a><strong>1 Socket</strong> <strong>基础</strong></h2><p>socket是网络编程的一种接口，它是一种特殊的I/O，用socket函数建立一个Socket连接，此函数返回一个整型的socket描述符，随后进行数据传输。</p>
<p>一个IP地址，一个通讯端口，就能确定一个通讯程序的位置。为此开发人员专门设计了一个套接结构，就是把网络程序中所用到的网络地址和端口信息放在一个结构体中。</p>
<p>一般套接口地址结构都以“sockaddr”开头。socket根据所使用的协议的不同可以分TCP套接口和UDP套接口，又称为流式套接口和数据套接口。</p>
<p>UDP是一个无连接协议，TCP是个可靠的端对端协议。传输UDP数据包时，LINUX不知道也不关心它们是否已经安全到达目的地，而传输TCP数据包时，则应先建立连接以保证传输的数据被正确接收。</p>
<p><strong>三种类型套接字</strong></p>
<p>流套接字(SOCK_STREAM)</p>
<p>​    可靠的、面向连接的通信。</p>
<p>​    使用TCP协议</p>
<p>数据报套接字(SOCK_DGRAM)</p>
<p>​    无连接服务</p>
<p>​    使用UDP协议</p>
<p>原始套接字(SOCK_RAW)</p>
<p>​    允许对底层协议如IP、ICMP直接访问</p>
<h3 id="1-socket套接字的数据结构"><a href="#1-socket套接字的数据结构" class="headerlink" title="1. socket套接字的数据结构"></a><strong>1. socket</strong>套接字的数据结构</h3><p>两个重要的数据类型：sockaddr和sockaddr_in，这两个结构类型都是用来保存socket信息的，如IP地址、通信端口等。</p>
<p>sockaddr——虚拟定义的地址（取决于协议）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;</span><br><span class="line">      <span class="comment">/*可以为AF_INET，代表TCP/IP地址族*/</span></span><br><span class="line">   <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">      <span class="comment">/*14个字节，包含IP地址和端口号*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sockaddr_in（AF_INET中使用的地址定义）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class"> &#123;</span>   <span class="keyword">short</span> sin_family;         <span class="comment">/*AF_INET（地址族）*/</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;</span><br><span class="line">        <span class="comment">/*端口号(必须要采用网络数据格式)*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">          <span class="comment">/*网络字节序的IP地址*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">         <span class="comment">/*与SOCKADDR结构保持同样大小*/</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-基于连接的服务"><a href="#2-基于连接的服务" class="headerlink" title="2. 基于连接的服务"></a><strong>2.</strong> <strong>基于连接的服务</strong></h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619170114870.png" alt="image-20210619170114870"></p>
<h4 id="Server程序的作用"><a href="#Server程序的作用" class="headerlink" title="Server程序的作用"></a><strong>Server程序</strong>的作用</h4><p>程序初始化</p>
<p>持续监听一个固定的端口</p>
<p>收到Client的连接后建立一个socket连接</p>
<p>与Client进行通信和信息处理</p>
<p>​    接收Client通过socket连接发送来的数据，进行相应处理并返回处理结果</p>
<p>​    通过socket连接向Client发送信息</p>
<p>通信结束后中断与Client的连接</p>
<h4 id="Client程序的作用"><a href="#Client程序的作用" class="headerlink" title="Client程序的作用"></a><strong>Client程序</strong>的作用</h4><p>程序初始化</p>
<p>连接到某个Server上，建立socket连接</p>
<p>与Server进行通信和信息处理</p>
<p>​    接收Server通过socket连接发送来的数据，进行相应处理</p>
<p>​    通过socket连接向Server发送请求信息</p>
<p>通信结束后中断与Server的连接</p>
<h3 id="3-无连接的服务"><a href="#3-无连接的服务" class="headerlink" title="3. 无连接的服务"></a>3. 无连接的服务</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619170325054.png" alt="image-20210619170325054"></p>
<h4 id="UDP编程的适用范围"><a href="#UDP编程的适用范围" class="headerlink" title="UDP编程的适用范围"></a>UDP编程的适用范围</h4><p>部分满足以下几点要求时，应该用UDP</p>
<p>​    面向数据报</p>
<p>​    网络数据大多为短消息</p>
<p>​    拥有大量Client</p>
<p>​    对数据安全性无特殊要求</p>
<p>​    网络负担非常重，但对响应速度要求高</p>
<p>例子：ICQ、视频点播</p>
<h4 id="具体编程时的区别"><a href="#具体编程时的区别" class="headerlink" title="具体编程时的区别"></a><strong>具体编程时的区别</strong></h4><p>socket()的参数不同</p>
<p>UDP Server不需要调用listen和accept</p>
<p>UDP收发数据用sendto/recvfrom函数</p>
<p>TCP：地址信息在connect/accept时确定</p>
<p>UDP：在sendto/recvfrom函数中每次均需指定地址信息</p>
<p>UDP：shutdown函数无效</p>
<h2 id="2-TCP编程"><a href="#2-TCP编程" class="headerlink" title="2 TCP编程"></a>2 TCP编程</h2><p>基于TCP协议的编程，其最主要的特点是建立完连接后，才进行通信。</p>
<p>常用的基于TCP网络编程函数及功能 </p>
<p>头文件</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619170614129.png" alt="image-20210619170614129"></p>
<h3 id="1-基于TCP网络编程函数"><a href="#1-基于TCP网络编程函数" class="headerlink" title="1.基于TCP网络编程函数"></a>1.基于TCP网络编程函数</h3><p>socket: 创建用于通信的端点并返回描述符.</p>
<p>​    int socket(int domain, int type, int protocol);</p>
<p>“domain” parameter</p>
<p>​    指定通信域，即选择协议族，如 AF_INET,AF_INET6 …</p>
<p>“type” parameter</p>
<p>​    指定通信语义。 三种主要类型: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW</p>
<p>“protocol” parameter</p>
<p>​    usually 0 (default). </p>
<p>bind: binds a name to a socket</p>
<p>int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen);</p>
<p>struct sockaddr {</p>
<p>  sa_family_t sa_family;</p>
<p>  char sa_data[14];</p>
<p>}</p>
<h3 id="inet-aton-amp-inet-ntoa"><a href="#inet-aton-amp-inet-ntoa" class="headerlink" title="inet_aton &amp; inet_ntoa"></a><strong>inet_aton</strong> <strong>&amp;</strong> <strong>inet_ntoa</strong></h3><p>互联网地址操作例程</p>
<p>​    int inet_aton(const char *cp, struct in_addr *inp);</p>
<p>​    char* inet_ntoa (struct in_addr in);</p>
<p>inet_ntoa将一个32位数字表示的IP地址转换成点分十进制IP地址字符串</p>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a><strong>listen</strong></h3><p>listen: listen for connections on a socket</p>
<p>int listen(int s, int backlog);</p>
<p>参数说明：</p>
<p> s：socket()返回的套接口文件描述符。</p>
<p> backlog：进入队列中允许的连接的个数。进入的连接请求在使用系统调用accept()应答之前要在进入队列中等待。这个值是队列中最多可以拥有的请求的个数。大多数系统的缺省设置为20。</p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a><strong>accept</strong></h3><p>accept()函数将响应连接请求，建立连接</p>
<p>int accept(int sockfd,struct sockaddr *addr,int *addrlen);</p>
<p>accept缺省是阻塞函数，阻塞直到有连接请求</p>
<p>sockfd: 被动(倾听)的socket描述符</p>
<p>如果成功，返回一个新的socket描述符(connected socket descriptor)来描述该连接。这个连接用来与特定的Client交换信息</p>
<p>addr将在函数调用后被填入连接对方的地址信息，如对方的IP、端口等。</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a><strong>connect</strong></h3><p>connect: initiate a connection on a socket (connect to a server).</p>
<p>int connect(int sockfd, struct sockaddr *servaddr, int addrlen);</p>
<p>主动的socket</p>
<p>servaddr是事先填写好的结构，Server的IP和端口都在该数据结构中指定。</p>
<h3 id="send-recv"><a href="#send-recv" class="headerlink" title="**send/**recv"></a>**send/**recv</h3><p> send/recv: 面向连接</p>
<p>int send(int s, const void *msg, size_t len, int flag);</p>
<p>s：发送数据的套接口文件描述符。 </p>
<p>msg：发送的数据的指针 </p>
<p>len：数据的字节长度 </p>
<p>flag：标志设置为0。 </p>
<p>int recv(int s, void *buf, size_t len, int flag);</p>
<p>s：读取的套接口文件描述符。 </p>
<p>buf：保存读入信息的地址。</p>
<p>len：缓冲区的最大长度。 </p>
<p>flag：设置为0。 </p>
<h3 id="sendto-recvfrom"><a href="#sendto-recvfrom" class="headerlink" title="sendto/recvfrom"></a>sendto/recvfrom</h3><p>int sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socketlen_t tolen);</p>
<p>int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</p>
<h3 id="close-amp-shutdown"><a href="#close-amp-shutdown" class="headerlink" title="close &amp; shutdown"></a><strong>close &amp; shutdown</strong></h3><p>close</p>
<p>​    int close(int sockfd);</p>
<p>shutdown</p>
<p>​    int shutdown(int sockfd, int how);</p>
<p>​    how: SHUT_RD, SHUT_WR, SHUT_RDWR</p>
<p>shutdown直接对TCP连接进行操作，close只是对套接字描述符操作。</p>
<h4 id="例4-1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。"><a href="#例4-1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。" class="headerlink" title="例4.1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。"></a>例4.1：服务器通过socket连接后，向客户端发送字符串“连接上了”。在服务器上显示客户端的IP地址或域名。</h4><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619171521320.png" alt="image-20210619171521320"></p>
<p>主要语句说明：<br>服务端<br>建立socket：socket(AF_INET, SOCK_STREAM, 0);<br>绑定bind：bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(struct sockaddr);<br>建立监听listen：listen(sockfd, BACKLOG);<br>响应客户请求：accept(sockfd,(struct sockaddr *)&amp;remote_addr, &amp;sin_size);<br>发送数据send：send(client_fd, “连接上了 \n”, 26, 0);<br>关闭close：close(client_fd);</p>
<p>客户端：<br>建立socket：socket(AF_INET, SOCK_STREAM, 0);<br>请求连接connect：connect(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(struct sockaddr))；<br>接收数据recv：recv(sockfd, buf, MAXDATASIZE, 0)；<br>关闭close：close(sockfd);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端源程序代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVPORT 3333 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> sockfd,client_fd;     <span class="keyword">int</span> sin_size;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span>     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span> </span><br><span class="line">     sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>) ;</span><br><span class="line">	my_addr.sin_family=AF_INET;</span><br><span class="line">	my_addr.sin_port=htons(SERVPORT);</span><br><span class="line">	my_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	bzero(&amp;(my_addr.sin_zero),<span class="number">8</span>); </span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;my_addr, <span class="keyword">sizeof</span>(my_addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;		perror(<span class="string">&quot;bind 出错！&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">if</span> (listen(sockfd, BACKLOG) == <span class="number">-1</span>) </span><br><span class="line">       &#123;	perror(<span class="string">&quot;listen 出错！&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);     &#125;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	sin_size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="keyword">if</span> ((client_fd = accept(sockfd, (struct sockaddr *)&amp;remote_addr, &amp;sin_size)) == <span class="number">-1</span>) </span><br><span class="line">       &#123;	perror(<span class="string">&quot;accept error&quot;</span>);		<span class="keyword">continue</span>;		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;收到一个连接来自： %s\n&quot;</span>, inet_ntoa(remote_addr.sin_addr));</span><br><span class="line">	<span class="keyword">if</span> (!fork()) </span><br><span class="line">        &#123; </span><br><span class="line">		<span class="keyword">if</span> (send(client_fd, <span class="string">&quot;连接上了 \n&quot;</span>, <span class="number">26</span>, <span class="number">0</span>) == <span class="number">-1</span>)			error(<span class="string">&quot;send 出错！&quot;</span>);	close(client_fd);	<span class="built_in">exit</span>(<span class="number">0</span>);		</span><br><span class="line">        &#125;</span><br><span class="line">	close(client_fd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端源程序代码 ：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> #<span class="meta-keyword">define</span> SERVPORT 3333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXDATASIZE 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd, recvbytes;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXDATASIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Please enter the server&#x27;s hostname!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">if</span>((host=gethostbyname(argv[<span class="number">1</span>]))==<span class="literal">NULL</span>)</span><br><span class="line">           &#123;	herror(<span class="string">&quot;gethostbyname error！&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">           &#123;  perror(<span class="string">&quot;socket create error！&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	serv_addr.sin_family=AF_INET;</span><br><span class="line">	serv_addr.sin_port=htons(SERVPORT);</span><br><span class="line">	serv_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr);</span><br><span class="line">	bzero(&amp;(serv_addr.sin_zero),<span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;connect error！&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">if</span> ((recvbytes=recv(sockfd, buf, MAXDATASIZE, <span class="number">0</span>)) ==<span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;connect 出错！&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	buf[recvbytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;收到: %s&quot;</span>,buf);</span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="3-UDP编程"><a href="#3-UDP编程" class="headerlink" title="3 UDP编程"></a>3 UDP编程</h2><p>基于UDP协议的编程，其最主要的特点是不需要用函数bind把本地IP地址与端口号进行绑定，也能进行通信。</p>
<p>常用的基UDP网络编程函数及功能：</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619171733752.png" alt="image-20210619171733752"></p>
<h3 id="例4-2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。"><a href="#例4-2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。" class="headerlink" title="例4.2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。"></a>例4.2：服务器端接受客户端发送的字符串。客户端将打开liu文件，读取文件中的３个字符串，传送给服务器端，当传送给服务端的字符串为”stop”时，终止数据传送并断开连接。</h3><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619171749586.png" alt="image-20210619171749586"></p>
<p>主要语句说明：<br>服务端：<br>建立socket：socket(AF_INET,SOCK_DGRAM,0)<br>绑定bind：bind(sockfd,(struct sockaddr *)&amp;adr_inet,sizeof(adr_inet));<br>接收数据recvfrom：recvfrom(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;adr_clnt,&amp;len);<br>关闭close：close(sockfd);</p>
<p>客户端：<br>建立socket：socket(AF_INET, SOCK_STREAM, 0);<br>读取liu文件：fopen(“liu”,”r”);<br>发送数据sendto：sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;adr_srvr,sizeof(adr_srvr));<br>关闭close：close(sockfd);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端源程序代码：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> port=<span class="number">8888</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">int</span> sockfd;	<span class="keyword">int</span> len;	<span class="keyword">int</span> z;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_inet</span>;</span>	</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_clnt</span>;</span> <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;等待客户端....\n&quot;</span>);</span><br><span class="line">	adr_inet.sin_family=AF_INET;</span><br><span class="line">	adr_inet.sin_port=htons(port);</span><br><span class="line">	adr_inet.sin_addr.s_addr =htonl(INADDR_ANY);</span><br><span class="line">	bzero(&amp;(adr_inet.sin_zero),<span class="number">8</span>);</span><br><span class="line">	len=<span class="keyword">sizeof</span>(adr_clnt);</span><br><span class="line">	sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;socket 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	   z=bind(sockfd,(struct sockaddr *)&amp;adr_inet,<span class="keyword">sizeof</span>(adr_inet));</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;bind 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	   z=recvfrom(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;adr_clnt,&amp;len);</span><br><span class="line">	  <span class="keyword">if</span>(z&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;	perror(<span class="string">&quot;recvfrom 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);		&#125;</span><br><span class="line">	  buf[z]=<span class="number">0</span>;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">&quot;接收:%s&quot;</span>,buf);</span><br><span class="line">	  <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">&quot;stop&quot;</span>,<span class="number">4</span>)==<span class="number">0</span>)</span><br><span class="line">		&#123;	<span class="built_in">printf</span>(<span class="string">&quot;结束....\n&quot;</span>);	<span class="keyword">break</span>;	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端源程序代码 ：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> port=<span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;	<span class="keyword">int</span> i=<span class="number">0</span>;	<span class="keyword">int</span> z;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">80</span>],str1[<span class="number">80</span>];	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_srvr</span>;</span></span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开文件......\n&quot;</span>);</span><br><span class="line">	fp=fopen(<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;打开文件失败&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;连接服务端...\n&quot;</span>);</span><br><span class="line">	adr_srvr.sin_family=AF_INET;</span><br><span class="line">	adr_srvr.sin_port=htons(port);</span><br><span class="line">	adr_srvr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	bzero(&amp;(adr_srvr.sin_zero),<span class="number">8</span>);</span><br><span class="line">	sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd==<span class="number">-1</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;socket 出错&quot;</span>);	<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;发送文件 ....\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;	fgets(str1,<span class="number">80</span>,fp);		<span class="built_in">printf</span>(<span class="string">&quot;%d:%s&quot;</span>,i,str1);</span><br><span class="line">		<span class="built_in">sprintf</span>(buf,<span class="string">&quot;%d:%s&quot;</span>,i,str1);</span><br><span class="line">		z=sendto(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;adr_srvr,	<span class="keyword">sizeof</span>(adr_srvr));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;发送.....\n&quot;</span>);	<span class="built_in">sprintf</span>(buf,<span class="string">&quot;stop\n&quot;</span>);</span><br><span class="line">	z=sendto(sockfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;adr_srvr,</span><br><span class="line">	<span class="keyword">sizeof</span>(adr_srvr));</span><br><span class="line">	<span class="keyword">if</span>(z&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;	perror(<span class="string">&quot;sendto 出错&quot;</span>);		<span class="built_in">exit</span>(<span class="number">1</span>);	&#125;</span><br><span class="line">	fclose(fp);	close(sockfd);	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-网络高级编程"><a href="#4-网络高级编程" class="headerlink" title="4 网络高级编程"></a>4 网络高级编程</h2><p>I/O Models<br>Block mode 阻塞模式<br>Non-block mode 非阻塞模式<br>I/O multiplexing  I/O多路复用<br>多进程并发<br>多线程并发</p>
<h3 id="阻塞方式"><a href="#阻塞方式" class="headerlink" title="阻塞方式"></a><strong>阻塞方式</strong></h3><p>阻塞方式:在数据通信中，当服务器运行函数accept() 时，假设没有客户机连接请求到来，那么服务器就一直会停止在accept（）语句上，等待客户机连接请求到来，出现这样的情况就称为阻塞。</p>
<h3 id="非阻塞方式"><a href="#非阻塞方式" class="headerlink" title="非阻塞方式"></a><strong>非阻塞方式</strong></h3><p>阻塞与非阻塞方式的比较<br>errno - EWOULDBLOCK<br>非阻塞的实现<br>int flags;<br>if ( (flags=fcntl(sock_fd, F_GETFL, 0)) &lt; 0)<br>    err_sys();<br>flags |= O_NONBLOCK;<br>if ( fcntl(sock_fd, F_SETFL, flags) &lt; 0)<br>    err_sys();</p>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a><strong>I/O</strong> <strong>多路复用</strong></h3><p>基本思想：</p>
<p>先构造一张有关描述符的表，然后调用一个函数(如select)，该函数到这些描述符中的一个已准备好进行I/O时才返回，返回时告诉进程哪个描述符已准备好进行I/O.</p>
<h3 id="“select”"><a href="#“select”" class="headerlink" title="“select”"></a><strong>“select”</strong></h3><p>select: synchronous I/O multiplexing.</p>
<p>#include &lt;sys/select.h&gt;</p>
<p>int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>
<p>FD_ZERO(fd_set *set);</p>
<p>FD_SET(int fd, fd_set *set);</p>
<p>FD_CLR(int fd, fd_set *set);</p>
<p>FD_ISSET(int fd, fd_set *set);</p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210619172130327.png" alt="image-20210619172130327"></p>
<h3 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a><strong>多进程并发</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listenfd = socket(...);</span><br><span class="line">bind(...);</span><br><span class="line">listen(...);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       connectfd = accpet(...);</span><br><span class="line">       <span class="keyword">if</span>(fork() == <span class="number">0</span>)   &#123;  close(listenfd);</span><br><span class="line">           process(...);</span><br><span class="line">           close(...);</span><br><span class="line">           <span class="built_in">exit</span>();   &#125;</span><br><span class="line">         <span class="keyword">else</span>    &#123;   close(connectfd);    ...  <span class="keyword">continue</span>;&#125;   close(...);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="雨课堂题目整理-3"><a href="#雨课堂题目整理-3" class="headerlink" title="雨课堂题目整理"></a>雨课堂题目整理</h2><p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101124982.png" alt="image-20210611101124982"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101135283.png" alt="image-20210611101135283"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101144547.png" alt="image-20210611101144547"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101151866.png" alt="image-20210611101151866"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101159284.png" alt="image-20210611101159284"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101205637.png" alt="image-20210611101205637"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101212054-1623377532896.png" alt="image-20210611101212054"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101220777.png" alt="image-20210611101220777"></p>
<p><img src="D:\SyncDisk\笔记整理\Linux\image-20210611101228856.png" alt="image-20210611101228856"></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://example.com/2021/11/18/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" data-id="ckw52exsu0003xcvc498n1kbe" class="article-share-link">分享到</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/11/18/SpringBoot%E5%AD%A6%E4%B9%A0%E8%B7%AF%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/11/18/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%B4%E6%AD%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 ZYZ<br>
      Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>