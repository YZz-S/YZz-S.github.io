<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>Unix程序设计头歌知识点整理 | YZz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
      <meta name="google-site-verification" content="XXX" />
    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1637200696663.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1637200696663.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/logo.png" alt="ZYZ">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>YZz</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-ckw5qsfjj000fa0vc2zec7rwz" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      Unix程序设计头歌知识点整理
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-11-19T01:23:18.000Z" itemprop="datePublished">2021-11-19</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unix/" rel="tag">Unix</a></li></ul>
            </div>
            

            
            <div class="article-busuanzi">
                有 <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h1 id="Linux编程基础"><a href="#Linux编程基础" class="headerlink" title="Linux编程基础"></a>Linux编程基础</h1><h2 id="vi-vim工作模式切换"><a href="#vi-vim工作模式切换" class="headerlink" title="vi/vim工作模式切换"></a>vi/vim工作模式切换</h2><p><code>vi/vim</code>编辑器有三种工作模式，每种工作模式都有不同的作用，以下是这三种工作模式的详细介绍:</p>
<ol>
<li>**命令模式: **查看当前文件内容，此时不能对文件内容进行写入操作，从该模式可以切换为插入模式和底线命令模式。</li>
<li>**插入模式: **可以对文件内容进行编辑操作，从该模式可以切换为命令模式。</li>
<li>**底线命令模式: **不可以对文件内容进行编辑，在此模式下可以执行一些<code>vi/vim</code>的命令，例如: 退出命令、保存内容命令等等。从该模式可以切换为命令模式。</li>
</ol>
<p><img src="https://data.educoder.net/api/attachments/188050" alt="img"></p>
<p><strong>注意: 启动<code>vi/vim</code>后，首先进入的是命令模式。</strong></p>
<h5 id="命令模式与插入模式相互切换"><a href="#命令模式与插入模式相互切换" class="headerlink" title="命令模式与插入模式相互切换"></a>命令模式与插入模式相互切换</h5><p>首先启动<code>vi/vim</code>编辑器后，首先进入的工作模式是命令模式，在当前模式下，我们只能查看文件内容，不能对文件内容进行写入操作。如果想对文件进行写入操作，那么我们只有进入插入模式下。</p>
<ol>
<li><strong>命令模式－&gt;插入模式方法</strong> 从命令模式到插入模式的切换方法有多种，我们介绍如下３中常用方法:</li>
</ol>
<table>
<thead>
<tr>
<th>输入命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i, I</td>
<td>i 为『从目前光标所在处输入』，I 为『在目前所在行的第一个非空格符处开始输入』。</td>
</tr>
<tr>
<td>a, A</td>
<td>a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。</td>
</tr>
<tr>
<td>o, O</td>
<td>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行。</td>
</tr>
</tbody></table>
<ol>
<li><strong>插入模式－&gt;命令模式方法</strong> 由插入模式切换到命令模式比较简单，我们只需要点击<code>ESC</code>键即可返回到命令模式。</li>
</ol>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>testFile</code>，并且将工作模式切换到插入模式，输入<code>Hello vi/vim</code>字符串，最后保存文件并退出，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi testFile` 或 `vim testFile</span><br></pre></td></tr></table></figure>

<p>打卡<code>testFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/186930" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/186931" alt="img"></p>
<p>按下字母<code>i</code>后进入插入模式； <img src="https://data.educoder.net/api/attachments/188053" alt="img"></p>
<p>输入<code>Hello vi/vim</code>字符后，按下<code>ESC</code>键后返回命令模式，最后输入<code>:wq</code>保存退出文件； <img src="https://data.educoder.net/api/attachments/188054" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="命令模式与底线命令模式相互切换"><a href="#命令模式与底线命令模式相互切换" class="headerlink" title="命令模式与底线命令模式相互切换"></a>命令模式与底线命令模式相互切换</h5><p><code>vi/vim</code>底线命令模式下如何执行写复杂的命令，例如我们常用的保存退出命令(<code>wq</code>)等。</p>
<ol>
<li><strong>命令模式－&gt;底线命令模式方法</strong> 从命令模式到底线命令模式的切换比较简单，我们只需要输入<code>:</code>字符即可，<strong>注意<code>:</code>是英文输入法下的冒号。</strong></li>
<li><strong>底线命令模式－&gt;命令模式方法</strong> 由底线命令模式切换到命令模式比较简单，我们只需要点击<code>ESC</code>键即可返回到命令模式。</li>
</ol>
<h2 id="vi-vim命令模式"><a href="#vi-vim命令模式" class="headerlink" title="vi/vim命令模式"></a>vi/vim命令模式</h2><p>在<code>vi/vim</code>命令模式下，我们可以对文件进行删除、复制和粘贴操作。</p>
<h5 id="命令模式移动光标操作"><a href="#命令模式移动光标操作" class="headerlink" title="命令模式移动光标操作"></a>命令模式移动光标操作</h5><p><code>vi/vim</code>编辑器与其它编辑器最大的不同之处是不能使用鼠标进行操作(可以在配置文件中设置鼠标属性，默认是禁止使用鼠标)，我们可以在命令模式下移动光标位置，常见移动命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td>j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td>k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td>l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td>[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键</td>
</tr>
<tr>
<td>[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键</td>
</tr>
<tr>
<td>[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td>[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，移动当前光标到第一行的第二字符处，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188089" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188090" alt="img"></p>
<p>移动光标到第一行的第５个字符处(按5次→)； <img src="https://data.educoder.net/api/attachments/188091" alt="img"></p>
<p>最后输入<code>:q</code>退出文件； <img src="https://data.educoder.net/api/attachments/188092" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="命令模式删除操作"><a href="#命令模式删除操作" class="headerlink" title="命令模式删除操作"></a>命令模式删除操作</h5><p>我们不光可以在插入模式下可以对文件内容进行删除操作，我们可以直接在命令模式下对文件进行删除操作，常见删除命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键)</td>
</tr>
<tr>
<td>nx</td>
<td>n 为数字，连续向后删除 n 个字符。例如，我要连续删除 5 个字符 ，则可以使用<code>5x</code></td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在的那一整行</td>
</tr>
<tr>
<td>ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如<code>10dd</code>则是删除 10 行</td>
</tr>
<tr>
<td>d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，删除当前文件的第二行所有内容，最后保存文件并退出，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188093" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188094" alt="img"></p>
<p>移动光标到文件第二行； <img src="https://data.educoder.net/api/attachments/188095" alt="img"></p>
<p>输入<code>dd</code>字符后删除当前行内容，最后输入<code>:wq</code>保存退出文件； <img src="https://data.educoder.net/api/attachments/188096" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="命令模式复制粘贴操作"><a href="#命令模式复制粘贴操作" class="headerlink" title="命令模式复制粘贴操作"></a>命令模式复制粘贴操作</h5><p>常见复制命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标所在的那一行</td>
</tr>
<tr>
<td>nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 <code>10yy</code> 则是复制 10 行</td>
</tr>
<tr>
<td>y1G</td>
<td>复制光标所在行到第一行的所有数据</td>
</tr>
<tr>
<td>yG</td>
<td>复制光标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td>y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td>y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
</tbody></table>
<p>常见粘贴命令为<code>p, P</code>，<code>p</code> 为将已复制的数据在光标下一行贴上，<code>P</code> 则为贴在游标上一行！</p>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，将第一行内容复制，然后粘贴到文件的末尾，最后保存文件并退出，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188093" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188097" alt="img"></p>
<p>复制第一行内容(<code>yy</code>)，移动光标到最后一行，粘贴(<code>p</code>)内容到当前行的下一行，最后输入<code>:wq</code>保存退出文件； <img src="https://data.educoder.net/api/attachments/188098" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h2 id="vi-vim底线命令模式"><a href="#vi-vim底线命令模式" class="headerlink" title="vi/vim底线命令模式"></a>vi/vim底线命令模式</h2><h5 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h5><p><code>vi/vim</code>编辑器在底线命令模式下可以对文件内容进行查找和替换操作，常见查找和替换命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可。</td>
</tr>
<tr>
<td>?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td>n</td>
<td>这个 n 是英文字母。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。</td>
</tr>
<tr>
<td>N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td>[:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 。</td>
</tr>
<tr>
<td>:1,$s/word1/word2/g</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2。</td>
</tr>
<tr>
<td>:1,$s/word1/word2/gc</td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代。</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，将所有<code>line</code>单词替换为<code>words</code>单词，并保存退出，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188089" alt="img"></p>
<p>首先进入的是命令模式； <img src="https://data.educoder.net/api/attachments/188090" alt="img"></p>
<p>首先输入<code>:</code>切换当前模式为底线命令模式，然后输入<code>1,$s/line/words/g</code>后回车； <img src="https://data.educoder.net/api/attachments/188108" alt="img"></p>
<p><img src="https://data.educoder.net/api/attachments/188109" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="底线命令模式下执行特殊命令"><a href="#底线命令模式下执行特殊命令" class="headerlink" title="底线命令模式下执行特殊命令"></a>底线命令模式下执行特殊命令</h5><p>常见在底线命令模式执行的命令如下所示:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>将编辑的数据写入硬盘档案中</td>
</tr>
<tr>
<td>:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td>:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td>:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td>:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td>:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<p>案例演示1: </p>
<p>使用<code>vi/vim</code>编辑器打开文件<code>oldFile</code>，显示当前文件行号，将当前文件的第1-3行内容另存为<code>oldFileCpy</code>文件，使用<code>cat</code>命令查看新生成文件内容，可以使用如下步骤：</p>
<p>打卡<code>oldFile</code>文件命令； <img src="https://data.educoder.net/api/attachments/188093" alt="img"></p>
<p>输入<code>:set nu</code>后回车，显示行号； <img src="https://data.educoder.net/api/attachments/188110" alt="img"></p>
<p><img src="https://data.educoder.net/api/attachments/188111" alt="img"></p>
<p>输入<code>:1,3 w oldFileCpy</code>后回车 <img src="https://data.educoder.net/api/attachments/188112" alt="img"></p>
<p>最后在<code>vi</code>中使用<code>cat</code>命令查看新生成的文件<code>oldFileCpy</code>内容； <img src="https://data.educoder.net/api/attachments/188113" alt="img"></p>
<p><img src="https://data.educoder.net/api/attachments/188114" alt="img"></p>
<p>按下回车键后返回当前<code>vi</code>编辑器，最后输入<code>q</code>退出文件； <img src="https://data.educoder.net/api/attachments/188115" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h2 id="Linux之静态库编写"><a href="#Linux之静态库编写" class="headerlink" title="Linux之静态库编写"></a>Linux之静态库编写</h2><p>在实际的软件开发时， 应该遵守一个基本原则：不要重复造轮子。如果某些代码经常要用到，不仅这个项目能使用，而且也能复用到其它项目上，那么就应该把这部分代码从项目中分离出来，将其编译为库文件，供需要的程序调用。</p>
<p>程序库分为两类，分别是<strong>静态库</strong>和<strong>动态库</strong>。本关将主要讲解如何生成<strong>静态库</strong>。</p>
<p><code>Windows</code>系统上的<strong>静态库</strong>是以<code>.lib</code>为后缀，而<code>Linux</code>系统上的<strong>静态库</strong>是以<code>.a</code>为后缀的特殊的存档。</p>
<p><code>Linux</code>系统的标准系统库可在目录<code>/usr/lib</code>与<code>/lib</code>中找到。比如，在类<code>Unix</code>系统中<code>C</code>语言的数序库一般存储为文件<code>/usr/lib/libm.a</code>。该库中函数的原型声明在头文件<code>/usr/include/math.h</code>中。</p>
<h5 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h5><p>在<code>Linux</code>下，我们可以使用<code>gcc</code>和<code>ar</code>工具制作和使用自己的静态库，具体过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将源码文件编译成.o目标文件；</span><br><span class="line">使用ar工具将多个目标文件打包成.a的静态库文件；</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><code>Linux</code>系统上默认的静态库名格式为：<code>libxxx.a</code>，其中<code>xxx</code>为生成库的名称。</p>
<p>案例演示1：</p>
<p>编写一个函数<code>printHello</code>，其功能为打印“Hello world”字符串，将其编译生成名为<code>Hello</code>的静态库，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim printHello.h</span><br><span class="line">vim printHello.c</span><br><span class="line">gcc -c printHello.c -o printHello.o</span><br><span class="line">ar rcs libHello.a printHello.o</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.h</code>(声明<code>printHello</code>函数，方便以后被其它程序调用)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __PRINTHELLO_H__</span><br><span class="line">#define __PRINTHELLO_H__</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void printHello();</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212803" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h5><p><strong>静态库</strong>的使用方法只需要在编译程序的时候指明要链接的库名称即可，<code>gcc</code>中有两个参数是关于链接库时所使用的，**分别是：<code>-L</code>和<code>-l</code>**。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-L：用于告诉gcc要链接的库所在目录；</span><br><span class="line">-l：用于指明链接的库名称(小写l)；</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>调用以上案例生成的<code>printHello</code>函数，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br><span class="line">gcc main.c -o exe -L ./ -lHello(可以换成Hello.o)</span><br><span class="line">./exe</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>main.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;printHello.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	printHello();    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212810" alt="img"> </p>
<p>[请在右侧“命令行”里直接体验]</p>
<h2 id="Linux之动态库编写"><a href="#Linux之动态库编写" class="headerlink" title="Linux之动态库编写"></a>Linux之动态库编写</h2><ul>
<li><strong>静态库</strong>与<strong>动态库</strong>的区别：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>静态库</th>
<th>动态库</th>
</tr>
</thead>
<tbody><tr>
<td>名称</td>
<td>命名方式是”libxxx.a”,库名前加”lib”，后缀用”.a”，”xxx”为静态库名</td>
<td>命名方式是”libxxx.so”, 库名前加”lib”，<strong>后缀用”.so”， “xxx”为动态库名</strong></td>
</tr>
<tr>
<td>链接时间</td>
<td>静态库的代码是在<strong>编译过程中被载入程序中</strong></td>
<td>动态库在编译的时候并没有被编译进目标代码，而是<strong>当你的程序执行到相关函数时才调用该函数库里的相应函数</strong></td>
</tr>
<tr>
<td>优点</td>
<td><strong>在编译后的执行程序不在需要外部的函数库支持</strong>，因为所使用的函数都已经被编进去了。</td>
<td><strong>动态库的改变</strong>并<strong>不影响你的程序</strong>，所以动态函数库升级比较方便</td>
</tr>
<tr>
<td>缺点</td>
<td>如果所使用的<strong>静态库发生更新改变，你的程序必须重新编译</strong></td>
<td>因为函数库并没有整合进程序，所以<strong>程序的运行环境必须提供相应的库</strong></td>
</tr>
</tbody></table>
<p><code>Windows</code>系统上的<strong>动态库</strong>是以<code>.dll</code>为后缀，而<code>Linux</code>系统上的<strong>动态库</strong>是以<code>.so</code>为后缀的特殊的存档。</p>
<h5 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h5><p>在<code>Linux</code>下，我们可以使用<code>gcc</code>制作和使用动态库，具体制作过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用gcc命令加-fPIC参数将源码文件编译成.o目标文件；使用gcc命令加-shared参数将多个目录文件生成一个动态库文件；</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><code>Linux</code>系统上默认的动态库名格式为：<code>libxxx.so</code>，其中<code>xxx</code>为生成库的名称。</p>
<p>案例演示1：</p>
<p>编写一个函数<code>printHello</code>，其功能为打印”Hello world”字符串，将其编译生成名为<code>Hello</code>的动态库，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim printHello.h</span><br><span class="line">vim printHello.c</span><br><span class="line">gcc -fPIC -c printHello.c -o printHello.o</span><br><span class="line">gcc -shared  printHello.o -o libHello.so</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.h</code>(申明<code>printHello</code>函数，方便以后被其它程序调用)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PRINTHELLO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PRINTHELLO_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>printHello.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212811" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h5><p><strong>动态库</strong>的使用方法与<strong>静态库</strong>使用方式略有不同，除了使用<code>gcc</code>中的<code>-L</code>和<code>-l</code>参数外，想要调用动态库还需要更新<code>Linux</code>系统中<code>/etc/ld.so.cache</code>或者修改<code>LD_LIBRARY_PATH</code>环境变量，否则在运行程序的时候会报<strong>”No such file or directory”</strong>错误。</p>
<p>案例演示1：</p>
<p>调用以上案例生成的<code>printHello</code>函数，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br><span class="line">gcc main.c -o exe -L ./ -lHello</span><br><span class="line">./exe</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212806" alt="img"> [使用<code>vim</code>编写程序]</p>
<p><img src="https://data.educoder.net/api/attachments/212812" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>此时编译正常，当运行的时候会报<strong>”No such file or directory”</strong>错误。</p>
<h5 id="更新-etc-ld-so-cache来运行动态库"><a href="#更新-etc-ld-so-cache来运行动态库" class="headerlink" title="更新/etc/ld.so.cache来运行动态库"></a>更新/etc/ld.so.cache来运行动态库</h5><ul>
<li>编辑<code>/etc/ld.so.conf</code>配置文件，然后加入需要加载的动态库目录。</li>
<li>运行<code>ldconfig</code>更新<code>/etc/ld.so.cache</code></li>
</ul>
<p>案例演示1：</p>
<p>更新<code>/etc/ld.so.cache</code>，然后运行上一个案例生成的<code>exe</code>，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line">sudo ldconfig</span><br><span class="line">./exe</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212813" alt="img"> [使用<code>vim</code>向<code>/etc/ld.so.conf</code>文件添加<code>/home/fzm</code>路径]</p>
<p><img src="https://data.educoder.net/api/attachments/212814" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h5 id="修改LD-LIBRARY-PATH环境变量"><a href="#修改LD-LIBRARY-PATH环境变量" class="headerlink" title="修改LD_LIBRARY_PATH环境变量"></a>修改<code>LD_LIBRARY_PATH</code>环境变量</h5><p>在运行可执行文件前修改<code>LD_LIBRARY_PATH</code>变量为可执行程序指定需要加载的动态库路径。</p>
<p>案例演示1：</p>
<p>修改<code>LD_LIBRARY_PATH</code>，然后运行上一个案例生成的<code>exe</code>，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=.  ./exe</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212815" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p><strong>注意</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH告诉了exe程序现在当前目录下寻找链接的动态库；</span><br><span class="line">当运行环境中同时存在同名的静态库和动态库时，默认优先链接动态库；</span><br></pre></td></tr></table></figure>

<h2 id="Makefile初体验"><a href="#Makefile初体验" class="headerlink" title="Makefile初体验"></a>Makefile初体验</h2><p>什么是<code>makefile</code>？或许很多<code>Winodws</code>的程序员都不知道这个东西，因为那些<code>Windows</code>的<code>IDE</code>都为你做了这个工作，但是要作一个专业的程序员，<code>makefile</code>还是要懂的。<code>makefile</code>其实就是描述了整个工程中所有文件的<strong>编译顺序，编译规则</strong>，并且由<code>make</code>命令来读取<code>makefile</code>文件，然后根据<code>makefile</code>文件中定义的规则对其进行解析，完成对整个项目的编译操作。</p>
<p><code>makefile</code>在<code>linux</code>操作系统中是比较常见的，例如，我们在使用源码安装一个软件的时候，通常只需执行<code>make</code>命令即可完成对软件的编译，正是因为软件开发者已经编写了<code>makefile</code>文件，所以只需执行<code>make</code>命令就会完成对整个工程的自动编译。</p>
<p>本关将介绍<code>makefile</code>的语法，使用<code>makefile</code>来完成对软件的编译。</p>
<h5 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h5><p><code>makefile</code>文件中包含了一组用来编译应用程序的规则，一项规则可分成三个部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作目标(target)</span><br><span class="line">依赖条件(prerequisite)</span><br><span class="line">所要执行的命令(command)</span><br></pre></td></tr></table></figure>

<p>格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target : prereq1 prereq2</span><br><span class="line">	commands</span><br></pre></td></tr></table></figure>

<p>以上格式就是一个文件的依赖关系，也就是说，<code>target</code>这个目标文件依赖于多个<code>prerequisites</code>文件，其生成规则定义在<code>commands</code>中。说白一点就是说，<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>commands</code>所定义的命令就会被执行。这就是<code>Makefile</code>的规则。也就是<code>Makefile</code>中最核心的内容。</p>
<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands前面使用的是TAB键，而不是空格，使用空格会出现错误；</span><br><span class="line">commands可以是任意的shell命令；</span><br><span class="line">在执行make命令时，make会解析第一项规则；</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>存在一个源码文件<code>main.c</code>文件，编译一个<code>makefile</code>规则来编译该文件，并生成一个名为<code>HelloWorld</code>的可执行文件，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写如下代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>vim</code>编写<code>makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld : main.c    </span><br><span class="line">	gcc -o HelloWorld main.c</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212979" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>通过以上案例可以看到，编写好<code>makefile</code>后，只需要输入<code>make</code>命令即自动只需定义好的规则。</p>
<p><strong>注意：</strong><code>gcc -o HelloWorld main.c</code>命令前是<code>TAB</code>键而不是空格。</p>
<p>案例演示2：</p>
<p>假设一个项目中包含<code>5</code>个源码文件，分别是<code>Add.c</code>、<code>Sub.c</code>、<code>Mul.c</code>、<code>Div.c</code>和<code>main.c</code>和一个头文件<code>def.h</code>，编译一个<code>makefile</code>规则来编译该项目，并生成一个名为<code>exe</code>的可执行文件，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Add.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Sub.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Mul.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim Div.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> a /  b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim main.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;def.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> add = Add(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">int</span> sub = Sub(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">int</span> mul = Mul(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">int</span> div = Div(<span class="number">10</span>, <span class="number">5</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 + 5 = %d\n&quot;</span>, add);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 - 5 = %d\n&quot;</span>, sub);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 * 5 = %d\n&quot;</span>, mul);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10 / 5 = %d\n&quot;</span>, div);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim def.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DEF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DEF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exe : main.o Add.o Sub.o Mul.o Div.o    </span><br><span class="line">	gcc -o exe main.o Add.o Sub.o Mul.o Div.o (若要重命名生成的文件，两个exe都要改名)</span><br><span class="line">main.o : main.c def.h    </span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line">Add.o : Add.c    </span><br><span class="line">	gcc -c Add.c -o Add.o</span><br><span class="line">Sub.o : Sub.c    </span><br><span class="line">	gcc -c Sub.c -o Sub.o</span><br><span class="line">Mul.o : Mul.c    </span><br><span class="line">	gcc -c Mul.c -o Mul.o</span><br><span class="line">Div.o : Div.c    </span><br><span class="line">	gcc -c Div.c -o Div.o</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/212996" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>以上案例，当只需<code>make</code>命令时，首先解析目标为<code>exe</code>的规则，然后发现<code>exe</code>依赖于<code>main.o、Add.o和Sub.o</code>，然后分别对<code>main.o、Add.o和Sub.o</code>规则进行解析，即分别执行目标为<code>main.o、Add.o和Sub.o</code>的命令。当<code>main.o、Add.o和Sub.o</code>生成后，最后执行<code>exe</code>对应的命令。</p>
<h2 id="Makefile之变量使用"><a href="#Makefile之变量使用" class="headerlink" title="Makefile之变量使用"></a>Makefile之变量使用</h2><p><code>makefile</code> 变量的命令可以包含字符、数字、下划线（可以是数字开头），并且大小写敏感。</p>
<p><code>makefile</code>变量在声明时需要对其进行赋值，而在使用该变量时需要在变量名前加上**<code>$</code><strong>符号 例如<code>$(VARNAME)</code>，如果用户需要在<code>makefile</code>文件中使用真实的</strong><code>$</code><strong>字符，则使用</strong><code>$$</code>**表示。</p>
<p><code>makefile</code>中对变量的赋值方式有三种，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归赋值(=)：递归赋值，即赋值后并不马上生效，等到使用时才真正的赋值，此时通递归找出当前的值；直接赋值(:=)：是将&quot;:=&quot;右边中包含的变量直接展开给左边的变量赋值；条件赋值(?=)：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值，所有一般用在第一次赋值；</span><br></pre></td></tr></table></figure>

<p><code>makefile</code>除了可以自定义变量外，还存在一些系统默认的特殊变量，这些特殊变量可以方便帮助我们快速的编写<code>makefile</code>文件，例如：<code>$@、$&lt;和$^</code>等等。</p>
<p>本关将介绍<code>makefile</code>的变量的定义和使用方法，以及使用特殊变量来编写<code>makefile</code>文件。</p>
<h5 id="Makefile-自定义变量"><a href="#Makefile-自定义变量" class="headerlink" title="Makefile 自定义变量"></a>Makefile 自定义变量</h5><p>自定义变量格式：</p>
<ul>
<li>递归赋值 <code>变量名 = 变量内容</code></li>
<li>直接赋值 <code>变量名 := 变量内容</code></li>
<li>条件赋值 <code>变量名 ?= 变量内容</code></li>
</ul>
<p>变量的使用格式为： <code>$变量名</code>或者<code>$&#123;变量名&#125;</code>或者<code>$(变量名)</code></p>
<p>案例演示1：</p>
<p>在上一关中案例<code>2</code>中的项包含了<code>5</code>个源码文件和一个头文件，如果使用变量来编写<code>makefile</code>则会显示出比较简洁的格式，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim makefilemake</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o exe <span class="variable">$(object)</span></span><br><span class="line"></span><br><span class="line">main.o : main.c def.h    </span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line">	</span><br><span class="line">Add.o : Add.c    </span><br><span class="line">	gcc -c Add.c -o Add.o</span><br><span class="line">	</span><br><span class="line">Sub.o : Sub.c    </span><br><span class="line">	gcc -c Sub.c -o Sub.o</span><br><span class="line">	</span><br><span class="line">Mul.o : Mul.c    </span><br><span class="line">	gcc -c Mul.c -o Mul.o</span><br><span class="line">	</span><br><span class="line">Div.o : Div.c    </span><br><span class="line">	gcc -c Div.c -o Div.o</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213114" alt="img"> [<code>makefile</code>内容]</p>
<p><img src="https://data.educoder.net/api/attachments/213116" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>可以看到，我们使用<code>object</code>来表示<code>main.o Add.o Sub.o Mul.o Div.o</code>，这样我们就可以使用<code>$(object)</code>来表示以上目标文件，而不是每次输入这<code>5</code>个目标文件。</p>
<h5 id="Makefile-特殊变量"><a href="#Makefile-特殊变量" class="headerlink" title="Makefile 特殊变量"></a>Makefile 特殊变量</h5><p> <code>makefile</code>常用的特殊变量有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$@：表示所有目标；</span><br><span class="line">$^：表示所有依赖目标的集合，以空格分隔；</span><br><span class="line">$&lt;：表示依赖目标中第一个目标的名子；</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>接着上一个案例中的项目，如果使用特殊变量来编写<code>makefile</code>则会显示出更加简洁的格式，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span>main.o : </span><br><span class="line"></span><br><span class="line">main.c def.h    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">Add.o : Add.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">Sub.o : Sub.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">Mul.o : Mul.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line">Div.o : Div.c    </span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213121" alt="img"> [请在右侧“命令行”里直接体验]</p>
<h2 id="Makefile自动推导"><a href="#Makefile自动推导" class="headerlink" title="Makefile自动推导"></a>Makefile自动推导</h2><p><code>make</code>很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个<code>.o</code>文件后都写上类似的命令。因为，我们的<code>make</code>会自动识别，并自己推导命令。</p>
<p>只要<code>make</code>看到一个<code>.o</code>文件，它就会自动的把<code>.c</code>文件加在依赖关系中，如果<code>make</code>找到一个<code>main.o</code>，那么<code>main.c</code>就会是<code>main.o</code>的依赖文件。并且 <code>gcc -c main.c</code> 也会被推导出来，于是，我们的<code>makefile</code>再也不用写得这么复杂。</p>
<p>本关将介绍<code>makefile</code>的自动推导功能。</p>
<h5 id="Makefile-自动推导"><a href="#Makefile-自动推导" class="headerlink" title="Makefile 自动推导"></a>Makefile 自动推导</h5><p>自动推导格式： <code>目标 : 其它依赖</code></p>
<p>案例演示1：</p>
<p>如果使用自动推导模式来编写上一关卡案例中的<code>makefile</code>，则会有更简洁的格式，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span></span><br><span class="line"></span><br><span class="line">main.o : def.h</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213116" alt="img"> </p>
<p>[请在右侧“命令行”里直接体验]</p>
<p>可以看到，我们只需要为<code>main.o</code>创建一个编译规则，其<code>4</code>个目标文件则不需要为其创建编译规则，因为<code>make</code>会自动的为其构造出编译规则。</p>
<h2 id="Makefile伪目标"><a href="#Makefile伪目标" class="headerlink" title="Makefile伪目标"></a>Makefile伪目标</h2><p>每个<code>Makefile</code>中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。</p>
<p>通常，我们在使用源码安装软件的时候，都会在编译完软件后，执行<code>make install</code>这个命令来安装软件，或者执行<code>make clean</code>这个命令清空临时生成的目标文件。以上操作就是利用了<code>makefile</code>的伪目标。</p>
<p>本关将介绍<code>makefile</code>的伪目标。</p>
<h5 id="Makefile-伪目标"><a href="#Makefile-伪目标" class="headerlink" title="Makefile 伪目标"></a>Makefile 伪目标</h5><p>makefile<code>使用</code>.PHONY`关键字来定义一个伪目标，具体格式为： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : 伪目标名称</span><br></pre></td></tr></table></figure>

<p>案例演示1：</p>
<p>为上一关卡案例中的<code>makefile</code>添加清空临时目标文件标签<code>clean</code>，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>  </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span></span><br><span class="line"></span><br><span class="line">main.o : def.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean :    </span><br><span class="line">	rm <span class="variable">$(object)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213181" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>可以看到，当我们执行完<code>make</code>命令后会生成多个临时文件，然后我们执行<code>make clean</code>命令后，则会将生成的临时文件删除掉，其实执行<code>make clean</code>命令就是在执行<code>rm main.o Add.o Sub.o Mul.o Div.o</code>。</p>
<p>案例演示2：</p>
<p>使用另一个格式来清除临时产生的目录文件和不显示删除命令，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim makefile</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>vim makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object=main.o Add.o Sub.o Mul.o Div.o</span><br><span class="line">exe : <span class="variable">$(object)</span>    </span><br><span class="line">	gcc -o <span class="variable">$@</span> <span class="variable">$(object)</span></span><br><span class="line">	</span><br><span class="line">main.o : def.h</span><br><span class="line"></span><br><span class="line">clean :    </span><br><span class="line">	@echo <span class="string">&quot;clean object files&quot;</span>    </span><br><span class="line">	@rm <span class="variable">$(object)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/213186" alt="img"> [请在右侧“命令行”里直接体验]</p>
<p>可以看到，当我们执行<code>make clean</code>命令后，将不会在终端中显示<code>rm main.o Add.o Sub.o Mul.o Div.o</code>命令。</p>
<p><strong>注意：</strong>在命令前加了**<code>@</code>**符号，则不会把命令原样输出在终端。</p>
<h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><h2 id="文件权限修改"><a href="#文件权限修改" class="headerlink" title="文件权限修改"></a>文件权限修改</h2><p>在当前目录中新建文件<code>test.txt</code></p>
<p>touch test.txt</p>
<p>增加拥有者<code>(u)</code>对该文件的执行权限。</p>
<p>chmod 777 test.txt</p>
<p>增加群组用户<code>(g)</code>对该文件的写权限。</p>
<p>chmod ug+w test.txt</p>
<p>取消其他用户<code>(o)</code>对该文件的读权限。</p>
<p>chmod o-r test.txt</p>
<h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><h3 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h3><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>文件的创建操作是 <code>I/O </code>操作的第一步。在Linux系统中<code>creat</code>系统调用可以实现对文件的创建。本关只介绍文件创建函数的使用方法。</p>
<p>在Linux系统中可以使用<code>man</code>命令来查询这些函数的使用方法。具体的查询命令为： <code>man 2 函数名</code> 其中，<code>2</code>表示查找系统调用函数，关于文件的创建、打开和关闭函数都是系统调用函数，因此使用<code>2</code>作为<code>man</code>命令的第一个参数。</p>
<p>案例演示1: 查询<code>creat</code>函数的使用方法可以使用以下命令： <code>man 2 creat</code></p>
<p><img src="https://data.educoder.net/api/attachments/279654" alt="img"> [查询结果]</p>
<p>通过<code>man</code>命令可以查询常用的系统调用函数的使用方法。</p>
<h5 id="文件的创建-1"><a href="#文件的创建-1" class="headerlink" title="文件的创建"></a>文件的创建</h5><p>创建文件的系统调用函数是<code>creat</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int creat (const char *pathname,mode_t mode);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要创建文件的绝对路径名或相对路径名；mode：用于指定所创建文件的权限；</span><br></pre></td></tr></table></figure>

<p>常见的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode</span><br></pre></td></tr></table></figure>

<p>取值及其含义见下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>mode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRUSR</td>
<td>文件所有者的读权限位</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>文件所有者的写权限位</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>文件所有者的执行权限位</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>所有者同组用户的读权限位</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>所有者同组用户的写权限位</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>所有者同组用户的执行权限位</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他用户的读权限位</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他用户的写权限位</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他用户的执行权限位</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功时，返回值为 文件的描述符(大于0的整数)；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>creat</code>函数创建一个名为<code>firstFile</code>的文件，并设置文件的权限为<code>644</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = creat(<span class="string">&quot;firstFile&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288183" alt="img"> 将以上代码保存为<code>main.c</code>文件中，编译执行。可以看到当前目录下存在<code>firstFile</code>文件，并且其权限为<code>644</code>。</p>
<h4 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在当前目录下创建一个名为<code>testFile</code>的文件，并设置其权限为<code>651</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> ret = creat(<span class="string">&quot;testFile&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IXGRP | S_IXOTH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件打开与关闭"><a href="#文件打开与关闭" class="headerlink" title="文件打开与关闭"></a>文件打开与关闭</h3><h4 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h4><p>文件的打开与关闭操作是 <code>I/O </code>操作的第二步。在Linux系统中提供了以下两个系统调用函数用于打开和关闭文件操作，分别是<code>open</code>和<code>close</code>。本关将介绍文件的打开和关闭函数的使用方法。</p>
<p>使用<code>man 2 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h5><p>打开文件的系统调用函数是<code>open</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(coust char *pathname, int flags);int open(const char *pathname, int flags, made_t mode);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要被打开或创建的文件绝对路径名或相对路径名；flags：用于描述文件的打开方式；mode：用于指定所创建文件的权限(与上一关中creat函数中mode取值一致)；</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第一个<code>open</code>函数用于打开已经存在的文件。而第二个<code>open</code>函数可以创建一个不存在的文件且打开，该函数将<code>flags</code>参数设置为<code>O_CREAT | O_WRONLY | O_TRUNC</code>时等同于上一关中的<code>creat</code>函数。</p>
<p>常见的<code>flags</code>取值及其含义见下表所示：</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY 以只读方式打开文件</td>
<td></td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写方式打开文件</td>
</tr>
<tr>
<td>O_RDWY</td>
<td>以只读写方式打开文件</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>若所打开文件不存在则创建此文件</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>若以只写或读写方式打开一个已存在文件时,将该文件截至 0</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>向文件添加内容时将指针置于文件的末尾</td>
</tr>
<tr>
<td>O_SYNC</td>
<td>只在数据被写外存或其他设备之后操作才返回</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功时，返回值为 文件的描述符(大于0的整数)；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>open</code>函数以只读方式打开一个已存在且名为<code>firstFile</code>的文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = open(<span class="string">&quot;firstFile&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279659" alt="img"> 将以上代码保存为<code>openFile.c</code>文件中，编译执行。</p>
<p>案例演示2: 在当前目录下使用<code>open</code>函数创建一个名为<code>secondFile</code>的文件，并设置文件的权限为<code>644</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = open(<span class="string">&quot;secondFile&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279660" alt="img"> 将以上代码保存为<code>secondFile.c</code>文件中，编译执行。可以看到当前目录下存在<code>secondFile</code>文件，并且其权限为<code>644</code>。</p>
<h5 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h5><p>关闭文件的系统调用函数是<code>close</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int close(int fd);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：需关闭文件的描述符；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为 0；调用失败时，返回值为-1，并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>close</code>函数关闭一个已经被打开的文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;firstFile&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = close(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279663" alt="img"> 将以上代码保存为<code>closeFile.c</code>文件中，编译执行。</p>
<h4 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>open_File</code>函数，使其以<strong>读</strong>方式打开一个文件，并返回文件描述符<code>fd</code>。</li>
<li>补全<code>close_File</code>函数，使其关闭一个已经被打开的文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fileName: 需要被打开的文件路径</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_File</span><span class="params">(<span class="keyword">char</span> *fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">0</span>;   <span class="comment">//存放文件描述符</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	fd = open(fileName, O_RDONLY);</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fd: 需要被关闭的文件描述符</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_File</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	fd = close(fd);</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><h4 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h4><p>文件的读写是 <code>I/O</code> 操作的核心内容。上一关中已经介绍了如何打开和关闭一个文件，但是要实现文件的 <code>I/O</code> 操作就必须对其进行读写，文件的读写操作所用的系统调用分别是<code>read</code>和<code>write</code>。本关将介绍文件的读写函数的使用方法。</p>
<p>使用<code>man 2 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="文件的写操作"><a href="#文件的写操作" class="headerlink" title="文件的写操作"></a>文件的写操作</h5><p>写入文件的系统调用函数是<code>write</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>ssize_t write(int fd, void *buf, size_t count);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：表示将对之进行写操作的文件打开时返回的文件描述符；buf：指向存放将写入文件的数据的缓冲区的指针；count：表示本次操作所要写入文件的数据的字节数；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为所写入的字节数；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下往<code>firstFile</code>文件中写入一个字符串。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;firstFile&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *data = <span class="string">&quot;this is firstFile\n&quot;</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入文件成功：写入%ld个字符\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279677" alt="img"> 将以上代码保存为<code>writeFile.c</code>文件中，编译执行。可以看到字符串被写入到<code>firstFile</code>文件中。</p>
<h5 id="文件的读操作"><a href="#文件的读操作" class="headerlink" title="文件的读操作"></a>文件的读操作</h5><p>读取文件的系统调用函数是<code>read</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>ssize_t read(int fd, void *buf, size_t count);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：表示将对之进行写操作的文件打开时返回的文件描述符；buf：指向存放所读数据的缓冲区的指针；count：读操作希望读取的字节数；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为本次读操作实际读取的字节数；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 读取当前目录下<code>firstFile</code>文件中的前4个字符。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;firstFile&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">5</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = read(fd, data, <span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取文件成功：数据：%s\n&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279678" alt="img"> 将以上代码保存为<code>readFile.c</code>文件中，编译执行。可以看到从<code>firstFile</code>文件中读取出了前4个字符。</p>
<h4 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>write_File</code>函数，完成向文件写入字符串功能。并返回实际写入字符个数。</li>
<li>补全<code>readLine</code>函数，完成从文件中读取一行的功能(不包括换行符)，并返回实际读取的字符个数(<strong>文件的换行符号为\n</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fd: 被打开文件的描述符</span></span><br><span class="line"><span class="comment"> * buf: 被写入字符串指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_File</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> writeSize = <span class="number">0</span>; <span class="comment">//返回实际写入的字符个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	writeSize = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> writeSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * fd: 被打开文件的描述符</span></span><br><span class="line"><span class="comment"> * buf: 存放读取的字符串指针(假设buf足够大)</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readLine</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> readSize = <span class="number">0</span>;  <span class="comment">//返回实际读取的字符个数</span></span><br><span class="line">	<span class="keyword">char</span> tempC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提示：使用while循环每次只读取一个字符，判断该字符是否为换行符或者是否已经读取到文件末尾(读取到文件末尾返回值为0)</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">1</span>,length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = read(fd, &amp;tempC, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">0</span>|tempC==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            readSize = readSize+<span class="number">1</span>;</span><br><span class="line">            buf[length++]=tempC;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> readSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h3><h4 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h4><p>当不需要一个文件时，我们通常直接选中文件按下<code>delete</code>键对其删除，本关将介绍如何在Linux系统中使用<code>C</code>语言删除一个已经存在的文件。</p>
<p>在Linux系统中使用<code>unlink</code>和<code>remove</code>系统调用可以实现对文件的删除操作。</p>
<p>使用<code>man 2 函数名</code>或者<code>man 3 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="使用unlink函数删除文件"><a href="#使用unlink函数删除文件" class="headerlink" title="使用unlink函数删除文件"></a>使用unlink函数删除文件</h5><p>删除文件的系统调用函数是<code>unlink</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int unlink(const char *pathname);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要删除的文件绝对路径名或相对路径名；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功时，返回值为0；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 删除当前目录下的<code>firstFile</code>文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = unlink(<span class="string">&quot;firstFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279690" alt="img"> 将以上代码保存为<code>deleteFile1.c</code>文件中，编译执行。可以看到当前目录下存在<code>firstFile</code>文件被删除了。</p>
<h5 id="使用unlink函数删除文件-1"><a href="#使用unlink函数删除文件-1" class="headerlink" title="使用unlink函数删除文件"></a>使用unlink函数删除文件</h5><p><code>remove</code>是删除文件的另一个函数，该函数是<code>C</code>语言的库函数，其本质是通过调用系统调用<code>unlink</code>来完成文件的删除操作，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int remove(const char *pathname);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：需要删除的文件绝对路径名或相对路径名；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功时，返回值为0；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 删除当前目录下的<code>secondFile</code>文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = remove(<span class="string">&quot;secondFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除文件成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/279691" alt="img"> 将以上代码保存为<code>deleteFile2.c</code>文件中，编译执行。可以看到当前目录下存在<code>secondFile</code>文件被删除了。</p>
<h4 id="编程要求-3"><a href="#编程要求-3" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>删除当前目录下的<code>testFile</code>文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = unlink(<span class="string">&quot;testFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="目录文件I-O"><a href="#目录文件I-O" class="headerlink" title="目录文件I/O"></a>目录文件I/O</h2><h3 id="目录文件的创建与删除"><a href="#目录文件的创建与删除" class="headerlink" title="目录文件的创建与删除"></a>目录文件的创建与删除</h3><h4 id="相关知识-4"><a href="#相关知识-4" class="headerlink" title="相关知识"></a>相关知识</h4><p>目录文件是Linux系统中一类比较特殊的文件。它对构成 Linux 系统的整个文件系统结构非常重要。Linux系统提供了两个系统调用函数来实现目录的创建和删除功能，分别是<code>mkdir</code>和<code>rmdir</code>函数，这两个函数的名称和创建/删除目录命令的名称一样。其实创建/删除目录命令的背后实现方法就是调用这两个系统函数来实现对目录的创建和删除功能。</p>
<p>在Linux系统中可以使用<code>man</code>命令来查询这些函数的使用方法。具体的查询命令为： <code>man 2 函数名</code> 其中，<code>2</code>表示查找系统调用函数，关于目录的创建、打开、关闭和删除函数都是系统调用函数，因此使用<code>2</code>作为<code>man</code>命令的第一个参数。</p>
<p>案例演示1: 查询<code>mkdir</code>函数的使用方法可以使用以下命令： <code>man 2 mkdir</code></p>
<p><img src="https://data.educoder.net/api/attachments/287800" alt="img"> [查询结果]</p>
<p>通过<code>man</code>命令可以查询<code>rmdir</code>函数的使用方法。</p>
<h5 id="目录文件的创建"><a href="#目录文件的创建" class="headerlink" title="目录文件的创建"></a>目录文件的创建</h5><p>创建目录文件的系统调用函数是<code>mkdir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/type.h&gt;#include &lt;sys/stat.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：新创建的目录文件名；mode：用于指定所创建目录文件的权限；</span><br></pre></td></tr></table></figure>

<p>常见的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode</span><br></pre></td></tr></table></figure>

<p>取值及其含义见下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>mode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRUSR</td>
<td>目录所有者的读权限位</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>目录所有者的写权限位</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>目录所有者的执行权限位</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>所有者同组用户的读权限位</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>所有者同组用户的写权限位</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>所有者同组用户的执行权限位</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他用户的读权限位</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他用户的写权限位</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他用户的执行权限位</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>在Linux系统中，新创建目录的权限位是<code>(mode &amp; ~ umask &amp; 01777)</code>，也就是<code>umask</code>为进程创建目录的权限位限制。因此会出现用户在代码中设定的权限与实际创建出来的权限不一致情况。同理，对于文件权限的处理也一样。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值<code>0</code>；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 在当前目录下使用<code>mkdir</code>函数创建一个名为<code>firstDir</code>的目录文，并设置目录的权限为<code>644</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;firstDir&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288179" alt="img"> 将以上代码保存为<code>createDir.c</code>文件，编译执行。可以看到当前目录下存在<code>firstDir</code>目录文件，并且其权限为<code>644</code>。</p>
<h5 id="目录文件的删除"><a href="#目录文件的删除" class="headerlink" title="目录文件的删除"></a>目录文件的删除</h5><p>删除目录文件的系统调用函数是<code>rmdir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rmdir(const char *pathname);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathname：要被删除的目录文件名称；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong>使用<code>rmdir</code>库函数删除的目录必须为空，如果该目录不为空，则必须删除该目录的所有文件(<code>.</code>和<code>..</code>文件除外)。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值<code>0</code>；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 使用<code>mkdir</code>函数删除当前目录下名为<code>firstDir</code>的目录文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = rmdir(<span class="string">&quot;firstDir&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288181" alt="img"> 将以上代码保存为<code>deleteDir.c</code>文件中，编译执行。可以看到当前目录下的<code>firstDir</code>目录文件被删除。</p>
<h4 id="编程要求-4"><a href="#编程要求-4" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在当前目录下创建一个名为<code>testDir</code>的目录，并设置其权限为<code>651</code>。</li>
<li>删除当前目录下名为<code>Dir</code>的空目录文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;testDir&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IXGRP | S_IXOTH);</span><br><span class="line">    <span class="keyword">int</span> ret1 = rmdir(<span class="string">&quot;Dir&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目录文件的打开与关闭"><a href="#目录文件的打开与关闭" class="headerlink" title="目录文件的打开与关闭"></a>目录文件的打开与关闭</h3><h4 id="相关知识-5"><a href="#相关知识-5" class="headerlink" title="相关知识"></a>相关知识</h4><p>在Linux系统中提供了以下两个系统调用函数用于打开和关闭目录操作，分别是<code>opendir</code>和<code>closedir</code>，这些库函数不属于系统调用，它们是<code>C</code>语言提供的库函数。本关将介绍目录的打开和关闭函数的使用方法。</p>
<p>因为这两个函数是<code>C</code>语言提供的库函数，因此可以使用<code>man 3 函数名</code>也可以查询这些函数的使用方法。</p>
<h5 id="目录文件的打开"><a href="#目录文件的打开" class="headerlink" title="目录文件的打开"></a>目录文件的打开</h5><p>打开目录文件的库函数是<code>opendir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>DIR *opendir(const char *name);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name：需要打开的目录绝对路径名或相对路径名；</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>打开一个目录后返回一个<code>DIR</code>对象，该对象指向被打开目录的目录流。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值为一个不为空的目录流指针；调用失败时，返回值为<code>NULL</code>的空指针，并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 使用<code>opendir</code>函数打开当前用户的家目录(本实验环境的用户家目录为<code>/home/fzm</code>)。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;/home/fzm&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288609" alt="img"> 将以上代码保存为<code>openDir.c</code>文件中，编译执行。</p>
<h5 id="目录文件的关闭"><a href="#目录文件的关闭" class="headerlink" title="目录文件的关闭"></a>目录文件的关闭</h5><p>关闭目录文件的库函数是<code>closedir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int closedir(DIR *dirp);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirp：需要被关闭的目录流指针；</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值说明： 调用成功时，返回值为 <code>0</code>；调用失败时，返回值为<code>-1</code>，并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 使用<code>closedir</code>函数关闭一个已经被打开的目录。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;/home/fzm/Downloads&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = closedir(dirp);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288611" alt="img"> 将以上代码保存为<code>closeDir.c</code>文件中，编译执行。</p>
<h4 id="编程要求-5"><a href="#编程要求-5" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li><p>补全<code>open_Dir</code>函数，使其打开一个目录并返回目录流指针<code>dirp</code>。</p>
</li>
<li><p>补全<code>close_Dir</code>函数，使其关闭一个被打开的目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * pathName: 需要被打开的目录路径</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function">DIR* <span class="title">open_Dir</span><span class="params">(<span class="keyword">char</span> *pathName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DIR* dirp = <span class="literal">NULL</span>;   <span class="comment">//存放目录流指针</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	dirp = opendir(pathName);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dirp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * dirp: 需要被关闭的目录流指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_Dir</span><span class="params">(DIR* dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">int</span> ret = closedir(dirp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="目录文件的读取操作"><a href="#目录文件的读取操作" class="headerlink" title="目录文件的读取操作"></a>目录文件的读取操作</h3><h4 id="相关知识-6"><a href="#相关知识-6" class="headerlink" title="相关知识"></a>相关知识</h4><p><code>ls</code>命令的背后实现方法就是通过打开被浏览的目录，然后从目录中读取目录项。Linux系统中使用<code>readdir</code>函数可以读取目录内容。本关将介绍目录的读函数的使用方法。</p>
<p>因为<code>readdir</code>函数是<code>C</code>语言提供的库函数，因此可以使用<code>man 3 函数名</code>来查询该函数的使用方法。</p>
<h5 id="目录文件的读操作"><a href="#目录文件的读操作" class="headerlink" title="目录文件的读操作"></a>目录文件的读操作</h5><p>读取目录的库调用函数是<code>readdir</code>，具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>struct dirent *readdir(DIR *dirp);</code></p>
</li>
</ul>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirp：表示被打开目录的流指针；</span><br></pre></td></tr></table></figure>

<p>结构<code>dirent</code>指向目录项，其定义在Linux系统中的<code>&lt;dirent.h&gt;</code>头文件中，详细定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">               <span class="keyword">ino_t</span>   d_ino;       <span class="comment">/* 索引节点号 */</span></span><br><span class="line">               <span class="keyword">off_t</span>    d_off;       <span class="comment">/* 在目录文件中的偏移 */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span>  d_reclen;    <span class="comment">/* 文件名长 */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">char</span>   d_type;      <span class="comment">/* 文件类型 */</span></span><br><span class="line">               <span class="keyword">char</span>  d_name[<span class="number">256</span>]; <span class="comment">/* 文件名，最长255字符 */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>d_name</code>字段存放着所读取到的目录项名。<code>d_type</code>字段为该目录项的类型，常见类型如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DT_DIR：目录文件；DT_LNK：符号链接文件；DT_REG：常规文件；DT_SOCK：sock文件；DT_UNKNOWN：未知的文件类型；</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>d_type</code>字段并不是支持所有的文件系统，并且只是由<code>BSD</code>衍生出来的Linux系统中可用。在Linux系统中还提供了另一个系统调用函数用来判断文件类型，其名称为<a target="_blank" rel="noopener" href="http://www.man7.org/linux/man-pages/man2/stat.2.html">stat</a>，有兴趣的学生可以执行去学习其使用方法。</p>
<ul>
<li>函数返回值说明： 调用成功时，返回值为所写入的字节数；调用失败时，返回值为<code>-1</code>并设置错误编号<code>errno</code>。</li>
</ul>
<p>案例演示1: 读取当前目录下的所有内容，并打印出其名称。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.表示当前目录</span></span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(closedir(dirp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288764" alt="img"> 将以上代码保存为<code>readdir.c</code>文件中，编译执行。可以看到执行该命令后会将当前目录下所有的内容都打印出来。</p>
<p>案例演示2: 读取当前目录下的所有普通文件，并打印出其名称。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.表示当前目录</span></span><br><span class="line">    DIR* dirp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dir-&gt;d_type == DT_REG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(closedir(dirp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭目录成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/288768" alt="img"> 将以上代码保存为<code>readRegDir.c</code>文件中，编译执行。可以看到执行该命令后只会将当前目录下常规文件打印出来了。</p>
<h4 id="编程要求-6"><a href="#编程要求-6" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>scanAll</code>函数，完成读取一个目录下所有的内容，并将每个内容按空格分割打印出来。</li>
<li>补全<code>scanDir</code>函数，完成读取一个目录下直接包含的目录名称(<strong>只读取当前目录层的内容，不往下读取</strong>)，并将每个目录按空格分割打印出来。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * dirp: 被打开的目录流指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanAll</span><span class="params">(DIR *dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//提示：不需要关闭dirp指针，输出的内容不能有换行，每个目录项中间用空格(英文空格)分割</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * dirp: 被打开的目录流指针</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanDir</span><span class="params">(DIR *dirp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提示：不需要关闭dirp指针，输出的内容不能有换行，每个目录项中间用空格(英文空格)分割</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span> =</span> readdir(dirp);</span><br><span class="line">    <span class="keyword">while</span>(dir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dir-&gt;d_type == DT_DIR)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, dir-&gt;d_name);</span><br><span class="line">        dir = readdir(dirp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h1><h2 id="获取进程常见属性"><a href="#获取进程常见属性" class="headerlink" title="获取进程常见属性"></a>获取进程常见属性</h2><p>在  Linux  环境下，进程是一个十分重要的概念。每个进程都由一个唯一的标识符来表示，即进程 ID ，通常称为 pid 。</p>
<p> Linux 系统中存在一个特殊的进程，即空闲进程( idle process )，当没有其他进程在运行时，内核所运行的进程就是空闲进程，它的 pid 为 0 。在启动后，内核运行的第一个进程称为 init 进程，它的 pid 是 1 。通常， Linux 系统中 init 进程就是我们在资源管理器中看到的名为 init 的程序。系统中其它的进程都是由 init 来创建出来的。</p>
<p>创建新进程的那个进程被称为父进程，而新创建的进程被称为子进程。每个进程都是由其他进程创建的(除了 init 进程)，因此每个子进程都有一个父进程。</p>
<p> Linux 系统提供了两个系统调用函数来获取一个进程的 pid 和其父进程的 pid ，分别是 getpid 和 getppid 函数。在 Linux 系统中可以使用 man 命令来查询这些函数的使用方法。具体的查询命令为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 函数名 </span><br></pre></td></tr></table></figure>

<h5 id="获取进程自身-pid"><a href="#获取进程自身-pid" class="headerlink" title="获取进程自身 pid"></a>获取进程自身 pid</h5><p>获取进程本身的进程 ID 的系统调用函数是 getpid ，具体的说明如下：</p>
<ul>
<li>需要的头文件如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 返回当前进程的 pid 值。</p>
</li>
</ul>
<h5 id="获取父进程-pid"><a href="#获取父进程-pid" class="headerlink" title="获取父进程 pid"></a>获取父进程 pid</h5><p>获取父进程的进程 ID 的系统调用函数是 getppid ，具体的说明如下：</p>
<ul>
<li>需要的头文件如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getppid(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 返回当前进程的父进程的 pid 值。</p>
</li>
</ul>
<h4 id="编程要求-7"><a href="#编程要求-7" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 getProcInfo 函数，用于获取当前进程 ID 和其父进程 ID (<strong>提示：将结果存放在procIDInfo结构体中</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************</span></span><br><span class="line"><span class="comment"> * pid: 当前进程ID</span></span><br><span class="line"><span class="comment"> * ppid: 父进程ID</span></span><br><span class="line"><span class="comment">***********************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">procIDInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">pid_t</span> ppid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 返回值: 需要被打开的目录路径</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function">struct procIDInfo <span class="title">getProcInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">procIDInfo</span> <span class="title">ret</span>;</span>   <span class="comment">//存放进程ID信息，并返回</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line">	<span class="keyword">pid_t</span> ppid = getppid();</span><br><span class="line">    </span><br><span class="line">    ret.pid=pid;</span><br><span class="line">    ret.ppid=ppid;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程创建操作-fork"><a href="#进程创建操作-fork" class="headerlink" title="进程创建操作-fork"></a>进程创建操作-fork</h2><p>当用户调用 fork 函数时，系统将会创建一个与当前进程相同的新进程。通常将原始进程称为父进程，而把新生成的进程称为子进程。子进程是父进程的一个拷贝，子进程获得同父进程相同的数据，但是同父进程使用不同的数据段和堆栈段。</p>
<p>在早期的系统中，创建进程比较简单。当调用 fork 时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容也复制到子进程的地址空间中。但是从内核角度来说，这种复制方式是非常耗时的。</p>
<p>因此，在现代的系统中采取了更多的优化。现代的 Linux 系统采用了写时复制技术( Copy on Write )，而不是一创建子进程就将所有的数据都复制一份。</p>
<p> Copy on Write ( COW )的主要思路是：如果子进程/父进程只是读取数据，而不是对数据进行修改，那么复制所有的数据是不必要的。因此，子进程/父进程只要保存一个指向该数据的指针就可以了。当子进程/父进程要去修改数据时，那么再复制该部分数据即可。这样也不会影响到子父进程的执行。因此，在执行 fork 时，子进程首先只复制一个页表项，当子进程/父进程有写操作时，才会对所有的数据块进行复制操作。</p>
<h5 id="使用fork函数创建进程"><a href="#使用fork函数创建进程" class="headerlink" title="使用fork函数创建进程"></a>使用fork函数创建进程</h5><p> fork 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功， fork 函数两个值，分别是 0 和子进程 ID 号。当调用失败时，返回 -1 ，并设置错误编号 errno 。fork 函数调用将执行两次返回，它将从父进程和子进程中分别返回。从父进程返回时的返回值为子进程的  PID ，,而<strong>从子进程返回时的返回值为 0 ，并且返回都将执行 fork 之后的语句</strong>。</p>
</li>
</ul>
<p>案例演示1: 编写一个程序，使用 fork 函数创建一个新进程，并在子进程中打印出其进程 ID 和父进程 ID ，在父进程中返回进程 ID 。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为子进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为父进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/292824" alt="img"></p>
<p>将以上代码保存为 forkProcess.c 文件，编译执行。可以看到每次执行 forkProcess 时，子进程和父进程都不是固定的执行顺序，因此由 fork 函数创建的子进程执行顺序是由操作系统调度器来选择执行的。因此，子进程和父进行在执行的时候顺序不固定。</p>
<h4 id="编程要求-8"><a href="#编程要求-8" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 createProcess 函数，使用 fork 函数创建进程，并在子进程中输出 “Children” 字符串，在父进程中输出 “Parent” 字符串。(<strong>注意：不要在 createProcess 函数中使用 exit 函数或者 return 来退出程序</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 不要在子进程或父进程中使用exit函数或者return来退出程序</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Children&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="进程创建操作-vfork"><a href="#进程创建操作-vfork" class="headerlink" title="进程创建操作-vfork"></a>进程创建操作-vfork</h2><p> vfork 函数是一个历史遗留产物。 vfork 创建进程与 fork 创建的进程主要有一下几点区别：</p>
<ol>
<li><strong>vfork创建的子进程与父进程共享所有的地址空间</strong>，而fork创建的子进程是采用COW技术为子进程创建地址空间；</li>
<li>vfork会使得<strong>父进程被挂起</strong>，直到<strong>子进程正确退出后父进程才会被继续执行</strong>，而fork创建的子进程与父进程的<strong>执行顺序是由操作系统调度来决定</strong>。</li>
</ol>
<p> <strong>vfork 性能要比 fork 高</strong>，主要原因是 vfork 没有进行所有数据的复制，尽管 fork 采用了 COW 技术优化性能，但是也会为子进程的页表项进行复制，因此 vfork 要比 fork 快。</p>
<p>使用 vfork 时要注意，<strong>在子进程中对共享变量的修改也会影响到父进程</strong>，因此 vfork 在带来高性能的同时，也使得整个程序容易出错，因此，开发人员在使用 vfork 创建进程时，一定要注意对共享数据的修改。</p>
<p>由于 vfork 创建的子进程和父进程共享所有的数据(栈、堆等等)，因此，<strong>采用 vfork 创建的子进程必须使用 exit 或者 exec 函数族</strong>(下一关将介绍这些函数的功能)来正常退出，不<strong>能使用 return 来退出</strong>。</p>
<p> exit 函数是用来<strong>结束正在运行的整个程序</strong>， exit 是<strong>系统调用级别</strong>，它表示一个进程的结束；而 <strong>return  是语言级别的，它表示调用堆栈的返回</strong>。</p>
<h5 id="使用-vfork-函数创建进程"><a href="#使用-vfork-函数创建进程" class="headerlink" title="使用 vfork 函数创建进程"></a>使用 vfork 函数创建进程</h5><p> vfork 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t vfork(void); </span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功， vfork 函数两个值，分别是 0 和子进程 ID 号。当调用失败时，返回 -1 ，并设置错误编号 errno 。</p>
</li>
</ul>
<p><strong>注意：</strong> <strong>vfork 函数调用将执行两次返回，它将从父进程和子进程中分别返回</strong>。<strong>从父进程返回时的返回值为子进程的  PID ,而从子进程返回时的返回值为 0</strong> ，并且返回都将执行 vfork 之后的语句。 <strong>vfork 创建的子进程必须调用 exit 函数来退出子进程</strong>。</p>
<p>案例演示 1 : 编写一个程序，使用 vfork 函数创建一个新进程，并在子进程中打印出其进程 ID 和父进程 ID ，在父进程中返回进程 ID 。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);  <span class="comment">//睡眠2秒</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为子进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为父进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293076" alt="img"></p>
<p>将以上代码保存为 vforkProcess.c 文件，编译执行。可以看到 vforkProcess 创建的子进程尽管使用 sleep 函数睡眠了 2 秒，但是函数父进程的执行顺序在子进程后，这就是 vfork 的特性。</p>
<p>当我们将以上代码中的 exit(0) 换成 return 0 时，则会出现如下错误。</p>
<p><img src="https://data.educoder.net/api/attachments/293087" alt="img"></p>
<p>出现以上错误的原因是当子进程使用 return 退出时，操作系统也会把栈清空，那么当父进程继续使用 return 退出时，则会发现栈已经被清空了，这就相当于 free 两次同一块内存，因此会出现错误。</p>
<h4 id="编程要求-9"><a href="#编程要求-9" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 createProcess 函数，使用 vfork 函数创建进程，并在子进程中输出”Children”字符串(<strong>提示：需要换行</strong>)，在父进程中输出”Parent”字符串(<strong>提示：需要换行</strong>)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 不要在子进程中使用return来退出程序</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Children\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程和父进程分别会执行的内容</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>常见与退出进程相关的函数有： exit 、 _exit 、 atexit 、 on_exit 、 abort 和 assert 。</p>
<ol>
<li>exit 函数是标准 C 库中提供的函数，它用来终止正在运行的程序，并且<strong>关闭所有 I/O 标准流</strong>。</li>
<li>_exit 函数也可用于结束一个进程，与 exit 函数不同的是， <strong>_exit 不会关闭所有 I/O 标准流</strong>。</li>
<li>atexit  函数用于<strong>注册一个不带参数也没有返回值的函数以供程序正常退出时被调用</strong>。</li>
<li>on_exit  函数的作用与 atxeit 函数十分类似，不同的是<strong>它注册的函数具有参数，退出状态和参数 arg 都是传递给该程序使用的</strong>。</li>
<li>abort 函数其实是用来<strong>发送一个 SIGABRT 信号</strong>，<strong>这个信号将使当前进程终止</strong>。</li>
<li>assert 是一个宏。<strong>调用 assert 时，它将先计算参数表达式  expression 的值,如果为 0 ，则调用 abort 函数结束进程</strong>。</li>
</ol>
<p><img src="https://data.educoder.net/api/attachments/293648" alt="img"></p>
<p>[ exit 和 _exit 区别]</p>
<h5 id="exit-和-exit-使用方法"><a href="#exit-和-exit-使用方法" class="headerlink" title="exit 和 _exit 使用方法"></a>exit 和 _exit 使用方法</h5><p> exit 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void exit(int status);</span><br></pre></td></tr></table></figure>

<p>参数说明： status：设置程序退出码；</p>
<p>_exit 函数的具体的说明如下：</p>
</li>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<p>参数说明： status ：设置程序退出码；</p>
</li>
<li><p>函数返回值说明： exit 和 _exit 均无返回值。</p>
</li>
</ul>
<h5 id="atexit-和-on-exit-使用方法"><a href="#atexit-和-on-exit-使用方法" class="headerlink" title="atexit 和 on_exit 使用方法"></a>atexit 和 on_exit 使用方法</h5><p> atexit 和 on_exit 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int atexit(void (*function)(void));</span><br><span class="line">int on_exit(void (*function)(int , void *), void *arg);</span><br></pre></td></tr></table></figure>

<p>参数说明： atexit 函数的 function 参数是一个函数指针，指向无返回值和无参数的函数； on_exit 函数的 function 参数是一个函数指针，指向无返回值和有两个参数的函数，其中第一个参数是调用 exit() 或从 main 中返回时的值，参数 arg 指针会传给参数 function 函数；</p>
</li>
<li><p>函数返回值说明： atexit 和 on_exit 调用成功返回 0 ；调用失败返回一个非零值。</p>
</li>
</ul>
<p><strong>注意：</strong> <strong>atexit 和 on_exit 只有在程序使用 exit 或者 main 中正常退出时才会有效。如果程序使用 _exit 、 abort 或 assert 退出程序时，则不会执行被注册的函数</strong>。</p>
<h5 id="abort-和-assert-使用方法"><a href="#abort-和-assert-使用方法" class="headerlink" title="abort 和 assert 使用方法"></a>abort 和 assert 使用方法</h5><p> abort 函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void abort(void);</span><br></pre></td></tr></table></figure>

<p>assert 宏的具体的说明如下：</p>
</li>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void assert(scalar expression);</span><br></pre></td></tr></table></figure>

<p>参数说明： expression ：需要被判断的表达式；</p>
</li>
</ul>
<p><strong>注意：</strong> assert 宏通常用于调试程序。</p>
<ul>
<li>函数返回值说明： abort 和 assert 无返回值。</li>
</ul>
<p>案例演示 1 : 使用 atexit 注册一个退出函数，使其在调用退出函数前被执行，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序正在被退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(atexit(out) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用atexit函数错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;```<span class="comment">//或者exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293727" alt="img"></p>
<p>将以上代码保存为 atexit.c 文件，编译执行。可以看到执行 atexit 程序后， out 函数被调用。</p>
<p>案例演示 2 : 使用 on_exit 注册一个退出函数，使其在调用退出函数前被执行，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d)\n&quot;</span>, (<span class="keyword">char</span> *s)arg, status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(on_exit(out, <span class="string">&quot;程序正在被退出&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用on_exit函数错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);```<span class="comment">//或者return 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293737" alt="img"></p>
<p>将以上代码保存为 on_exit.c 文件，编译执行。可以看到执行 on_exit 程序后， out 函数被调用，并且 status 变量的值就是 exit 函数退出的值。</p>
<p>案例演示1: 使用 abort 终止一个程序，详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293754" alt="img"></p>
<p>将以上代码保存为 abort.c 文件，编译执行。可以看到执行 abort 程序后，程序被强行终止。</p>
<h4 id="编程要求-10"><a href="#编程要求-10" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，具体要求如下：</p>
<ul>
<li>补全 exitProcess 函数，使用 atexit 函数注册一个函数，在注册函数中打印出当前进程的 ID 号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 用户需要在exitProcess函数中使用atexit函数注册一个自定义函数，并在自定义函数中打印出当前进程ID号</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exitProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">if</span>(atexit(out) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;调用atexit函数错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h2><p>**如果，当子进程在父进程前结束，则内核会把子进程设置为一个特殊的状态。这种状态的进程叫做僵死进程(<code>zombie</code>)**。尽管子进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是仍然保留了一些信息(如进程号<code>pid</code>退出状态 运行时间等)。只有父进程获取了子进程的这些信息后，子进程才会彻底的被销毁，否则一直保持僵死状态。如果系统中产生大量的僵尸进程，将导致系统没有可用的进程号，从而导致系统不能创建新的进程。</p>
<p>Linux处理僵死进程的方法之一是使用进程等待的系统调用<code>wait</code>和<code>waitpid</code>来使得父进程获取子进程的终止信息。</p>
<h5 id="wait函数使用方法"><a href="#wait函数使用方法" class="headerlink" title="wait函数使用方法"></a>wait函数使用方法</h5><p><code>wait</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>wait</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数格式如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pid_t wait(int *status);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参数说明： 参数`status`是一个整数指针，当子进程结束时，将子进程的结束状态字存放在该指针指向的缓存区。利用这个状态字，需要时可以使用一些由 Linux 系统定义的宏来了解子程序结束的原因。这些宏的定义与作用如下:</span><br><span class="line"></span><br><span class="line">| 宏定义              | 含义                                                         |</span><br><span class="line">| ------------------- | ------------------------------------------------------------ |</span><br><span class="line">| WIFEXITED(status)   | 子进程正常结束时，返回值为真(非零值)                         |</span><br><span class="line">| WEXITSTATUS(status) | 当WIFEXITED为真时，此宏才可以使用。返回进程退出的代码        |</span><br><span class="line">| WIFSIGNALED(status) | 子进程接收到信号结束时，返回值为真。但如果进程接收到信号时调用exit函数结束，则返回值为假 |</span><br><span class="line">| WTERMSIG(status)    | 当 WIFSIGNALED 为真时，将获得终止该进程的信号                |</span><br><span class="line"></span><br><span class="line">- 函数返回值说明： 调用成功时，返回值为被置于等待状态的进程的 `pid`；执行失败返回`-1`并设置错误代码`errno`。</span><br><span class="line"></span><br><span class="line">##### waitpid函数使用方法</span><br><span class="line"></span><br><span class="line">`waitpid`函数的具体的说明如下：</span><br><span class="line"></span><br><span class="line">- 需要的头文件如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  waitpid</span><br></pre></td></tr></table></figure>

<p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid</span><br></pre></td></tr></table></figure>

<p>：用于指定所等待的进程。其取值和相应的含义如下所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>pid</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>pid &gt; 0</td>
<td>等待进程<code>ID</code>为<code>pid</code>所指定值的子进程</td>
</tr>
<tr>
<td>pid = 0</td>
<td>等待进程组<code>ID</code>与该进程相同的子进程</td>
</tr>
<tr>
<td>pid = -1</td>
<td>等待所有子进程，等价于<code>wait</code>调用</td>
</tr>
<tr>
<td>pid &lt; -1</td>
<td>等待进程组<code>ID</code>为<code>pid</code>绝对值的子进程</td>
</tr>
</tbody></table>
<p>参数<code>option</code>则用于指定进程所做操作。其取值和相应的含义如下所示：</p>
<table>
<thead>
<tr>
<th>option</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>将进程挂起等待其结束</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>不使进程挂起而立刻返回</td>
</tr>
<tr>
<td>WUNTRACED</td>
<td>如果进程已结束则返回</td>
</tr>
</tbody></table>
<p>参数<code>status</code>是一个整数指针，当子进程结束时，将子进程的结束状态字存放在该指针指向的缓存区。</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>WIFEXITED(status)</td>
<td>子进程正常结束时，返回值为真(非零值)</td>
</tr>
<tr>
<td>WEXITSTATUS(status)</td>
<td>当WIFEXITED为真时，此宏才可以使用。返回进程退出的代码</td>
</tr>
<tr>
<td>WIFSIGNALED(status)</td>
<td>子进程接收到信号结束时，返回值为真。但如果进程接收到信号时调用exit函数结束，则返回值为假</td>
</tr>
<tr>
<td>WTERMSIG(status)</td>
<td>当WIFSIGNALED为真时，将获得终止该进程的信号</td>
</tr>
<tr>
<td>WIFSTOPPED(status)</td>
<td>在调用函数waitpid时制定了WUNTRACED选项，且该子进程使waitpid返回时，这个宏的返回值为真</td>
</tr>
<tr>
<td>WSTOPSIG(status)</td>
<td>当WIFSTOPPED为真时，将获得停止该进程的信号</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功时，返回收集到的子进程的进程<code>pid</code>；当设置选项<code>WNOHANG</code>，而调用中<code>waitpid</code>发现没有已退出的子进程可收集，则返回<code>0</code>；执行失败返回<code>-1</code>并设置错误代码<code>errno</code>。</li>
</ul>
<p>案例演示1: 编写一个程序，使用<code>fork</code>函数与<code>wait</code>函数结合创建一个新进程，使得新创建的子进程在父进程前执行。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>(wait(&amp;status) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，退出代码：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294404" alt="img"></p>
<p>案例演示1: 编写一个程序，使用<code>fork</code>函数与<code>waitpid</code>函数结合创建一个新进程，使得新创建的子进程在父进程前执行。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，退出代码：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294406" alt="img"> 将以上代码保存为<code>waitpidProcess.c</code>文件，编译执行。可以看到执行<code>waitpidProcess</code>程序后，尽管子进程使用<code>sleep</code>睡眠了<code>2</code>秒，还是子进程先执行，然后父进程才执行。<code>waitpid</code>函数可以实现与<code>wait</code>函数相同的功能。</p>
<h4 id="编程要求-11"><a href="#编程要求-11" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>waitProcess</code>函数，等待子进程结束，并且返回子进程的退出的代码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功且子进程正常退出返回退出代码，否则返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="keyword">return</span> WEXITSTATUS(status); </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="进程创建操作-exec函数族"><a href="#进程创建操作-exec函数族" class="headerlink" title="进程创建操作-exec函数族"></a>进程创建操作-exec函数族</h2><p>在上一个实训中提到，**<code>vfork</code>函数创建的子进程可以通过调用<code>exec</code>函数族来正确退出<strong>。其原理是，</strong>使用<code>exec</code>函数族可以执行一个新的程序，并且以新的子进程来完全替换原有的进程地址空间**。</p>
<p><code>exec</code>函数族的作用是根据<strong>指定的文件名找到可执行文件，并用它来取代调用进程的内容</strong>，换句话说，就是在<strong>调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何<code>Linux</code>下可执行的脚本文件。</strong></p>
<p><strong>通常<code>exec</code>函数族用来与<code>vfork</code>函数结合一起使用。使用<code>vfork</code>函数创建一个子进程，然后在子进程中使用<code>exec</code>函数族来执行一个新的程序。当在由<code>vfork</code>创建的子进程中使用<code>exec</code>函数族来执行新程序时，子进程的地址空间会被新执行的程序完全覆盖，并且此时<code>vfork</code>的父进程与子进程地址空间被分离开，也就是使用<code>exec</code>函数族创建的新程序不会对<code>vfork</code>的父进程造成任何影响。</strong></p>
<p><code>exec</code>函数族是库函数，因此使用<code>man 3 exec</code>来查看其使用方法。</p>
<h5 id="使用exec函数族创建进程"><a href="#使用exec函数族创建进程" class="headerlink" title="使用exec函数族创建进程"></a>使用exec函数族创建进程</h5><p><code>exec</code>函数族的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数族格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...  <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],  <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ol>
<li><p>函数名中含有字母l的函数，其参数个数不定。其参数由所调用程序的命令行参数列表组成，最后一个NULL表示结束。函数名中含所有字母v的函数，则是使用一个字符串数组指针argv指向参数列表，这一字符串数组和含有l的函数中的参数列表完全相同，也同样以NULL结束。</p>
</li>
<li><p>函数名中含有字母p的函数可以自动在环境变量PATH指定的路径中搜索要执行的程序。因此它的第一个参数为file表示可执行函数的文件名。而其他函数则需要用户在参数列表中指定该程序路径，其第一个参数path 是路径名。路径的指定可以是绝对路径，也可一个是相对路径。但出于对系统安全的考虑，建议使用绝对路径而尽量避免使用相对路径。</p>
</li>
<li><p>函数名中含有字母e的函数，比其他函数多含有一个参数envp。该参数是字符串数组指针，用于制定环境变量。调用这两个函数时，可以由用户自行设定子进程的环境变量，存放在参数envp所指向的字符串数组中。这个字符串数组也必须由NULL结束。其他函数则是接收当前环境。</p>
<p>函数返回值说明： 只有当函数执行失败时，<code>exec</code>函数族才会返回<code>-1</code>并设置错误代码<code>errno</code>。当执行成功时，<code>exec</code>函数族是不会返回任何值。</p>
</li>
</ol>
</li>
</ul>
<p>案例演示<code>1</code>: 编写一个程序，使用<code>vfork</code>函数与<code>exec</code>函数族结合创建一个新进程，并在子进程中执行<code>touch testFile</code>命令创建一个<code>testFile</code>文件，在父进程中返回进程<code>ID</code>。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">&quot;touch&quot;</span>, <span class="string">&quot;touch&quot;</span>, <span class="string">&quot;testFile&quot;</span>,  <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//执行execlp函数失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程为父进程：pid(%d)，ppid(%d)\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果执行execlp成功，则以下代码只会被父进程执行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/293501" alt="img"> 将以上代码保存为<code>execlProcess.c</code>文件，编译执行。可以看到执行<code>execlProcess</code>程序后，在当前目录下创建了一个名为<code>testFile</code>的文件。</p>
<h4 id="编程要求-12"><a href="#编程要求-12" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>execlProcess</code>函数，使用<code>vfork</code>函数创建进程，并在子进程中调用创建一个名为<code>testDir</code>的目录，在父进程中输出”Parent Process”字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 提示: 在子进程中如果执行exec函数失败要使用exit函数正确退出子进程</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execlProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = vfork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//子进程</span></span><br><span class="line">		<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">		<span class="keyword">if</span>(execlp(<span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;testDir&quot;</span>,  <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//执行execlp函数失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/********** END **********/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//父进程</span></span><br><span class="line">		<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Parent Process&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/********** END **********/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程创建操作-system"><a href="#进程创建操作-system" class="headerlink" title="进程创建操作-system"></a>进程创建操作-system</h2><p><code>system</code>函数是一个和操作系统相关紧密的函数。用户可以使用它来在用户自己的程序中调用系统提供的各种命令。</p>
<p>执行系统的命令行,其实也是调用程序创建一个进程来实现的。实际上，<code>system</code>函数的实现正是通过调用<code>fork</code>、<code>exec</code>和<code>waitpid</code>函数来完成的。详细的实现思路是：首先使用<code>fork</code>创建一个新的进程，并且在子进程中通过调用<code>exec</code>函数族来执行一个新程序，在父进程中通过<code>waitpid</code>函数等待子进程的结束，同时也获取子进程退出代码。</p>
<p><code>system</code>函数是库函数，因此使用<code>man 3 system</code>来查看其使用方法。</p>
<h5 id="使用system函数执行程序一个新程序"><a href="#使用system函数执行程序一个新程序" class="headerlink" title="使用system函数执行程序一个新程序"></a>使用system函数执行程序一个新程序</h5><p><code>system</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int system(const char *command);</span><br></pre></td></tr></table></figure>

<p>参数说明： <code>command：需要被执行的命令；</code></p>
</li>
<li><p>函数返回值说明： 执行成功，返回值是执行命令得到的返回状态，如同<code>wait</code>的返回值一样。执行失败时返回的值分为以下几种情况：执行<code>system</code>函数时，它将调用<code>fork</code>、<code>exec</code>和<code>waitpid</code>函数。其中任意一个调用失败都可以使得<code>system</code>函数的调用失败。如果调用<code>fork</code>函数出错，则返回值为<code>-1</code>，<code>errno</code>被设置为相应错误；如果调用<code>exec</code>时失败，则表示<code>shell</code>无法执行所设命令，返回值为<code>shell</code>操作的返回值；如果调用<code>waitpid</code>函数失败,则返回值也为<code>-1</code>，<code>errno</code>被置为相应值。</p>
</li>
</ul>
<p>案例演示<code>1</code>: 编写一个程序，使用<code>system</code>函数来执行<code>touch testFile</code>命令创建一个<code>testFile</code>文件。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = system(<span class="string">&quot;touch testFile&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;执行 touch testFile 命令失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294596" alt="img"> 将以上代码保存为<code>system.c</code>文件，编译执行。可以看到执行<code>system</code>程序后，在当前目录下创建了一个名为<code>testFile</code>的文件。</p>
<h4 id="编程要求-13"><a href="#编程要求-13" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>createProcess</code>函数，使用<code>system</code>函数创建一个名为<code>testDir</code>的目录(** 调用成功返回命令的状态码，失败返回-1**)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功返回命令的状态码，失败返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	ret = system(<span class="string">&quot;mkdir testDir&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现一个简单的命令解析器"><a href="#实现一个简单的命令解析器" class="headerlink" title="实现一个简单的命令解析器"></a>实现一个简单的命令解析器</h2><p>在<code>Linux</code>系统中<code>Shell</code>是非常重要的一个工具，<code>Shell</code>是一个用<code>C</code>语言编写的程序，它是用户使用 <code>Linux</code> 的桥梁。当打开一个<code>Shell</code>（终端），我们直接可以在命令行中输入要执行的命令，然后<code>Shell</code>会自动的读取我们输入的命令，最后执行这些命令。</p>
<p><code>RShell</code>的主要思路是：（1）读取用户输入的命令；（2）然后创建一个子进程；（3）使用<code>exec</code>函数族来执行输入的命令，同时挂起父进程；当子进程执行完成后，重复执行步骤<code>1-3</code>即可实现一个简单的命令解析器工具。</p>
<h5 id="使用system函数实现一个简单的命令解析器"><a href="#使用system函数实现一个简单的命令解析器" class="headerlink" title="使用system函数实现一个简单的命令解析器"></a>使用<code>system</code>函数实现一个简单的命令解析器</h5><p><code>system</code>函数可以执行一个命令，那么本案例将介绍如何使用<code>system</code>函数来实现一个简单的命令解析器<code>RShell</code>。详细的步骤可分为以下几步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取用户输入；</span><br><span class="line">调用system函数执行命令；</span><br><span class="line">重复第一步；</span><br></pre></td></tr></table></figure>

<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RShell&gt;&gt;&quot;</span>);   </span><br><span class="line">        gets(command);</span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//当用户输入exit命令后，退出RShell工具</span></span><br><span class="line">        system(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294667" alt="img"> 将以上代码保存为<code>systemRShell.c</code>文件中，编译执行。可以看到执行<code>systemRShell</code>命名后，我们就可以输入要执行的命令，然后按下回车，该命令就会被执行。当想退出<code>systemRShell</code>时，只需要输入<code>exit</code>回车即可。</p>
<h5 id="使用fork、exec函数族和wait实现一个简单的命令解析器"><a href="#使用fork、exec函数族和wait实现一个简单的命令解析器" class="headerlink" title="使用fork、exec函数族和wait实现一个简单的命令解析器"></a>使用<code>fork</code>、<code>exec</code>函数族和<code>wait</code>实现一个简单的命令解析器</h5><p><code>fork</code>和<code>exec</code>也可以完成执行一个新程序。详细的步骤可分为以下几步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">读取用户输入；</span><br><span class="line">调用fork函数创建一个子进程；</span><br><span class="line">在子进程中调用exec来执行用户输入的命令；</span><br><span class="line">在父进程中使用wait来等待子进程执行结束；</span><br><span class="line">重复第一步；</span><br></pre></td></tr></table></figure>

<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RShell&gt;&gt;&quot;</span>);   </span><br><span class="line">        gets(command);</span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(command, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//当用户输入exit命令后，退出RShell工具</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创建进程失败(%s)!\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *file;</span><br><span class="line">            <span class="keyword">char</span> *point = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">char</span> *tmpArg[<span class="number">10</span>];</span><br><span class="line">            point = strtok(command, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            file = point;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(point != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(index == <span class="number">9</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                tmpArg[index++] = point;</span><br><span class="line">                point = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> **arg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)*(index+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                arg[i] = tmpArg[i];</span><br><span class="line">            arg[index] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(execvp(file, arg) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//执行execvp函数失败</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> status;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/294720" alt="img"> 将以上代码保存为<code>execRShell.c</code>文件中，编译执行。可以看到使用<code>fork</code>、<code>exec</code>和<code>wait</code>也可以实现一个简单的命令解析器工具。</p>
<h4 id="编程要求-14"><a href="#编程要求-14" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>RShell</code>函数，实现一个简单的命令解析器工具。(<strong>提示：可以使用system函数或者fork+exec+wait。</strong>)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * 参数cmd: 存放要被执行的命令</span></span><br><span class="line"><span class="comment"> * 参数commandNum: 命令的个数</span></span><br><span class="line"><span class="comment"> * 案例: cmd = &#123;&quot;ls&quot;, &quot;touch testFile&quot;&#125;   commandNum = 2</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RShell</span><span class="params">(<span class="keyword">char</span> *cmd[], <span class="keyword">int</span> commandNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;=commandNum)&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            system(cmd[temp]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h1><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h4 id="相关知识-7"><a href="#相关知识-7" class="headerlink" title="相关知识"></a>相关知识</h4><p>在 Linux 中，每一个信号都有一个名字，这些名字以 SIG 开头。例如， SIGABRT 是夭折信号，当进程调用 abort 函数时会产生这种信号。SIGALRM 是闹钟信号，由 alarm 函数设置的定时器超时后将产生此信号。</p>
<h5 id="信号产生"><a href="#信号产生" class="headerlink" title="信号产生"></a>信号产生</h5><p>信号产生是指<strong>触发信号</strong>的事件的发生。</p>
<p>例如，通过键盘输入组合键<code>CTRL+C</code>系统会收到 SIGINT。 通过<code>killall -sigid processname</code>以给指定进程发送信号。</p>
<p>比如<code>killall -SIGKILL testsignal</code>给 testsignal 发送 SIGKILL 信号，即杀死进程的信号。</p>
<p>SIGUSR1 和 SIGUSR2 是<strong>用户自定义</strong>信号，通过上述的方式也可以将信号 SIGUSR1 和 SIGUSR2 传递给进程。</p>
<h5 id="信号的处理动作"><a href="#信号的处理动作" class="headerlink" title="信号的处理动作"></a>信号的处理动作</h5><p>信号是异步事件的经典实例，产生信号的事件对进程而言是<strong>随机</strong>出现的。进程不能简单地测试一个变量来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行以下操作”。</p>
<p>在某个信号出现时，可以告诉内核按照以<strong>下三种方式之一</strong>进行处理，我们称之为信号的处理或与信号相关的动作：</p>
<ul>
<li><strong>忽略</strong>此信号。大多数信号可以使用这种方式进行处理，但是 SIGKILL 和 SIGSTOP 除外。</li>
<li><strong>捕获</strong>信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。</li>
<li><strong>执行系统默认动作</strong>。对于大多数信号来说，系统默认动作是终止该进程。</li>
</ul>
<h5 id="信号处理过程"><a href="#信号处理过程" class="headerlink" title="信号处理过程"></a>信号处理过程</h5><h6 id="注册信号处理函数"><a href="#注册信号处理函数" class="headerlink" title="注册信号处理函数"></a>注册信号处理函数</h6><p>信号的处理是由内核来代理的，首先程序通过 signal 为每个信号<strong>注册</strong>处理函数，而内核中有一张信号向量表，对应信号处理机制。这样，信号在进程中注销完毕之后，会调用相应的<strong>处理函数</strong>进行处理。</p>
<h5 id="信号的检测与响应时机"><a href="#信号的检测与响应时机" class="headerlink" title="信号的检测与响应时机"></a>信号的检测与响应时机</h5><p>在系统调用或中断返回用户态的前夕，内核会检查未决信号集，进行相应的信号处理。</p>
<h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><ul>
<li>程序运行在用户态时；</li>
<li>进程由于系统调用或中断进入内核；</li>
<li>转向用户态执行信号处理函数；</li>
<li>信号处理函数完毕后进入内核；</li>
<li>返回用户态继续执行程序。</li>
</ul>
<h5 id="signal处理接口"><a href="#signal处理接口" class="headerlink" title="signal处理接口"></a>signal处理接口</h5><p> signal 函数是最简单的信号处理接口，也是使用比较广泛的一个接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/189475" alt="预览大图"></p>
<p>参数的含义：</p>
<ul>
<li><code>signum</code>：信号名，一般不允许是 SIGKILL 或 SIGSTOP ；</li>
<li><code>handler</code>：常量 SIG_IGN、常量 SIG_DFL或者当收到此信号后要调用的函数的地址。如果是 SIG_IGN，则忽略此信号。如果是 SIG_DFL，则使用系统默认动作。</li>
</ul>
<p>返回值：返回 sighandler_t句柄或者 SIG_ERR。</p>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal(SIGINT,<span class="keyword">catch</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;catch signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行步骤如下： 运行程序： 在 10s 内按键<code>CTRL+Ｃ</code>。</p>
<p>运行结果如下： <code>hello!</code> <code>^Ccatch signal!</code> <code>hello!</code></p>
<h4 id="编程要求-15"><a href="#编程要求-15" class="headerlink" title="编程要求"></a>编程要求</h4><p>在主函数的最开始会初始化一个全部变量 g_i4event 为 0。</p>
<p>本关的编程任务是补全右侧代码片段中两段<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在 do _signal中分别为信号 SIGUSR1 、 SIGUSR2 注册信号处理函数 funcA 和 funcB ，而后将 g_i4event 置为 1；</li>
<li>完成两个信号处理函数，其中 funcA 中将 g_i4event 置为 2， funcB 中将 g_i4event 为 3。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_i4event;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">/********Begin********/</span></span><br><span class="line"><span class="comment">/*实现funcA和funcB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The courier has received the task of dispatching milk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The courier has gotten the milk from the store\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The courier has received the task of dispatching milk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The courier has not taken the milk from store\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g_i4event==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The courier has put the milk in your box\n&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********End*********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_signal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********Begin********/</span></span><br><span class="line">   </span><br><span class="line">	signal(SIGUSR1,funcA);</span><br><span class="line">	signal(SIGUSR2,funcB);</span><br><span class="line">     </span><br><span class="line">	g_i4event=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*********End*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="signal高级处理之sigaction"><a href="#signal高级处理之sigaction" class="headerlink" title="signal高级处理之sigaction"></a>signal高级处理之sigaction</h2><p>在 Linux 信号处理函数中，signal函数是最基本的，由于系统版本的不同，signal 由<strong>ISO C</strong>定义。因为 ISO C 不涉及到多进程、进程组以及终端 I /O等，所以它对信号的定义<strong>比较模糊</strong>。</p>
<p>从<strong>Unix system V</strong>派生的实现支持 signal 函数，但该函数提供旧的<strong>不可靠信号语义</strong>。4.4BSD 也提供了 signal 函数，并且提供了<strong>新</strong>的信号语义。</p>
<p>因此，signal 的语义与实现有关，为了保险起见，最好使用别的函数来代替 signal 函数。这个函数是 sigaction，也是本实训讲解的重点。</p>
<h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><p> sigaction 函数取代了 UNIX 早期版本使用的 signal 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act,struct sigaction *oldact)</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/189474" alt="img"></p>
<p>参数的含义：</p>
<ul>
<li>signo ：信号的值，可以为除 SIGKILL 及 SIGSTOP 外的任何一个特定有效的信号；</li>
<li>act ：指向结构 sigaction 的一个实例的指针，在结构 sigaction 的实例中，<strong>指定了对特定信号的处理</strong>，但可以为空，进程会以<strong>缺省方式</strong>对信号处理；</li>
<li>oldact ：对象指针，指向的对象用来保存返回的原来对相应信号的处理，可指定 oldact 为 NULL 。</li>
</ul>
<p><strong>注：如果把第二、第三个参数都设为<code>NULL</code>，那么该函数可用于检查信号的有效性。</strong></p>
<p>返回值： 0 表示成功，-1 表示有错误发生。</p>
<p>功能： sigaction 函数用于<strong>改变</strong>进程接收到特定信号后的行为。</p>
<h5 id="sigaction结构体详解"><a href="#sigaction结构体详解" class="headerlink" title="sigaction结构体详解"></a>sigaction结构体详解</h5><p>sigaction 函数最重要的部分就是<strong>sigaction结构体</strong>，这个被应用于参数 act 和 oldact 中，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__sighandler_t</span> _sa_handler;</span><br><span class="line"><span class="keyword">void</span> (*_sa_sigaction)(<span class="keyword">int</span>,struct siginfo *, <span class="keyword">void</span> *)；</span><br><span class="line">&#125;_u</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask；</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>联合数据结构中的两个元素<code>_sa_handler</code>以及 _sa_sigaction <strong>指定信号关联函数</strong>，即用户指定的信号处理函数。除了可以是用户自定义的处理函数外，还可以为<strong>SIG_DFL</strong>(采用缺省的处理方式)，也可以为 SIG_IGN (忽略信号)；</li>
<li>由 _sa_sigaction 指定的信号处理函数带有三个参数，是为实时信号而设的，它指定一个<strong>三参数信号处理函数</strong>。第一个参数为信号值，第三个参数没有使用，第二个参数是指向 siginfo_t 结构的指针，结构中包含信号携带的数据值，参数所指向的结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">siginfo_t</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>      si_signo;  <span class="comment">/* 信号值，对所有信号有意义*/</span></span><br><span class="line"><span class="keyword">int</span>      si_errno;  <span class="comment">/* errno值，对所有信号有意义*/</span></span><br><span class="line"><span class="keyword">int</span>      si_code;   <span class="comment">/* 信号产生的原因，对所有信号有意义*/</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span>                               </span><br><span class="line"><span class="comment">/* 联合数据结构，不同成员适应不同信号 */</span></span><br><span class="line">    <span class="comment">//确保分配足够大的存储空间</span></span><br><span class="line">    <span class="keyword">int</span> _pad[SI_PAD_SIZE];</span><br><span class="line">    <span class="comment">//对SIGKILL有意义的结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">  ...</span><br><span class="line">    &#125;...</span><br><span class="line">... ...  </span><br><span class="line"><span class="comment">//对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;...</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sa_mask : <strong>信号集</strong>，指定在信号处理程序执行过程中，哪些信号应当<strong>被阻塞</strong>。<strong>缺省情况</strong>下当前信号本身被阻塞，防止信号的嵌套发送，除非指定 SA_NODEFER 或者 SA_NOMASK 标志位。</li>
</ul>
<p>注：请注意 sa_mask 指定的信号阻塞的前提条件：在<code>sigaction()</code>安装信号的处理函数执行过程中，由 sa_mask 指定的信号才会被阻塞。在使用 sigaction 之前，<strong>请务必清空或者设置自己所需要的屏蔽字段</strong>。</p>
<ul>
<li>sa_flags 中包含了许多标志位，包括 SA_NODEFER 及 SA_NOMASK 标志位。另一个比较重要的标志位是 SA_SIGINFO ，当设定了该标志位时，表示信号附带的参数可以被传递到信号处理函数中，因此，应该为 sigaction 结构中的 sa_sigaction 指定处理函数，而不应该为 sa_handler 指定信号处理函数，否则设置该标志变得毫无意义。即使为 sa_sigaction 指定了信号处理函数，如果不设置 SA_SIGINFO ，信号处理函数同样不能得到信号传递过来的数据，在信号处理函数中对这些信息的访问都将导致错误。 一般的做法是，如果采用 _sa_handler 作为处理函数，则将 sa_flags 设定为0；如果采用 _sa_sigaction 作为处理函数，则将 sa_flags 设定为 SA_SIGINFO。</li>
</ul>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">oldact</span>;</span></span><br><span class="line"><span class="comment">/*注册信号处理函数*/</span></span><br><span class="line">act.sa_handler = <span class="keyword">catch</span>;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);<span class="comment">//清空sa_mask，这点尤为重要</span></span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigaction(SIGINT, act ,oldact);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;catch signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行步骤如下：</p>
<ol>
<li>运行程序；</li>
<li>在 10s 内按键<code>CTRL +Ｃ</code>。</li>
</ol>
<p>运行结果如下： <code>hello!</code> <code>^Ccatch signal!</code> <code>hello!</code></p>
<h4 id="编程要求-16"><a href="#编程要求-16" class="headerlink" title="编程要求"></a>编程要求</h4><p>在主函数的最开始会初始化一个全部变量 g_i4event 为 0。</p>
<p>本关的编程任务是补全右侧代码片段中两段<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在 do _sigaction中分别为信号 SIGUSR1 、 SIGUSR2 注册信号处理函数 funcA 和 funcB ，而后将 g_i4event 置为 1；</li>
<li>完成两个信号处理函数，其中 funcA 中将 g_i4event 置为 2， funcB 中将 g_i4event 置为 3。</li>
</ul>
<p><strong>注：采用<code>_sa_sigaction</code>和<code>SA_SIGINFO</code>来实现。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_i4event;</span><br><span class="line"><span class="comment">/********Begin********/</span></span><br><span class="line"><span class="comment">/*实现funcA和funcB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The JD has notified the storehouse and installer\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The TV has delivered to your house from the storehouse\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The JD has notified the storehouse and installer\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The installer has arrived your house, but the TV is not delivered\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g_i4event==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The installer has installed your TV\n&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********End*********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sigaction</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********Begin********/</span></span><br><span class="line">	signal(SIGUSR1,funcA);</span><br><span class="line">	signal(SIGUSR2,funcB);  </span><br><span class="line">	g_i4event=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*********End*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux定时器"><a href="#Linux定时器" class="headerlink" title="Linux定时器"></a>Linux定时器</h2><h5 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h5><p>使用 alarm 函数可以设置一个定时器，在将来的某个时刻，这个定时器就会超时。当超时时，会产生 SIGALRM 信号。如果忽略或者不捕捉此信号，则其默认动作时终止调用该 alarm 函数的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </span><br></pre></td></tr></table></figure>

<p>参数： seconds ，是产生信号需要经过的时钟秒数，也就是定时器的时间。</p>
<p> alarm 安排内核调用进程——在指定的 seconds 秒后发出一个 SIGALRM 的信号。如果指定的参数 seconds 为 0 ，则不再发送 SIGALRM 信号。后一次设定将取消前一次的设定。该调用返回值为上次定时调用到发送之间剩余的时间，或者因为没有前一次定时调用而返回 0 。</p>
<p>注意，在使用时，alarm 只设定为发送一次信号，如果要多次发送，需要多次使用 alarm 调用。</p>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch alarm signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alarm(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">sighandler_t</span> res = signal(SIGALRM, <span class="keyword">catch</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wait for alarm signal!</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">sleep (<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span> <span class="keyword">for</span> alarm signal!</span><br><span class="line">catch alarm signal!</span><br></pre></td></tr></table></figure>


<p>在主函数的最开始会初始化一个全部变量 g_i4event 为 0 。</p>
<p>本关的编程任务是补全右侧代码片段中两段<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>在 do _alarm中首先启动 5s 定时器，将 g_i4event 置为 1；</li>
<li>睡眠一秒，然后为信号 SIGALRM 注册信号处理函数 funcalarm ，将 g_i4event 置为 2；</li>
<li>在信号处理函数，将 g_i4event 置为 3。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_i4event;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">/********Begin********/</span></span><br><span class="line"><span class="comment">/*实现funcA和funcB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(g_i4event==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;You set the alarm clock\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You start to work and wait for the alarm ring\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g_i4event==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now is 15:30, please leave home and go to apointment\n&quot;</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">g_i4event=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********End*********/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********Begin********/</span></span><br><span class="line">alarm(<span class="number">5</span>);</span><br><span class="line">g_i4event=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> res = signal(SIGALRM, funcA);</span><br><span class="line">sleep (<span class="number">1</span>);</span><br><span class="line">g_i4event=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********End*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FIFO管道使用"><a href="#FIFO管道使用" class="headerlink" title="FIFO管道使用"></a>FIFO管道使用</h2><p>本关将介绍命名管道的使用方法。对于命名管道和普通文件的操作一样，使用open函数打开，然后使用read和close进行读写操作，最后使用close函数对其进行关闭。与普通文件操作的不同点是：使用read读取普通文件，read不会阻塞。而read读取管道文件，read会阻塞运行，直到管道中有数据或者所有的写端关闭。 </p>
<p>命名管道相对比无名管道的好处是可以在两个不同的程序进行数据的传输。并且命名管道当写端彻底关闭后，读端read才会返回0。 注意：</p>
<p>如果管道的读端提前关闭，写端继续写入数据就会发生异常。 读端读取管道中的数据，只要读过的数据就会被清空 。 命名管道使用方法 创建命名管道的库函数是mkfifo，具体的说明如下：</p>
<p>需要的头文件如下： <code>#include &lt;sys/types.h&gt;</code> <code>#include &lt;sys/stat.h&gt;</code> 函数格式如下： <code>int mkfifo(const char *pathname, mode_t mode);</code> 参数说明： <code>pathname</code>：存放命名管道的文件名； <code>mode</code>：创建命名管道的权限，与创建文件的权限参数一致； mode设置说明：</p>
<p><code>S_IRUSR</code>： 文件所有者的读权限位 <code>S_IWUSR</code>： 文件所有者的写权限位 <code>S_IXUSR</code> ： 文件所有者的执行权限位 <code>S_IRGRP</code>： 所有者同组用户的读权限位 <code>S_IWGRP</code>： 所有者同组用户的写权限位 <code>S_IXGRP</code>： 所有者同组用户的执行权限位 <code>S_IROTH</code>： 其他用户的读权限位 <code>S_IWOTH</code>： 其他用户的写权限位 <code>S_IXOTH</code>： 其他用户的执行权限位 函数返回值说明： 调用成功时，返回值0；调用失败时，返回值为-1并设置错误编号errno。 案例演示1: 使用mkfifo函数在当前目录下创建一个命名管道testFIFO，并设置权限为644，并用来传送数据。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(<span class="string">&quot;testFIFO&quot;</span>, S_IRUSR |  S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道失败(%s)！\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为createFIFO.c文件，编译执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">&quot;This is test FIFO&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;testFIFO&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开命名管道失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为writeFIFO.c文件，编译执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;testFIFO&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开命名管道失败(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = read(fd, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道中的数据为：%s(%d个字符)\n&quot;</span>, buf, size);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为readFIFO.c文件，编译执行。 首先执行createFIFO程序来创建一个命名管道，然后执行writeFIFO程序用来向管道中写入数据，最后在另一个终端中执行readFIFO程序从管道中读取数据。</p>
<h3 id="编程要求-17"><a href="#编程要求-17" class="headerlink" title="编程要求"></a>编程要求</h3><p>本关的编程任务是补全右侧代码片段中Begin至End中间的代码，具体要求如下：</p>
<p>创建一个名为FIFO的命名管道文件，并设置权限为650。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(<span class="string">&quot;FIFO&quot;</span>, S_IRUSR |  S_IWUSR | S_IRGRP | S_IXGRP);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道失败(%s)！\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建命名管道成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>​                                     </p>
<h2 id="TCP套接字创建与端口绑定"><a href="#TCP套接字创建与端口绑定" class="headerlink" title="TCP套接字创建与端口绑定"></a>TCP套接字创建与端口绑定</h2><h4 id="相关知识-8"><a href="#相关知识-8" class="headerlink" title="相关知识"></a>相关知识</h4><p>在Linux系统中，每种协议都有自己的网络地址数据结构，这些数据结构都以<code>sockaddr_</code>开头，不同的是后缀表示不同的协议。最为常见的是<code>IPv4</code>协议，它的网络地址数据结构为<code>sockaddr_in</code>。</p>
<p>由于历史的缘故，在有些库函数中，特定协议的套接字地址结构都要强制转为通用的套接字地址结构，该数据结构被定义在<code>&lt;sys.socket.h&gt;</code>头文件中，详细定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sa_family;    <span class="comment">//套接字地址族</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_data[<span class="number">14</span>];   <span class="comment">//14个字节的协议地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_family</code>表示套接字的协议族类型，对应于<code>TCP/IP</code>协议该值为<code>AF_INET</code>；成员<code>sa_data</code>存储具体的协议地址。一般在编程中并不对该结构体进行操作，而是使用另一个与它等价的数据结构，例如，<code>IPv4</code>协议的网络地址数据结构为<code>sockaddr_in</code>，格式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family;    <span class="comment">/*地址类型*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;    <span class="comment">/* 端口号*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/*IP地址*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 填充字节，一般赋值为0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_family</code>表示套接字的协议族类型，对应于<code>TCP/IP</code>协议该值为<code>AF_INET</code>；<code>sin_port</code>表示端口号；<code>sin_addr</code>用来存储<code>32</code>位的<code>IP</code>地址，数组<code>sin_zero</code>为填充字段，一般赋值为<code>0</code>。</p>
<p><code>struct in_addr</code>的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span>    </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>  s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体<code>sockaddr</code>的长度为<code>16</code>字节，结构体<code>sockaddr_in</code>的长度也为<code>16</code>字节，通常在编写基于<code>TCP/IP</code>协议的网络程序时，使用结构体<code>sockaddr_in</code>来设置地址，然后通过强制类型转换成<code>sockaddr</code>类型。结构<code>sockaddr_in</code>与<code>sockaddr</code>的转换关系如下图所示：</p>
<p><img src="https://data.educoder.net/api/attachments/311998" alt="img"></p>
<p><code>TCP</code>网络编程是目前比较通用的方式，例如：<code>HTTP</code>协议、<code>FTP</code>协议等很多广泛应用的协议都是基于<code>TCP</code>协议实现的。<code>TCP</code>编程有两种模式，分别是服务器模式和客户端模式。无论是服务器模式还是客户端模式首先需要创建一个<code>TCP</code>套接字，对于服务器模式，我们还需要绑定一个本地端口。</p>
<p>Linux系统中提供了<code>socket</code>与<code>bind</code>两个系统调用函数用来创建套接字与绑定端口操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="创建TCP套接字"><a href="#创建TCP套接字" class="headerlink" title="创建TCP套接字"></a>创建TCP套接字</h5><p>Linux系统提供一个<code>socket</code>系统调用来创建一个套接字。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain：创建套接字所使用的协议族；type：套接字类型；protocol：用于指定某个协议的特定类型，通常某个协议中只有一种特定类型，这样该参数的值仅能设置为0；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>domain</code>参数的常用的协议族如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_UNIX</td>
<td>创建只在本机内进行通信的套接字</td>
</tr>
<tr>
<td>AF_INET</td>
<td>使用IPv4 TCP/IP协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>使用IPv6 TCP/IP协议</td>
</tr>
</tbody></table>
<p><code>type</code>参数的常用的套接字类型如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>创建TCP流套接字</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>创建UDP流套接字</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>创建原始套接字</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 执行成功返回值为一个新创建的套接字，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</li>
</ul>
<p>案例演示1: 创建一个使用<code>IPv4</code>协议族的<code>TCP</code>类型的套接字。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312726" alt="img"> 将以上代码保存为<code>createTCP.c</code>文件，编译执行。</p>
<h5 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h5><p>在<code>TCP</code>服务器模式编程中，我们需要讲一个端口绑定到一个已经建立的套接字上，这样方便客户端程序根据绑定的端口来连接服务器程序。Linux提供了一个<code>bind</code>函数来将一个套接字和某个端口绑定在一起。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：是一个指向sockaddr参数的指针，其中包含了IP地址、端口；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果创建套接字时使用的是AF_INET协议族，则addr参数所使用的结构体为struct sockaddr_in指针(详细定义见相关知识)。当设置addr参数的sin_addr为INADDR_ANY而不是某个确定的IP地址时，就可以绑定到任何网络接口。对于只有一个IP地址的计算机，INADDR_ANY对应的就是它的IP地址；对于有多个网卡的主机，INADDR_ANY表示本服务器程序将处理来自任何网卡上相应端口的连接请求。由于计算机中的字符与网络中的字符存储顺序不同。计算机中的整型数与网络中的整型数进行交换时，需要借用相关的函数进行转换。这些函数如下所示：</span><br><span class="line">uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure>

<p>使用<code>man 2 函数名</code>可以查看其详细的介绍。</p>
<p>案例演示1: 创建一个使用<code>IPv4</code>协议族的<code>TCP</code>类型的套接字，并与<code>6666</code>这个端口进行绑定。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口%d成功\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312731" alt="img"> 将以上代码保存为<code>bindPort.c</code>文件，编译执行。</p>
<h4 id="编程要求-18"><a href="#编程要求-18" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>bindSocket</code>函数中代码，绑定一个指定的本地端口。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * sockfd: 已经创建的套接字</span></span><br><span class="line"><span class="comment"> * port: 需要绑定的端口号</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindSocket</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    ret=bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP监听与接收连接"><a href="#TCP监听与接收连接" class="headerlink" title="TCP监听与接收连接"></a>TCP监听与接收连接</h2><h4 id="相关知识-9"><a href="#相关知识-9" class="headerlink" title="相关知识"></a>相关知识</h4><p>所谓<code>TCP</code>套接字的监听，指的是<code>TCP</code>套接字的端口处于等待状态，如果有客户端发出连接请求时，这个端口将会接受这个连接请求。连接指的是客户端向服务器发出一个通信请求，服务器会响应这个请求。</p>
<p>当服务器处于监听状态时，如果获得了一个客户端请求，则服务器将会将这个请求存放等待队列中。当系统处于空闲状态时，服务器将会从等待队列中取出请求，接受这个请求并处理这个请求。</p>
<p>Linux系统中提供了<code>listen</code>与<code>accept</code>两个系统调用函数用来监听和接受连接请求操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="TCP监听"><a href="#TCP监听" class="headerlink" title="TCP监听"></a>TCP监听</h5><p>Linux系统提供一个<code>listen</code>系统调用来实现监听等待功能。 <code>listen</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int listen(int sockfd, int backlog);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；backlog：能同时监听的最大连接请求；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong><code>listen</code>并未真正接受客户端的连接请求，只是设置<code>socket</code>的状态为<code>listen</code>模式。</p>
<p>案例演示1: 使用<code>listen</code>函数来监听指定端口的连接信息。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口%d成功\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置最大监听客户端数为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听端口%d失败: %s\n&quot;</span>, PORT, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听%d端口中...\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312837" alt="img"> 将以上代码保存为<code>listenPort.c</code>文件，编译执行。</p>
<h5 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h5><p>当服务器处理监听状态时，如果客户端发出一个连接请求，则服务器需要接受这个请求，并处理该请求。Linux提供了一个<code>accept</code>函数来接受客户端的连接请求。 <code>accept</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：保存发起连接请求的主机IP地址和端口信息；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功返回值为被接受请求的套接字编号，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong>当<code>accept</code>函数接受了一个连接时，会返回一个新的<code>socket</code>编号。接下来的数据传送与读取都是通过这个新的<code>socket</code>编号进行处理的。</p>
<p>案例演示1: 使用<code>accept</code>函数来接受客户端的请求，并打印出客户端主机的基本信息。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个TCP套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//与6666端口进行绑定</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口%d成功\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听6666端口，并设置最大监听个数为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听端口%d失败: %s\n&quot;</span>, PORT, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听%d端口中...\n&quot;</span>, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> clientSockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="comment">//接受连接请求</span></span><br><span class="line">    <span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求成功\n&quot;</span>);</span><br><span class="line">        <span class="comment">//inet_ntoa函数将网络地址转换成.点隔的字符串格式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址：%s \t 端口：%d\n&quot;</span>, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/312910" alt="img"> 将以上代码保存为<code>acceptClient.c</code>文件，编译执行。在浏览器中，输入<code>localhost:6666</code>进行请求，由于<code>HTTP</code>请求也是采用<code>TCP</code>协议进行传送，所以在对<code>6666</code>端口进行访问时，服务器接受了该请求，并打印出了发起连接请求客户端<code>IP</code>地址和端口。</p>
<h4 id="编程要求-19"><a href="#编程要求-19" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>main</code>函数中代码，监听<code>8888</code>号端口(设置监听的个数大于<code>1</code>)，并接受来自客户端的第一个连接请求。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="comment">//与8888端口进行绑定</span></span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听8888端口，并设置最大监听个数大于1</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">     listen(sockfd, <span class="number">5</span>);</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//接受来自客户端的第一个连接请求</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="keyword">int</span> clientSockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听8888端口成功，并且成功接受来自客户端的第一个请求\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP连接的建立与终止相关知识"><a href="#TCP连接的建立与终止相关知识" class="headerlink" title="TCP连接的建立与终止相关知识"></a>TCP连接的建立与终止相关知识</h2><p>所谓请求连接，指的就是在客户机上向服务器发送信息时，首先需要发送一个连接请求。当服务器接受了客户端的连接请求后，客户端就可以与服务器进行数据的交换。</p>
<p>所谓终止连接，指的就是客户端与服务器之间交换完数据后，需要断开当前连接并释放相关的资源，这样方便下一个客户端的请求。由于服务器同时处理的连接请求数是有限的，所以当客户端交换完数据后不终止连接就会导致后续请求的连接失败。</p>
<p>建立<code>TCP</code>连接时需要经历<code>3</code>次握手操作，主要步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接开始时，客户端发送SYN包，并包含了自己的初始序号a；服务器收到SYN包以后会回复一个SYN包，其中包含了对上一个a包的回应信息ACK和自己的初始序号b；客户端收到回应的SYN包以后，回复一个ACK包做响应；</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/313070" alt="img"> [<code>TCP</code>建立连接三次握手过程]</p>
<p>终止<code>TCP</code>连接时需要经历<code>4</code>次握手操作，主要步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先进行关闭的一方(即发送第一个FIN)将执行主动关闭，而另一方(收到这个FIN)执行被动关闭；当被动关闭方收到这个FIN，它发回一个ACK；被动关闭方发送一个FIN请求；主动关闭方收到这个FIN请求后，回复一个ACK请求；</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/313073" alt="img"> [<code>TCP</code>终止连接四次握手过程]</p>
<p>Linux系统中提供了<code>connect</code>与<code>close</code>两个系统调用函数用来建立和终止连接请求操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="TCP建立连接请求"><a href="#TCP建立连接请求" class="headerlink" title="TCP建立连接请求"></a>TCP建立连接请求</h5><p>Linux系统提供一个<code>connect</code>系统调用来实现连接目标网络服务功能。 <code>connect</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：指针要连接的服务器IP地址和端口信息；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 在上一关卡的案例中，我们实现了如何监听和接受连接，本案例将使用<code>connect</code>实现与上一关卡案例中的服务器建立连接关系。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求连接服务器失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求连接%s:%d成功\n&quot;</span>, SERVER_IP, PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/313107" alt="img"> 将以上代码保存为<code>connectServer.c</code>文件，编译执行。可以看到建立连接成功，服务器将客户端的<code>IP</code>地址和端口打印出来。<strong>注意：</strong>客户端的端口是随机分配的。</p>
<h5 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h5><p>当客户端与服务器进行数据交换完成后，我们需要断开已经建立的连接。Linux提供了两个函数来终止连接，分别是<code>close</code>函数和<code>shutdown</code>函数。</p>
<p><code>close</code>函数的使用方法与文件的关闭一样，只需将要关闭的套接字传给函数即可，此处就不做详细的介绍。</p>
<p><code>shutdown</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shutdown(int sockfd, int how);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经建立连接的套接字编号；how：具体的关闭行为；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>how</code>参数的常用取值及其含义如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHUT_RD</td>
<td>表示切断读，之后不能使用该套接字进行读操作</td>
</tr>
<tr>
<td>SHUT_WR</td>
<td>表示切断写，之后不能使用该套接字进行写操作</td>
</tr>
<tr>
<td>SHUT_RDWR</td>
<td>表示切断读写，与close函数功能一样</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</li>
</ul>
<h4 id="编程要求-20"><a href="#编程要求-20" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>connectSocket</code>函数中代码，向指定的服务器发出连接请求。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * ipAddr: 远程服务器的IP地址</span></span><br><span class="line"><span class="comment"> * port: 远程服务器的端口</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">char</span> *ipAddr, <span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接到指定的服务器</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(port);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(ipAddr);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TCP数据传送"><a href="#TCP数据传送" class="headerlink" title="TCP数据传送"></a>TCP数据传送</h2><h4 id="相关知识-10"><a href="#相关知识-10" class="headerlink" title="相关知识"></a>相关知识</h4><p>当创建好<code>TCP</code>套接字并且完成了客户端与服务器间的连接，接下来，我们就可以实现在客户端与服务器间的数据传送功能。</p>
<p>在客户端与服务器间进行数据传送时，一端(客户端/服务器)用于向建立好的套接字写入数据，另一端(服务器/客户端)用于从建立好的套接字中读取数据，这样一来一回的就实现了客户端与服务器间的数据交换功能。</p>
<p><img src="https://data.educoder.net/api/attachments/313259" alt="img"> [<code>TCP</code>服务器与客户端间的数据传送框架]</p>
<p>Linux系统中提供了<code>recv</code>、<code>send</code>、<code>read</code>和<code>write</code>四个系统调用函数用来完成客户端与服务器间的数据发送和接收操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="数据发送与接收方式一"><a href="#数据发送与接收方式一" class="headerlink" title="数据发送与接收方式一"></a>数据发送与接收方式一</h5><p>Linux系统提供<code>recv</code>和<code>send</code>系统调用来实现数据的发送与接收功能。 <code>recv</code>和<code>send</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；buf：用于存放接收和发送的数据；len：buf的长度；flags：设置接收与发送的控制选项，一般设置为0；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际接收或发送的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 使用<code>recv</code>和<code>send</code>函数实现客户端与服务器间的数据传送功能，客户端读取用户的数据并发送给服务器，服务器接收到数据后打印出来，当客户端读取到<code>exit</code>字符串时，关闭当前连接。详细代码如下所示：</p>
<p>客户端主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求连接服务器失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(gets(userInput) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strcasecmp(userInput, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            send(sockfd, userInput, <span class="built_in">strlen</span>(userInput), <span class="number">0</span>);  <span class="comment">//发送数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(sockfd);    <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>sendData.c</code>文件。</p>
<p>服务器主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建TCP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听6666端口，并设置最大监听个数为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;监听端口%d失败: %s\n&quot;</span>, PORT, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> clientSockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="comment">//接受连接请求</span></span><br><span class="line">    <span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接受客户端请求失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(userInput, <span class="number">0</span>, <span class="keyword">sizeof</span>(userInput));</span><br><span class="line">        <span class="keyword">while</span>(recv(clientSockfd, userInput, <span class="keyword">sizeof</span>(userInput), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端：%s\n&quot;</span>, userInput);</span><br><span class="line">            <span class="built_in">memset</span>(userInput, <span class="number">0</span>, <span class="keyword">sizeof</span>(userInput));  <span class="comment">//清空上次接收的缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(clientSockfd);  <span class="comment">//关闭客户端连接</span></span><br><span class="line">        close(sockfd);   <span class="comment">//关闭服务器套接字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>recvData.c</code>文件。</p>
<p><img src="https://data.educoder.net/api/attachments/313276" alt="img"> 编译执行以上两个程序，可以看到服务器接收到了客户端发过来的数据，并将其打印出来。<strong>注意：</strong>先执行<code>recvData</code>，再执行<code>sendData</code>程序。</p>
<h5 id="数据发送与接收方式二"><a href="#数据发送与接收方式二" class="headerlink" title="数据发送与接收方式二"></a>数据发送与接收方式二</h5><p>Linux系统可以使用<code>write</code>和<code>read</code>系统调用来实现数据的发送与接收功能。 <code>write</code>和<code>read</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd, const void *buf, size_t count);ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd：已经创建的套接字；buf：用于存放接收和发送的数据；count：buf的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际接收或发送的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>注意：</strong><code>write</code>和<code>read</code>函数的使用方法与文件的读写相同，此处就不做详细的案例介绍。</p>
<h4 id="编程要求-21"><a href="#编程要求-21" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>main</code>函数中代码，实现服务器与客户端间的数据传送功能。</li>
<li>将客户端发来的数据完全打印出来(<strong>提示：换行打印</strong>)，并且将接收到的数据原样发送给客户端。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="comment">//与PORT端口进行绑定</span></span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//监听PORT端口，并设置最大监听个数为5</span></span><br><span class="line">	<span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> clientSockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clientAddrSize = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">	<span class="comment">//接受连接请求</span></span><br><span class="line">	<span class="keyword">if</span>((clientSockfd = accept(sockfd, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrSize)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">		<span class="comment">//接收客户端传来的数据，并打印出来(提示：换行打印)</span></span><br><span class="line">		<span class="comment">//同时将接收到的数据原样发送给客户端</span></span><br><span class="line">		<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">		<span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="keyword">while</span>(recv(clientSockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, data);</span><br><span class="line">            send(clientSockfd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>);  <span class="comment">//发送数据</span></span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));  <span class="comment">//清空上次接收的缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/********** END **********/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(clientSockfd);</span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP套接字创建与端口绑定"><a href="#UDP套接字创建与端口绑定" class="headerlink" title="UDP套接字创建与端口绑定"></a>UDP套接字创建与端口绑定</h2><h4 id="相关知识-11"><a href="#相关知识-11" class="headerlink" title="相关知识"></a>相关知识</h4><p>所谓无连接的套接字通信，指的就是使用<code>UDP</code>协议进行数据的传输。使用这种协议进行通信时，两台计算机间是不需要建立连接的。</p>
<p>在实训<code>Linux之网络编程(TCP)</code>中，我们介绍了使用<code>TCP</code>协议进行数据的传输。<code>TCP</code>协议是需要在服务器与客户端间进行建立连接的，并且能够保证传输的数据可靠的到达对方。那么<code>TCP</code>协议与<code>UDP</code>协议的区别主要包括以下几点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接的，也就是在数据传输前需要建立连接；而UDP时无连接的，即数据传输前不需要建立连接；TCP提供可靠的服务，也就是使用TCP协议传输的数据不会丢失、不会重复并且按序到达；而UDP协议尽最大努力将数据传输到对方，即不保证可靠交付；由于TCP需要对数据进行校验保证可靠交付，所以其实时性不如UDP好；TCP对系统资源需求较大；而UDP相对需求较少；</span><br></pre></td></tr></table></figure>

<p>由于<code>UDP</code>以简单、传输快的优势，在很多应用场景下取代了<code>TCP</code>。例如：在视频会议、语音通话场景下，<code>UDP</code>协议就比<code>TCP</code>协议更适合。因为，视频和语音丢部分内容不会影响到结果，而这些对实时性要求很高，所以采用<code>UDP</code>协议更适合。</p>
<p>在编程方面，<code>UDP</code>使用到的数据结构与<code>TCP</code>一致。例如在<code>IPv4</code>协议下，都使用<code>struct sockaddr_in</code>结构体来表示网络地址信息。</p>
<p>Linux系统中提供了<code>socket</code>与<code>bind</code>两个系统调用函数用来创建套接字与绑定端口操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="创建UDP套接字"><a href="#创建UDP套接字" class="headerlink" title="创建UDP套接字"></a>创建UDP套接字</h5><p>Linux系统提供一个<code>socket</code>系统调用来创建一个套接字。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain：创建套接字所使用的协议族；type：套接字类型；protocol：用于指定某个协议的特定类型，通常某个协议中只有一种特定类型，这样该参数的值仅能设置为0；</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>domain</code>参数的常用的协议族如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_UNIX</td>
<td>创建只在本机内进行通信的套接字</td>
</tr>
<tr>
<td>AF_INET</td>
<td>使用IPv4 TCP/IP协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>使用IPv6 TCP/IP协议</td>
</tr>
</tbody></table>
<p><code>type</code>参数的常用的套接字类型如下表所示：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>创建TCP流套接字</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>创建UDP流套接字</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>创建原始套接字</td>
</tr>
</tbody></table>
<ul>
<li>函数返回值说明： 执行成功返回值为一个新创建的套接字，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</li>
</ul>
<p>案例演示1: 创建一个使用<code>IPv4</code>协议族的<code>UDP</code>类型的套接字。详细代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/314427" alt="img"> 将以上代码保存为<code>createUDP.c</code>文件，编译执行。</p>
<h5 id="绑定端口-1"><a href="#绑定端口-1" class="headerlink" title="绑定端口"></a>绑定端口</h5><p>在<code>UDP</code>服务器模式编程中，我们需要将一个端口绑定到一个已经创建好的套接字上，这样方便客户端程序根据绑定的端口来向服务器传输数据。Linux提供了一个<code>bind</code>函数来将一个套接字和某个端口绑定在一起。 <code>socket</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下： <code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code> 参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；addr：是一个指向sockaddr参数的指针，其中包含了IP地址、端口；addrlen：addr结构的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为<code>0</code>，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p><strong>提示：</strong>使用<code>bind</code>函数为<code>UDP</code>协议绑定一个端口的使用方法与为<code>TCP</code>协议绑定端口一致，详细介绍请参看实训<a target="_blank" rel="noopener" href="https://www.educoder.net/shixuns/4hlmn9wo/challenges"> Linux之网络编程(TCP) </a>中的第一关卡内容。</p>
<h4 id="编程要求-22"><a href="#编程要求-22" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>UDPSocket</code>函数中代码，创建一个<code>UDP</code>套接字，并绑定一个指定的本地端口。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment"> * port: 需要绑定的端口号</span></span><br><span class="line"><span class="comment"> * 返回值: 调用成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPSocket</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr_inet</span>;</span></span><br><span class="line">    adr_inet.sin_family=AF_INET;</span><br><span class="line">	adr_inet.sin_port=htons(port);</span><br><span class="line">	adr_inet.sin_addr.s_addr =htonl(INADDR_ANY);</span><br><span class="line">	bzero(&amp;(adr_inet.sin_zero),<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd,(struct sockaddr *)&amp;adr_inet,<span class="keyword">sizeof</span>(adr_inet))!=<span class="number">-1</span>)&#123;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP数据传送"><a href="#UDP数据传送" class="headerlink" title="UDP数据传送"></a>UDP数据传送</h2><h4 id="相关知识-12"><a href="#相关知识-12" class="headerlink" title="相关知识"></a>相关知识</h4><p>由于<code>UDP</code>协议不需要建立连接即可进行数据的传输，在服务器端创建好<code>UDP</code>套接字并绑定一个本地端口后，接下来，我们就可以实现在客户端与服务器间的数据传送功能。</p>
<p>在客户端与服务器间进行数据传送时，一端(客户端/服务器)用于向建立好的套接字写入数据，另一端(服务器/客户端)用于从建立好的套接字中读取数据，这样一来一回的就实现了客户端与服务器间的数据交换功能。</p>
<p>在实训<code>Linux之网络编程(TCP)</code>中介绍的<code>TCP</code>数据传输使用到的函数是<code>recv</code>、<code>send</code>、<code>read</code>和<code>write</code>四个系统调用。而<code>UDP</code>协议数据传输使用的函数是<code>sendto</code>和<code>recvfrom</code>两个系统调用函数。</p>
<p>Linux系统中提供了<code>sendto</code>和<code>recvfrom</code>两个系统调用函数用来完成<code>UDP</code>协议的客户端与服务器间的数据发送和接收操作。</p>
<p>以上函数我们可以使用<code>man</code>命令来查询该函数的使用方法。具体的查询命令为：<code>man 2 函数名</code>。</p>
<h5 id="UDP协议的数据发送"><a href="#UDP协议的数据发送" class="headerlink" title="UDP协议的数据发送"></a><code>UDP</code>协议的数据发送</h5><p>Linux系统提供<code>sendto</code>系统调用来实现数据的发送功能。 <code>sendto</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；buf：用于存放接收和发送的数据；len：buf的长度；flags：设置接收与发送的控制选项，一般设置为0；dest_addr：要发往主机的网络地址信息；addrlen：dest_addr的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际发送的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<h5 id="UDP协议的数据接收"><a href="#UDP协议的数据接收" class="headerlink" title="UDP协议的数据接收"></a><code>UDP</code>协议的数据接收</h5><p>Linux系统可以使用<code>recvfrom</code>系统调用来实现数据的接收功能。 <code>recvfrom</code>函数的具体的说明如下：</p>
<ul>
<li><p>需要的头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>函数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd：已经创建的套接字；buf：用于存放接收和发送的数据；len：buf的长度；flags：设置接收与发送的控制选项，一般设置为0；src_addr：要接收主机的网络地址信息；addrlen：src_addr的长度；</span><br></pre></td></tr></table></figure></li>
<li><p>函数返回值说明： 调用成功，返回值为实际接收的数据字节个数，否则返回<code>-1</code>，并设置错误代码<code>errno</code>。</p>
</li>
</ul>
<p>案例演示1: 利用<code>UDP</code>协议实现如下功能：使用<code>recvfrom</code>和<code>sendto</code>函数实现客户端与服务器间的数据传送功能，客户端读取用户的数据并发送给服务器，服务器接收到数据后打印出来，当客户端读取到<code>exit</code>字符串时，关闭当前客户端套接字，当服务器收到<code>exit</code>字符串时，关闭当前服务器套接字。详细代码如下所示：</p>
<p>客户端主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(gets(userInput) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sendto(sockfd, userInput, <span class="keyword">sizeof</span>(userInput), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));  <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(userInput, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);    <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>sendData.c</code>文件。</p>
<p>服务器主要代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="keyword">char</span> userInput[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(recvfrom(sockfd, userInput, <span class="keyword">sizeof</span>(userInput), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(strcasecmp(userInput, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端：%s\n&quot;</span>, userInput);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);   <span class="comment">//关闭服务器套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>recvData.c</code>文件。</p>
<p><img src="https://data.educoder.net/api/attachments/314481" alt="img"> 编译执行以上两个程序，可以看到服务器接收到了客户端发过来的数据，并将其打印出来。 <strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先执行recvData，再执行sendData程序；由于UDP协议可以实现多个客户端对于一个服务器，所以当客户端退出后，服务器是不会退出的，因此，我们通过接收客户端传来的数据来判断是否服务器也需要退出；</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-23"><a href="#编程要求-23" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>补全<code>main</code>函数中代码，使用<code>UDP</code>协议实现服务器与客户端间的数据传送功能。</li>
<li>将客户端发来的数据完全打印出来(<strong>提示：换行打印</strong>)，并且将接收到的数据原样发送给客户端。</li>
<li>当服务器收到<code>exit</code>字符串时，退出当前服务器程序(<strong>提示：不打印退出字符串exit</strong>)。</li>
<li><strong>提示：</strong>在每次接收字符串前要将存放字符串的变量清空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="comment">//与PORT端口进行绑定</span></span><br><span class="line">	<span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">	<span class="comment">//接收客户端传来的数据，并打印出来(提示：换行打印)</span></span><br><span class="line">	<span class="comment">//同时将接收到的数据原样发送给客户端</span></span><br><span class="line">	<span class="comment">//当接收到&quot;exit&quot;字符串时，退出当前程序，不打印出&quot;exit&quot;字符串</span></span><br><span class="line">	<span class="comment">//提示：在每次接收字符串前要将存放字符串的变量清空</span></span><br><span class="line">	<span class="comment">/********** BEGIN **********/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">	<span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">        <span class="keyword">while</span>(recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span> ,(struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strcasecmp(data, <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, data);</span><br><span class="line">            sendto(sockfd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span> ,(struct sockaddr *)&amp;clientAddr, <span class="keyword">sizeof</span>(clientAddr));  <span class="comment">//发送数据</span></span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));  <span class="comment">//清空上次接收的缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line"></span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP项目实战"><a href="#UDP项目实战" class="headerlink" title="UDP项目实战"></a>UDP项目实战</h2><h4 id="相关知识-13"><a href="#相关知识-13" class="headerlink" title="相关知识"></a>相关知识</h4><p>通过前2关的学习，我们学会如何使用<code>UDP</code>协议来在不同的计算机间传输数据。使用<code>UDP</code>协议通信时，客户端与服务器的交互过程如下图所示：</p>
<p><img src="https://data.educoder.net/api/attachments/315383" alt="img">                       [<code>UDP</code>协议的套接字通信]</p>
<p>利用以上2关的知识就可以简单的文件上传工具。该工具包含两部分内容，分别是接收文件的服务器和上传文件的客户端。</p>
<h5 id="实现文件上传工具-服务器端"><a href="#实现文件上传工具-服务器端" class="headerlink" title="实现文件上传工具-服务器端"></a>实现文件上传工具-服务器端</h5><p>实现文件上传服务器主要分为以下几个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先是接收要上传的文件名称；当接收到客户端发来的文件名称后，在本地创建该文件；从客户端中接收文件的内容，并保存在创建好的文件中；当客户端上传文件内容接收后，服务器关闭创建的文件；</span><br></pre></td></tr></table></figure>

<p>通过以上几步就可以实现文件上传服务器的功能。为了识别客户端发送来的数据类型，我们定义了以下协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们定义客户端与服务器间的数据块为1024KB(也就是每次传输的数据大小)；我们将每个数据块的前1个字节定义为数据块的类型，也就是用于标示该数据块中的内容是文件名称或文件内容或上传结束，我们使用f表示该数据块为文件名称，c标示该数据块为文件内容，e表示上传结束；</span><br></pre></td></tr></table></figure>

<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义数据块大小</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//定义服务器端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6667</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));    <span class="comment">//清空</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定本地6666端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;绑定端口失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存放客户端主机信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientAddrLen = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> recvLen;</span><br><span class="line">    <span class="comment">//接收来自客户端发来的数据</span></span><br><span class="line">    <span class="keyword">while</span>((recvLen = recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据自定义的协议来判断客户端发送来的数据块类型</span></span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//上传文件完成，关闭当前打开的文件</span></span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据块是上传文件的名称，在本地创建该文件</span></span><br><span class="line">            fd = open(&amp;(data[<span class="number">1</span>]), O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收客户端上传的%s文件...\n&quot;</span>, &amp;(data[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据块为上传文件的内容，将内容写入到新创建的文件中</span></span><br><span class="line">            <span class="comment">//因为data的第一个字符为文件块类型，所以只需从第二个字符开始写文件</span></span><br><span class="line">            write(fd, &amp;(data[<span class="number">1</span>]), recvLen - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给客户端回复一个接收确认的标识OK</span></span><br><span class="line">        sendto(sockfd, <span class="string">&quot;OK&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;OK&quot;</span>), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, clientAddrLen);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);   <span class="comment">//关闭服务器套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>uploadFileServer.c</code>文件中，编译执行。</p>
<h5 id="实现文件上传工具-客户端"><a href="#实现文件上传工具-客户端" class="headerlink" title="实现文件上传工具-客户端"></a>实现文件上传工具-客户端</h5><p>实现文件上传客户端主要分为以下几个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先是获取要上传文件的名称，并将该名称发送给服务器；当收到服务器的回复后，打开文件并读取内容，将读取的内容发送给服务器；当文件所有内容发送完成后，给服务器发送一个上传完成的标识，并退出客户端；</span><br></pre></td></tr></table></figure>

<p>通过以上几步就可以实现文件上传客户端的功能。我们遵循在实现服务器时定义的协议，同时为了有序的将文件内容发送到服务器，因此，我们需要服务器每次接收成功一块数据后，给客户端返回一个标识，当客户端收到该标识后再继续发送下一块的内容。</p>
<p>详细的代码设计为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义数据块大小</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//定义服务器端口和服务器地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 6667</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建UDP套接字失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> servAddrLen = <span class="keyword">sizeof</span>(servAddr);</span><br><span class="line">    bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));    <span class="comment">//清空</span></span><br><span class="line">    servAddr.sin_family = AF_INET;</span><br><span class="line">    servAddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//使用inet_addr函数将点分十进制的IP转换成一个长整数型数</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="keyword">char</span> filePath[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//读取要上传文件的路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入上传的文件路径+名称: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filePath);</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;f&#x27;</span>;  <span class="comment">//根据上传协议，设置数据块类型为文件名称</span></span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;(data[<span class="number">1</span>]), filePath);</span><br><span class="line">    <span class="comment">//向服务器发送要上传文件的名称</span></span><br><span class="line">    sendto(sockfd, data, <span class="built_in">strlen</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//等待服务器接收确认，然后再继续上传文件内容</span></span><br><span class="line">    recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen);</span><br><span class="line">    <span class="keyword">int</span> fd = open(filePath, O_RDONLY);    <span class="comment">//打开要上传的文件</span></span><br><span class="line">    <span class="keyword">int</span> readSize = <span class="number">0</span>;</span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;   <span class="comment">//设置数据块类型为文件内容</span></span><br><span class="line">    <span class="comment">//循环读取文件内容(注意:一次实际读取的文件内容最大字符个数为1023)</span></span><br><span class="line">    <span class="keyword">while</span>((readSize = read(fd, &amp;(data[<span class="number">1</span>]), <span class="number">1023</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>))) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将读取到的文件内容连同数据块类型标识一起发送给服务器</span></span><br><span class="line">        sendto(sockfd, data, readSize+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">        <span class="comment">//等待服务器接收确认，然后再上传文件下一块的内容</span></span><br><span class="line">        recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen);</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当文件内容上传完成后，发送上传结束标识</span></span><br><span class="line">    data[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    sendto(sockfd, data, <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">    close(fd);</span><br><span class="line">    close(sockfd);   <span class="comment">//关闭客户端套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上代码保存为<code>uploadFileClient.c</code>文件中，编译执行。</p>
<p><img src="https://data.educoder.net/api/attachments/316310" alt="img"> 编译执行，我们可以看到客户端将要上传的文件成功上传到了服务器。 <strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为同一目录下不能存在两个名称相同的文件，因此不要将服务器程序放置到与上传文件所在的目录下；首先要先执行服务器程序uploadFileServer，然后再执行客户端程序uploadFileClient；</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-24"><a href="#编程要求-24" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li><p>补全<code>downloadFileClient</code>函数，该函数是用来从服务器上下载一个指定的文件，实现下载文件的客户端部分。</p>
</li>
<li><p>下载文件要遵循以下步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先向服务器发送当前要下载的文件名称；从服务器接收数据块；向服务器发送一个接收确认请求(例如发送OK字符串)；重复第2步骤，直到收到的数据块类型为下载文件结束时，关闭当前打开的文件，然后退出程序；</span><br></pre></td></tr></table></figure></li>
<li><p>客户端与服务器间所遵循以下下载协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们定义客户端与服务器间的数据块为16KB(也就是每次传输的数据大小)；我们将每个数据块的前1个字节定义为数据块的类型，也就是用于标示该数据块中的内容是文件内容还是下载结束标识，我们使用c标示该数据块为文件内容，e表示下载结束；</span><br></pre></td></tr></table></figure></li>
<li><p><strong>提示：</strong>首先客户端向服务器先发送要下载文件的名称，告诉服务器要下载哪个文件；然后服务器读取文件，并发送给客户端。下载文件的客户端实现部分与以上案例中介绍的上传文件服务器端的实现大致相同，请仔细参看以上案例的实现。</p>
</li>
</ul>
<p>文件下载工具的服务器端的核心伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收要下载的文件名称</span></span><br><span class="line">recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line"><span class="comment">//数据块是下载文件的名称，在本地打开该文件</span></span><br><span class="line">fd = open(filePath, O_RDONLY);</span><br><span class="line"><span class="comment">//设置数据块类型为文件内容</span></span><br><span class="line">data[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> readSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//读取要下载文件的数据</span></span><br><span class="line"><span class="keyword">while</span>((readSize = read(fd, &amp;(data[<span class="number">1</span>]), <span class="number">15</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>))) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    sendto(sockfd, data, readSize+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, clientAddrLen);</span><br><span class="line">    <span class="comment">//等待客户端的接收确认</span></span><br><span class="line">    recvfrom(sockfd, ack, <span class="keyword">sizeof</span>(ack), <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">    <span class="comment">//清空data文件数据部分</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;(data[<span class="number">1</span>]), <span class="number">0</span>, <span class="keyword">sizeof</span>(data)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当文件内容读取完成后，发送下载结束标识</span></span><br><span class="line">data[<span class="number">0</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">sendto(sockfd, data, <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;clientAddr, clientAddrLen); </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数据块大小</span></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//定义服务器端口和服务器地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8889</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> servAddrLen = <span class="keyword">sizeof</span>(servAddr);</span><br><span class="line">	bzero(&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));</span><br><span class="line">	servAddr.sin_family = AF_INET;</span><br><span class="line">	servAddr.sin_port = htons(PORT);</span><br><span class="line">	servAddr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//由用户传入的要下载文件的名称</span></span><br><span class="line">	<span class="keyword">char</span> *downLoadFileName = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//先在本地创建要下载的文件</span></span><br><span class="line">	<span class="keyword">int</span> fd = fd = open(downLoadFileName, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">	<span class="comment">//向服务器发送要上传文件的名称</span></span><br><span class="line">	sendto(sockfd, downLoadFileName, <span class="built_in">strlen</span>(downLoadFileName), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen); </span><br><span class="line">	</span><br><span class="line">    <span class="comment">/********** BEGIN **********/</span></span><br><span class="line">	<span class="comment">//等待服务器接收确认，然后再继续上传文件内容</span></span><br><span class="line">    <span class="keyword">int</span> recvLen = <span class="number">0</span>;</span><br><span class="line">    recvLen =recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen);</span><br><span class="line">    write(fd, &amp;(data[<span class="number">1</span>]), recvLen - <span class="number">1</span>);</span><br><span class="line">    sendto(sockfd, <span class="string">&quot;OK&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;OK&quot;</span>), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//data[0] = &#x27;c&#x27;;   //设置数据块类型为文件内容</span></span><br><span class="line">    <span class="comment">//循环读取文件内容(注意:一次实际读取的文件内容最大字符个数为1023)</span></span><br><span class="line">    <span class="keyword">while</span>((recvLen=recvfrom(sockfd, data, <span class="keyword">sizeof</span>(data), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, &amp;servAddrLen)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据自定义的协议来判断客户端发送来的数据块类型</span></span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下载文件完成，关闭当前打开的文件</span></span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据块为下载文件的内容，将内容写入到新创建的文件中</span></span><br><span class="line">            <span class="comment">//因为data的第一个字符为文件块类型，所以只需从第二个字符开始写文件</span></span><br><span class="line">            write(fd, &amp;(data[<span class="number">1</span>]), recvLen - <span class="number">1</span>);</span><br><span class="line">            sendto(sockfd, <span class="string">&quot;OK&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;OK&quot;</span>), <span class="number">0</span>, (struct sockaddr *)&amp;servAddr, servAddrLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/********** END **********/</span></span><br><span class="line">	</span><br><span class="line">	close(sockfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select机制"><a href="#select机制" class="headerlink" title="select机制"></a>select机制</h2><h4 id="相关知识-14"><a href="#相关知识-14" class="headerlink" title="相关知识"></a>相关知识</h4><p><code>select</code>机制是一种很常见的多路复用方法，准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。 当调用<code>select()</code>时，由内核根据 IO 状态修改 fd_set 的内容，由此来通知执行了<code>select()</code>的进程的那个 Socket 或文件可读或可写。主要用于 Socket 通信当中。</p>
<h5 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h5><p>使用<code>select()</code>可以完成非阻塞（所谓非阻塞方式 non-block ，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生，则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)</span><br></pre></td></tr></table></figure>

<p><img src="https://data.educoder.net/api/attachments/187172" alt="img"></p>
<p>######函数参数 通过传递函数参数告知内核以下三个信息： - 我们所关心的描述符； - 对于每个描述符我们关心的条件（读，写，异常）； - 希望等待多长时间（永久等待，等一段时间，不等待）。</p>
<p>函数参数详解如下：</p>
<ul>
<li>第一个参数 maxfdp1 指定待测试的描述字个数，它的值是待测试的最大描述字加 1 （因此把该参数命名为 maxfdp1），描述字<code>0,1,2...,maxfdp1-1</code>均将被测试。文件描述符是从 0 开始的。</li>
<li>中间的三个参数 readset 、writeset 和 exceptset 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code>可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;<span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 检查集合中指定的文件描述符是否可以读写 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>timeout</code>告知内核等待所指定描述字中的任何一个就绪可花多少时间。其<code>timeval</code>结构用于指定这段时间的秒数和微秒数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个参数有三种可能：</p>
<ul>
<li><p>永远等待下去：仅在有一个描述字准备好 I/O 时才返回。为此，把该参数设置为空指针 NULL 。</p>
</li>
<li><p>等待一段固定时间：在有一个描述字准备好 I/O 时返回，但是不超过由该参数所指向的 timeval 结构中指定的秒数和微秒数。</p>
</li>
<li><p>根本不等待：检查描述字后立即返回，这称为轮询。为此，该参数必须指向一个 timeval 结构，而且其中的定时器值必须为 0。</p>
<h6 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h6><p>select 函数返回，内核告诉我们：</p>
</li>
<li><p>已准备好的描述符数量。</p>
</li>
<li><p>哪个描述符已准备好读、写、或异常。 使用该返回值，就可以调用相应的 I/O 函数(read，write)，并且明确知道该函数不会阻塞。</p>
</li>
</ul>
<p>返回值如下：</p>
<ul>
<li>返回 -1，表示出错，例如指定的描述符集都没准备好时捕捉到一个信号。</li>
<li>返回 0，表示没有描述符准备好，指定的时间已经超过。</li>
<li>返回<strong>正值</strong>，表示已经准备好的描述符数，三个描述符集中仍旧打开的位是对应已准备好的描述符位。</li>
</ul>
<p>整个 select 流程如下：</p>
<p><img src="https://data.educoder.net/api/attachments/187169" alt="img"></p>
<p>应用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">fd_set readfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">&#123; </span><br><span class="line">ret=select(fd+<span class="number">1</span>,&amp;readfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;timeout);  </span><br><span class="line"><span class="keyword">if</span>(ret)<span class="comment">//返回正值</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-25"><a href="#编程要求-25" class="headerlink" title="编程要求"></a>编程要求</h4><p>本关的编程任务是补全右侧代码片段中<code>Begin</code>至<code>End</code>中间的代码，具体要求如下：</p>
<ul>
<li>将文件描述符加入到读集合中去。</li>
<li>设置 3s 超时机制。</li>
<li>检测 I/O 有变化，读取文件中的数据。</li>
<li>注意：数据读取完后，立刻退出函数体，以免造成死循环.</li>
<li>具体请参见后续测试样例。</li>
</ul>
<p>本关涉及的代码文件<code>SelectDamo.c</code>的代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="comment">/*buffer为数据缓冲区，将读取的到数据填充进来*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*********Begin*******/</span></span><br><span class="line">    <span class="comment">/**********End********/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*********Begin*******/</span></span><br><span class="line">    fd_set readfd;</span><br><span class="line">    FD_ZERO(&amp;readfd);</span><br><span class="line">    FD_SET(fd,&amp;readfd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec=<span class="number">3</span>; </span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123; </span><br><span class="line">        ret=select(fd+<span class="number">1</span>,&amp;readfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;timeout);  </span><br><span class="line">        <span class="keyword">if</span>(ret)<span class="comment">//返回正值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//int readSize = 0;</span></span><br><span class="line">            <span class="comment">//char tempC[BUFFER_SIZE];</span></span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">1</span>,length=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//while(1)&#123;</span></span><br><span class="line">                temp = read(fd, buffer, BUFFER_SIZE);</span><br><span class="line">                 <span class="comment">/*if(buffer[length-1]==0|buffer[length-1]==&#x27;\n&#x27;)&#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;else&#123;</span></span><br><span class="line"><span class="comment">                    readSize = readSize+1;</span></span><br><span class="line"><span class="comment">                    buffer[length++]=tempC;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**********End********/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Unix程序设计课堂知识点整理
        
      </div>
    </a>
  
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=Unix程序设计头歌知识点整理 - YZz&url=http://www.zalex.top/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%B4%E6%AD%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=Unix程序设计头歌知识点整理 - YZz&u=http://www.zalex.top/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%B4%E6%AD%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=Unix程序设计头歌知识点整理 - YZz&url=http://www.zalex.top/2021/11/19/Unix%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%B4%E6%AD%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>












<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KafKa/" rel="tag">KafKa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/" rel="tag">Unix</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2021/12/07/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_Maven/">记录一次Maven问题解决</a>
          </li>
        
          <li>
            <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_KafKa/">KafKa学习路上遇到的问题</a>
          </li>
        
          <li>
            <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_SpringBoot/">SpringBoot学习路上遇到的问题</a>
          </li>
        
          <li>
            <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">Hexo博客搭建路上遇到的问题</a>
          </li>
        
          <li>
            <a href="/2021/11/19/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88_MyBatis/">MyBatis学习路上遇到的问题</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            YZz &copy; 2021<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1637200696663.js"></script>


<script src="/dist/custom.js?1637200696663.js"></script>



<!-- 百度链接提交 -->
<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>



<!-- Google Analytics-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXX-X"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-XXXXX-X');
</script>





</body>

</html>